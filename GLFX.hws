/*************/
/* GLFX v1.0 */
/*************/

/* TODO STUFF ARE MARKED WITH #TODO#    */

/* CHANGE LOG
   ==========
   11/04/2021
    Clean up and source docs and notes
   10/04/2021
    Removed : Useless functions from the previous version
   25/11/2020
    Removed : Background class, all can be done with the sprite class.
    Removed : GLFX.HeightMap_Generate() -> Not needed anymore
    Removed : GLFX.Background:HMap_GetTerrainHeight() -> Not needed anymore
    Removed : GLFX.Background:Create() -> Not needed anymore
    Removed : GLFX.Background:Move() -> Not needed anymore
    Removed : GLFX.Background:HMap_AddSerie() -> Not needed anymore
    Removed : GLFX.Background:HMap_AttachSprite() -> Not needed anymore
    Removed : GLFX.Background:HMap_DetachSprite() -> Not needed anymore
    Removed : GLFX.Background:Draw() -> Not needed anymore
    Removed : GLFX.Background:Update() -> Not needed anymore
   26/11/2020
    Docs : Doc comments for the SPRITE Object
    Docs : GLFX.Sprite:_UpdateAnimation() doc comments added
    Docs : GLFX.Sprite:SetAnimationFrame() doc comments added
    Docs : GLFX.Sprite:_UpdatePolyColl() doc comments added
    Docs : GLFX.Sprite:SetBoundaries() doc comments added
    
/* POWEROFTWO
   ----------
   MorphOS, AmigaOS4 and AmigaOS3 need that texture sizes have to be a
   power of two, otherwise nothing is showed to the screen.
   ----------
   Patched functions:
   - Sprite:Load()
   - Particle textures loaded at runtime
   - Sprite:NewFromText()
*/


/* THINGS TO IMPLEMENT
   -------------------
   - Utility : Particle System Editor, it should produce a *.psys file with
               all needed stuff embedded, including textures.
               Associated methods : GLFX.ParticleSystem:Load()
                                    GLFX.ParticleSystem:Save()

   - Macro / Scene : Loading Screen
       Should be able to define an animated loading screen with a
       progress bar used to show loading progresses, something like:
         GLFX.LoadingScreen:New()
         GLFX.LoadingScreen:Show()
         GLFX.LoadingScreen:Hide()
         GLFX.LoadingScreen:Free()
         GLFX.LoadingScreen:Update()
       Basically it could be a macro that setups a scene.

   - Macro / Scene : Title Screen
       Defines an animated title screen with a list of available options (menu)
       that the player can select.
       
   - Macro / Scene : Hiscore
       Defines an animated hiscores screen to show the hiscores.
       
   - Macro / Scene : Credits
       Defines an animated credits screen to show the game / prod credits.

  -----
  PARTICLE SYSTEM
  ---------------
    I have ot add the following methods:
      :attractor()
      :repeller()
      
  -----
  AI
  --
    - Path searching and AI scripts
    
  -----
  TILES
  -----
    - Tiles system
    
  -----
  WHOLE SCREEN EFFECTS
  --------------------
    - Rotation, Scaling, etc...
    
  -----
  DOT PARTICLES
    - A simplified and faster version of the particle system which uses dots
    
  -----
  ACTORS
  ------
    - Actors class
    
  ------
  3D
  --
    - Add support for 3D backgrounds & objects
  
  -----
  COLLISIONS
  ----------
  Methods to add:
    :CollisionsWithGroup(args)      Enables sprite-group collisions
    .Group.SetCollisions(args)      Enables group-group collisions
    .Group.ClearCollisions(args)    Disables group-group collisions
    
*/




@REQUIRE "GLGalore"
@INCLUDE "+Includes.hws"
@INCLUDE #INC_HELPERS
@INCLUDE #INC_TABLES
@INCLUDE #INC_DEBUG
@INCLUDE #INC_GFX
@INCLUDE #INC_G2D
@INCLUDE #INC_EASING

Const #SIMPLE_SPRITE   = 1
Const #COMPLEX_SPRITE  = 2
Const #BACKGROUND      = 3
Const   #BGTYPE_PARALLAX = 31
Const   #BGTYPE_TILEMAP  = 32
Const   #BGTYPE_STATIC   = 33
Const   #BGTYPE_DYNAMIC  = 34
Const   #BGTYPE_HEIGHTMAP= 35
Const   #BGREPEAT_H      =  1
Const   #BGREPEAT_V      =  2

Const #SE_ATYPE_INTERVAL = 1
Const #SE_ATYPE_TIMEOUT  = 2

Const #POLY_DOT = 0
Const #POLY_BOX = 1
Const #POLY_OCTA = 2
Const #POLY_TRIANGLE = 3

@DISPLAY { width = 640, height = 480, sizeable = True }

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::: FRAMEWORK ROOT CLASS ::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Global GLFXCh = "GLFX"

Global GLFX = {}
       GLFX.SpriteEngines   = {}              ; All existing Sprite Engines
       GLFX.ParticleSystems = {}              ; All existing Particle Systems
       GLFX.Display     = 1                   ; Display used for this GLFX context
       GLFX.Mode        = #DISPMODE_WINDOWED  ; Display Mode
       GLFX.Width       = 640                 ; Display Width
       GLFX.Height      = 480                 ; Display Height
       GLFX.Title       = "GLFX App"          ; Display Title
       GLFX.Fixed       = False               ; Is fixed?
       GLFX.NoHide      = True                ; Can't be hided?
       GLFX.NoModeSwitch = True               ; Switch to fullscreen locked?
       GLFX.NoClose     = False               ; Can't be closed?
       GLFX.Borderless  = False               ; Is borderless?
       GLFX.HideFromTaskBar = False           ; Hide from taskbar?
       
       GLFX.DBGBoxPos = { x = #LEFT, y = #BOTTOM } ; Debug Box Position
       GLFX.FPS         = 60                      ; Target FPS
       GLFX.FPSSample   = 100-1                   ; FPS samples for avarage calculation
       GLFX.FlipSync    = True                    ; Wait VBL at every frame?
       GLFX.TimerID     = -1                      ; - internal timer
       GLFX.IntervalID  = -1                      ; - internal interval
       GLFX.ClearColor  = { 0.0, 0.0, 0.0, 1.0 }  ; Clear color
       GLFX.CommonColor = { 1.0, 1.0, 1.0, 1.0 }  ; Common color
       GLFX.BrushID     = 0                       ; - internal brush
       GLFX.ScreenRatio = GLFX.Width/GLFX.Height  ; Screen Ratio
       GLFX.PixelSize   = { 1.0, 1.0 }            ; Pixel Size
       GLFX.RatioMode   = "stretch"               ; Ratio mode (stretch, fit, zoom)
       GLFX.PowerOfTwo  = False               ; Force textures size to power of 2
       
       GLFX.ShowStats   = True                ; Show statics on screen?
       GLFX.c           = 0                   ; ----- statistics variables -----
       GLFX.t           = 0
       GLFX.initStat    = False
       GLFX.cTime       = 0
       GLFX.dTime       = 0
       GLFX.oldTime     = 0
       GLFX.maxFPS      = 0
       GLFX.minFPS      = 999
       GLFX.UserMessage = ""                  ; Custom message to show along with the statistics
       
       GLFX.isInitialized = False
       
       GLFX.GL_blendSrc     = #GL_SRC_ALPHA
       GLFX.GL_blendDst     = #GL_ONE_MINUS_SRC_ALPHA
       GLFX.GL_blendEnabled = False
       GLFX.GL_lastTexInit  = -1
       GLFX.GL_Context      = -1
       GLFX.LastTexture     = -1
       
       ; Used by :Init()
       GLFX.GL_ShadeModel = #GL_SMOOTH ; _SMOOTH | _FLAT
       GLFX.GL_TexEnv1    = #GL_TEXTURE_ENV_MODE
       GLFX.GL_TexEnv2    = #GL_MODULATE
       GLFX.GL_Clear      = #GL_DEPTH_BUFFER_BIT | #GL_COLOR_BUFFER_BIT
       
       GLFX.DListCnt = 0
       
       GLFX.Scenes       = {} ; -> ogni scena contiene il suo sprite engine
       GLFX.CurrentScene = {}
       GLFX.QueuedScene  = {}
       GLFX.Hiscore      = {}
       

Function GLFX.GetNearestPowerOfTwo(value) ; 04/2021
/******************************************************************************
result = GLFX.GetNearestPowerOfTwo(value)

Returns the nearest power of 2 of the given value.
This is needed in some Amiga-like systems that does not accept textures of
any sizes.
-------------------------------------------------------------------------------
INPUT
  value : The value to process
  
OUTPUT
  result : The nearest power of 2 of the given value
  
EXAMPLE
  DebugPrint(GLFX.GetNearestPowerOfTwo(20))
  Will print 32 to the screen.
******************************************************************************/
  Local done    = False
  Local current = 1
  
  While Not(done)
    If current >= value
      done = True
    Else
      current = current*2
    EndIf
  Wend
  
  Return(current)
  
EndFunction

Function GLFX:New(args) ; OK / DOCS
/******************************************************************************
Engine = GLFX:New(args)

Create a new GLFX engine instance. A GLFX engine is needed to access all
engine's capabilities like sprites and particle systems.
-------------------------------------------------------------------------------
INPUT
  - args : A table where all engine's object fields can be tuned at creation
           time. See GLFX table for all possible arguments.

OUTPUT
  - engine : The created engine object.
******************************************************************************/
  DBG.Console.Out(":New()", DBG.OpenFunc, GLFXCh)
  DBG.Console.Out("Initialization parameters :", Nil, GLFXCh)
  DBG.Console.Out(args, Nil, GLFXCh)

  Local obj = CopyTable(self)
  TB.Set(obj, args, False)
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  Return(obj)
  
EndFunction

Function GLFX:Init(args) ; OK / DOCS
/******************************************************************************
GLFX:Init(args)

Initialize the engine.
-------------------------------------------------------------------------------
INPUT
  - args : A table where all engine's object fields can be redefined and tuned.
           See GLFX table for all possible arguments.
NOTES
  This method will initialize the engine, will create the output screen and
  will initialize the OpenGL library.
******************************************************************************/
  DBG.Console.Out(":Init()", DBG.OpenFunc, GLFXCh)
  DBG.Console.Out("Initialization parameters :", Nil, GLFXCh)
  DBG.Console.Out(args, Nil, GLFXCh)
  
  TB.Set(self, args, False)

  ; Check systems that needs power of two textures
  self.System = GetVersion()
  If self.System.Platform = "MorphOS"
    DBG.Console.Out("MorphOS detected : PowerOfTwo textures needed!", DBG.Hilight, GLFXCh)
    self.PowerOfTwo = True
    
  ElseIf self.System.Platform = "AmigaOS3"
    DBG.Console.Out("AmigaOS3 detected : PowerOfTwo textures needed!", DBG.Hilight, GLFXCh)
    self.PowerOfTwo = True
    
  ElseIf self.System.Platform = "AmigaOS4"
    DBG.Console.Out("AmigaOS4 detected : PowerOfTwo textures needed!", DBG.Hilight, GLFXCh)
    self.PowerOfTwo = True
    
  EndIf
  
  If Not(self.isInitialized)
    If self.Display <> 1
      DBG.Console.Out("Creating and opening the display...", Nil, GLFXCh)
      CreateDisplay(self.Display, { Width = self.Width, Height = self.Height, Mode = self.Mode })
      OpenDisplay(self.Display)
      
    Else
      DBG.Console.Out("Using the Hollywood's default display 1", Nil, GLFXCh)
      
    EndIf
    
  Else
    DBG.Console.Out("Display Already initialized.", DBG.Warning, GLFXCh)

  EndIf
  
  DBG.Console.Out("Setting display attribute :", Nil, GLFXCh)
  
  Local dAttrs =     
    { Title           = self.Title,
      Fixed           = self.Fixed,
      NoHide          = self.NoHide,
      NoModeSwitch    = self.NoModeSwitch,
      NoClose         = self.NoClose,
      Borderless      = self.Borderless,
      HideFromTaskBar = self.HideFromTaskBar }

  DBG.Console.Out(dAttrs, Nil, GLFXCh)
  SetDisplayAttributes(dAttrs)
  
  DBG.Console.Out("Display size : " .. self.Width .. "x" .. self.Height, Nil, GLFXCh)
  ChangeDisplaySize(self.Width, self.Height)
  
  DBG.Console.Out("Display mode : " .. ToString(self.Mode), Nil, GLFXCh)
  ChangeDisplayMode(self.Mode, self.Width, self.Height)
  
  ; This call is needed when the window is resized
  self:Reshape()

  ; Some GL init code
	gl.Disable(#GL_DEPTH_TEST)
	gl.Clear(#GL_COLOR_BUFFER_BIT|#GL_DEPTH_BUFFER_BIT)

  ;Re-create the display list
  DBG.Console.Out("Processing existing display lists...", Nil, GLFXCh)
  ; self.DListCnt = 0
  Local si, se, i, v, li, pso
  For si, se In Pairs(self.SpriteEngines)
    DBG.Console.Out("  Sprite Engine : " .. ToString(si), Nil, GLFXCh)
    For i, v In Pairs(se.PartSystems)
      DBG.Console.Out("    Particle System : " .. ToString(i), Nil, GLFXCh)
      For li, pso In Pairs(v)
        DBG.Console.Out("    - Overwriting  DisplayList : " .. pso.DisplayList, Nil, GLFXCh)
        gl.NewList(pso.DisplayList, #GL_COMPILE)        
          gl.Begin(#GL_QUADS)
            gl.TexCoord(0.0, 1.0)
            gl.Vertex( -1, -1, 0)
            gl.TexCoord(1.0, 1.0)
            gl.Vertex(  1, -1, 0)
            gl.TexCoord(1.0, 0.0)
            gl.Vertex(  1,  1, 0)
            gl.TexCoord(0.0, 0.0)
            gl.Vertex( -1,  1, 0)
          gl.End()
        gl.EndList()
      Next
    Next
  Next
  
  ; Setup textures
  DBG.Console.Out("Processing textures...", Nil, GLFXCh)
  Local sei, seo
  For sei, seo In Pairs(self.SpriteEngines)
    DBG.Console.Out("  Sprite Engine : " .. ToString(sei), Nil, GLFXCh)
    Local si, so
    For si, so In Pairs(seo.SpriteList)
      DBG.Console.Out("  - Texture : " .. ToString(si) .. " - " .. ToString(so), Nil, GLFXCh)
      GLFX._TexInit(so.id)
    Next
  Next
  
  DBG.Console.Out("Setting up OpenGL...", Nil, GLFXCh)
	gl.ClearColor(self.ClearColor[0], self.ClearColor[1], self.ClearColor[2], self.ClearColor[3])
  gl.Color(self.CommonColor[0], self.CommonColor[1], self.CommonColor[2], self.CommonColor[3])
	gl.BlendFunc(self.GL_blendSrc, self.GL_blendDst)

	gl.Enable(#GL_TEXTURE_2D)
	gl.TexEnv(self.GL_TexEnv1, self.GL_TexEnv2)

	gl.ShadeModel(self.GL_ShadeModel)
  
  self.isInitialized = True
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX:Start() ; OK
/********************
GLFX:Start()

Start the GLFX engine.
-------------------------------------------------------------------------------
All defined objects will be rendered and all events managers will be started.
******************************************************************************/
  DBG.Console.Out(":Start()", DBG.OpenFunc, GLFXCh)

  If GetType(self.TimerID) <> #NUMBER
    DBG.Console.Out("Framework already started!", DBG.Warning, GLFXCh)
    DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
    Return()
  EndIf
  
  self.IntervalRate = Int(1000/self.FPS) ; Scene updater
  self.IntervalID = SetInterval(Nil, self._Handler, self.intervalRate, self)
  DBG.Console.Out("Setting Renderer Interval @ " .. self.FPS .. " fps (" .. self.IntervalRate .. "ms)", Nil, GLFXCh)
  
  DBG.Console.Out("Adding callback functions on:", Nil, GLFXCh)
  DBG.Console.Out("- SizeWindow -> GLFX:Reshape()", Nil, GLFXCh)
  DBG.Console.Out("- ModeSwitch -> GLFX:Init() *** BUGGED ***", Nil, GLFXCh)
  DBG.Console.Out("- OnKeyDown  -> NOT YET IMPLEMENTED", DBG.Warning, GLFXCh)
  InstallEventHandler(
    { SizeWindow = Function(msg) self:Reshape(msg) EndFunction, 
      ModeSwitch = Function(msg) self:Init(msg)    EndFunction, 
      OnKeyDown  = Function(msg) EndFunction})
  
  DBG.Console.Out("Beginning Double Buffering...", Nil, GLFXCh)
  BeginDoubleBuffer(True)
  
  DBG.Console.Out("Starting Main Timer...", Nil, GLFXCh)
  self.TimerID = StartTimer(Nil)
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX:Stop() ; OK
/*******************
GLFX:Stop()

Stop a GLFX engine.
-------------------------------------------------------------------------------
All screen updates will be stopped as long as all the events managers.
******************************************************************************/
  DBG.Console.Out(":Stop()", DBG.OpenFunc, GLFXCh)
  
  DBG.Console.Out("Stopping Double Buffering...", Nil, GLFXCh)
  EndDoubleBuffer()
  
  DBG.Console.Out("Stopping Rendering Interval...", Nil, GLFXCh)
  ClearInterval(self.IntervalID)
  
  DBG.Console.Out("Stopping Main Timer...", Nil, GLFXCh)
  StopTimer(self.TimerID)
  
  self.IntervalID = -1
  self.TimerID = -1
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)

EndFunction

Function GLFX:GLShadeModel(model) ; OK
/********************************
GLFX:GLShadeModel(model)

Set the OpenGL model
---------------------------------------------------------------------
INPUT
  - model : GL Model, can be one of the following
    -> #GL_SMOOTH
    -> #GL_FLAT
******************************************************************************/
  If self.GL_ShadeModel <> model
    self.GL_ShadeModel = model
    gl.ShadeModel(model)
  EndIf

EndFunction

Function GLFX:GLTexEnv(param1, param2) ; OK
/*************************************
GLFX:GLTexEnv(param1, param2)

Set the OpenGL Texture Environment
---------------------------------------------------------------------
INPUT
  - param1 : #GL_TEXTURE_ENV_MODE or #GL_TEXTURE_ENV_COLOR
  - param2 : Depends on params 1 :
    -> param1 = ..._ENV_MODE -> #GL_MODULATE, #GL_DECAL, #GL_BLEND, and #GL_REPLACE
    -> param1 = ..._ENV_COLOR -> Array that holds an RGBA color consisting of four floating-point values.
******************************************************************************/
  If self.GL_TexEnv1 <> param1 Or self.GL_TexEnv2 <> param2
    self.GL_TexEnv1 = param1
    self.GL_TexEnv2 = param2
    gl.TexEnv(param1, param2)
  EndIf
  
EndFunction

Function GLFX:AddScene(scene) ; OK
/****************************
GLFX:AddScene(scene)

Add a defined scene to the engine.
-------------------------------------------------------------------------------
INPUT
  - scene : A scene object created with GLFX.Scene:New()
******************************************************************************/
  DBG.Console.Out(":AddScene() -> " .. scene.name .. " (" .. ToString(scene) .. ")", DBG.OpenFunc, GLFXCh)
  
  self.scenes[scene.name] = scene
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX:SceneIsQueued(sceneName)
/*************************************
result = GLFX:SceneIsQueued(sceneName)

Returns True if scene <sceneName> has been already queued for a change.
-------------------------------------------------------------------------------
INPUT
  - sceneName : Name of the scene to check

OUTPUT
  - result : True if already queued otherwise False.

NOTES
  We you switch to another scene it will not be changed immediately because
  there could be transitions that dealy the change, this method is used to
  check if a scene has been already queued for a change.
******************************************************************************/
  ; Check if the given scene has been already queued for the change.
  If RawGet(self, "queuedscene")
    If RawGet(self.QueuedScene, "name")
      If self.QueuedScene.Name = sceneName
        Return(True)
        
      EndIf
      
    EndIf
    
  EndIf

  Return(False)
  
EndFunction

Function GLFX:ChangeScene(sceneName, delayTime, transition) ; OK
/**********************************************************
GLFX:ChangeScene(sceneName, delayTime, transition)

Change the current scene with the one named <sceneName>.
-------------------------------------------------------------------------------
INPUT
  - sceneName : Name of the scene that will replace the current one
  - delayTime : Delay time in ms for the new scene to be activated. If not
                specified the scene change will be immediate.
  - transition : optional transition effect. Currently supported types are:
                 -> crossfade
                 -> move

OUTPUT
  - result : True if the change has been accepted, False if there was an error.
******************************************************************************/
  Local dlTime = ToString(delayTime)
  If dlTime = "Nil"
    dlTime = " not specified"
    
  Else
    dlTime = dlTime .. "ms"
    
  EndIf
  
  DBG.Console.Out(":ChangeScene() -> " .. sceneName .. " (delay:" .. dlTime ..")", DBG.OpenFunc, GLFXCh)

  Local engine = self
  
  ; Verifica se la nuova scena è quella in esecuzione
  If RawGet(self, "currentscene")
    If RawGet(self.currentScene, "name")
      If self.currentScene.Name = sceneName
        DBG.Console.Out("Attempt to change the scene with the current scene!", DBG.Warning, GLFXCh)
        DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
        Return(False)
        
      EndIf
      
    EndIf
    
  EndIf

  ; Verifica se la nuova scena è già in coda per il cambio
  If self:SceneIsQueued(sceneName)
    DBG.Console.Out("Attempt to change the scene with one already queued for change!", DBG.Warning, GLFXCh)
    DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
    Return(False)
    
  EndIf
  
  /*
  If RawGet(self, "queuedscene")
    If RawGet(self.QueuedScene, "name")
      If self.QueuedScene.Name = sceneName
        DBG.Console.Out("Attempt to change the scene with one already queued for change!", DBG.Warning, GLFXCh)
        DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
        Return()
      EndIf
    EndIf
  EndIf
  */
  
  ; WARNING!
  ; If the scene change is delayed we must run the UnInit routine when
  ; effectively the scene changes!
  /*
  If RawGet(self.CurrentScene, "uninit")
    DBG.Console.Out("Executing :UnInit() method on the exiting scene '" .. self.CurrentScene.Name .. "'", DBG.Hilight, GLFXCh)
    self.CurrentScene:UnInit() ; <- send next scene name
    DBG.Console.Out("Resetting keyboard handler...", Nil, GLFXCh)
    self.input.Keyboard:Reset()
  EndIf */

  If delayTime
    ;-- DELAYED SCENE CHANGE --
    DBG.Console.Out("Setting delayed change...", DBG.Hilight, GLFXCh)
    SetTimeout(Nil,
      ;=== DELAYED SCENE CHANGE CALLBACK ===
      ;=====================================
      Function(msg)
        Local obj = msg.userData.obj
        Local sceneName = msg.userData.sceneName
                 
        DBG.Console.Out("Entering scene '" .. sceneName .. "' initialization...", DBG.OpenFunc, GLFXCh)
        If RawGet(obj.scenes, sceneName)
          ; UnInit of the scene that's going to be replaced
          If RawGet(obj.CurrentScene, "uninit")
            DBG.Console.Out("Executing :UnInit() method on the exiting scene '" .. obj.CurrentScene.Name .. "'", DBG.Hilight, GLFXCh)
            obj.CurrentScene:UnInit() ; <- send next scene name
            DBG.Console.Out("Resetting keyboard handler...", Nil, GLFXCh)
            obj.input.Keyboard:Reset()
          EndIf
                   
          ; Switch to the new scene
          obj.CurrentScene = obj.scenes[sceneName]
                   
          If RawGet(obj.CurrentScene, "init")
            DBG.Console.Out("Executing :Init() method...", DBG.Hilight, GLFXCh)
            obj.CurrentScene:Init()
            obj.QueuedScene = {}
            DBG.Console.Out("Running Scene : " .. obj.CurrentScene.Name, DBG.Hilight, GLFXCh)
            obj:HandleSceneTransition()
          EndIf

        Else
          DBG.Console.Out("Scene '" .. sceneName .. "' not found!", DBG.Warning, GLFXCh)
        
        EndIf
        
        DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
      EndFunction,
      
      ;-- delay time --
      delayTime,
      ;-- data for the callback function --
      { obj       = self, 
        sceneName = sceneName })

    DBG.Console.Out("The scene has been queued for execution in " .. ToString(delayTime) .. "ms.", DBG.Hilight, GLFXCh)
    self.QueuedScene = self.scenes[sceneName]

  Else
    ;-- IMMEDIATE SCENE CHANGE --
    If RawGet(self.CurrentScene, "uninit")
      DBG.Console.Out("Executing :UnInit() method on the exiting scene '" .. self.CurrentScene.Name .. "'", DBG.Hilight, GLFXCh)
      self.CurrentScene:UnInit() ; <- send next scene name
      DBG.Console.Out("Resetting keyboard handler...", Nil, GLFXCh)
      self.input.Keyboard:Reset()
    EndIf
    
    If RawGet(self.scenes, sceneName)
      self.CurrentScene = self.scenes[sceneName]
      If RawGet(self.CurrentScene, "init")
        DBG.Console.Out("Executing :Init() method...", DBG.Hilight, GLFXCh)
        self.CurrentScene:Init()
      EndIf
      self:HandleSceneTransition()
    Else
      DBG.Console.Out("Scene '" .. sceneName .. "' not found!", DBG.Warning, GLFXCh)
    EndIf
    DBG.Console.Out("Running Scene : " .. self.CurrentScene.Name, DBG.Hilight, GLFXCh)
  EndIf

  Return(True)
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX:HandleSceneTransition()
  ; type
  ; brushid
  ; startColor
  ; endColor
  ; time
  ; easing
  If TB.Item.Exists(self, "scenetransition")
    Switch self.SceneTransition.Type
      Case "crossfade"
      ;---------------
        DBG.Console.Out("Starting scene transition : CrossFade FX", DBG.Hilight, GLFXCh)
        If TB.Item.Exists(self.CurrentScene, "spriteengine")
          If TB.Item.Exists(self.SceneTransition, "brushid")
            Local se   = self.CurrentScene.SpriteEngine
            Local bid  = self.SceneTransition.BrushID
            Local fw   = se.Framework
            self.SceneTransition.Sprite = 
              fw.Sprite:NewFromBrush(bid, se,
                { x = 0, y = 0,
                  w = fw.width, h = fw.height,
                  anchorx = 0, anchory = 0,
                  blendEnabled = True,
                  color = self.SceneTransition.StartColor,
                  layer = se.layerMax + 1
                  })
            self.SceneTransition.Tween = tween.start(
              self.SceneTransition.Time, 
              self.SceneTransition.Sprite, 
              { color = self.SceneTransition.EndColor }, 
              self.SceneTransition.Easing, 
              Function(locFW)
                DBG.Console.Out("Scene transition ended, resetting...", DBG.Hilight, GLFXCh)
                locFW.SceneTransition.Sprite:Destroy()
                FreeBrush(locFW.SceneTransition.BrushID)
                locFW.SceneTransition = Nil
              EndFunction, self)
            
          Else
            DBG.Console.Out("BrushID field not found in current transition!", DBG.Error, GLFXCh)
          EndIf
          
        Else
          DBG.Console.Out("SpriteEngine field not found in current scene!", DBG.Error, GLFXCh)
        EndIf

      Case "move"
      ;----------
        DBG.Console.Out("Starting scene transition : Move FX", DBG.Hilight, GLFXCh)
        If TB.Item.Exists(self.CurrentScene, "spriteengine")
          If TB.Item.Exists(self.SceneTransition, "brushid")
            Local se   = self.CurrentScene.SpriteEngine
            Local bid  = self.SceneTransition.BrushID
            Local fw   = se.Framework
            self.SceneTransition.Sprite = 
              fw.Sprite:NewFromBrush(bid, se,
                { x = 0, y = 0,
                  w = fw.width, h = fw.height,
                  anchorx = 0, anchory = 0,
                  blendEnabled = False,
                  layer = se.layerMax + 1
                  })
            self.SceneTransition.Tween = tween.start(
              self.SceneTransition.Time, 
              self.SceneTransition.Sprite, 
              { x = self.SceneTransition.Target.x,
                y = self.SceneTransition.Target.y }, 
              self.SceneTransition.Easing, 
              Function(locFW)
                DBG.Console.Out("Scene transition ended, resetting...", DBG.Hilight, GLFXCh)
                locFW.SceneTransition.Sprite:Destroy()
                FreeBrush(locFW.SceneTransition.BrushID)
                locFW.SceneTransition = Nil
              EndFunction, self)
            
          Else
            DBG.Console.Out("BrushID field not found in current transition!", DBG.Error, GLFXCh)
          EndIf
          
        Else
          DBG.Console.Out("SpriteEngine field not found in current scene!", DBG.Error, GLFXCh)
        EndIf
        
      Default
        DBG.Console.Out("UNKNOW SCENE TRASNITION : " .. self.SceneTransition.Type, DBG.Error, GLFXCh)
    EndSwitch

  EndIf
EndFunction

Function GLFX:Update() ; *
/*****************************************************************************
GLFX:Update()

Update the current scene.
*****************************************************************************/
  If RawGet(self.CurrentScene, "update")
    self.CurrentScene:Update()
  EndIf
  
  ; CHECK CURRENT SCENE STORYBOARD
  If RawGet(self.CurrentScene, "storyboard")
    If Not(self.CurrentScene.Storyboard.IsPaused)
      Local sb = self.CurrentScene.Storyboard
      Local ct = GetTimer(sb.Timer)
      ;--- timed events --------------------
      ; I timed events sono memorizzati con indice uguale al tempo
      ; in cui dovranno essere eseguiti, ad ogni controllo verifico
      ; gli eventi dall'ultimo controllo (.LastTE) al tempo corrente
      ; (.Timer), gli eventi definiti in questo intervallo saranno
      ; tutti eseguiti.
      For Local t = sb.LastTE To ct
        If RawGet(sb.TimedEvents, t)
          If Not(sb.TimedEvents[t].Executed)
            DBG.Console.Out("GLFX:Update() => Executing Storyboard Timed Event : " .. ToString(t) .. "ms", DBG.Hilight, GLFXCh)
            ; Callback (userdata, time, scene)
            sb.TimedEvents[t].Callback(sb.TimedEvents[t].userdata, t, sb.scene)
            sb.TimedEvents[t].Executed = True
            
          EndIf
          
        EndIf
        
      Next
      
      sb.LastTE = ct+1
      ;--- triggered events ----------------

      ; [TODO]
      /* possibile implementazione
         [CONDIZIONI]
            [TIMER] : {Id Timer}{Condizione}{Valore} -> Callback
            [VARIABLE] : {Table}{Variable}{Condizione}{Valore} -> Callback
            [ESISTENZA] : {Table}{Type}{Condizione}{Object} -> Callback      
      */
      
    Else
      ; Storyboard is paused
    EndIf
  Else
    ; Scene without Storyboard
  EndIf
  
EndFunction


Function GLFX:PartSystemsDestroy()
/*****************************************************************************
GLFX:PartSystemsDestroy()

Destroy all engine's particle systems
*****************************************************************************/
  DBG.Console.Out(":PartSystemsDestroy()", DBG.OpenFunc, GLFXCh)

  Local i, v
  For i, v In Pairs(self.PartSystems)
    Local destroyed = 0
    Local ii, vv
    For ii, vv In Pairs(v)
      destroyed = destroyed + 1      
      vv:Destroy()
    Next
    DBG.Console.Out("Particle System : " .. ToString(i) .. ", destroyed " .. ToString(destroyed) .. " particles.", Nil, GLFXCh)
  Next
  self.PartSystems = {}
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
EndFunction

Function GLFX:SpritesDestroy()
/*****************************************************************************
GLFX:SpritesDestroy()

Destroy all engine's sprites
*****************************************************************************/
  Local i, v
  For i, v In Pairs(self.Sprites)
    Local ii, vv
    For ii, vv In Pairs(v)
      vv:Destroy()
    Next
  Next
  self.Sprites = {}
  
EndFunction

Function GLFX:ScenesDestroy()
  DBG.Console.Out(":ScenesDestroy()", DBG.OpenFunc, GLFXCh)

  Local destroyed, i, v = 0
  For i, v In Pairs(self.Scenes)
    destroyed = destroyed + 1
    v:Destroy()
  Next
  DBG.Console.Out("Destroyed " .. ToString(destroyed) .. " scenes.", Nil, GLFXCh)
  self.Scenes = {}
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX:_Handler()
/******************************************************************************
GLFX:Renderer()

Render the engine scene (called automatically by the engine)
******************************************************************************/
  StartTimer(1)
  
  DisableLineHook()
  
  self.userdata.cTime = GetTimer(self.userdata.TimerID)
  self.userdata.dTime = self.userdata.cTime - self.userdata.OldTime
  self.userdata.OldTime = self.userdata.cTime
  tween.update(self.userdata.dTime) 

  /*
  If self.userdata.dTime < self.userdata.IntervalRate-1 Or self.userdata.dTime > self.userdata.IntervalRate+1
    DebugPrint("TIME ERROR : ", self.userdata.dTime, self.userdata.IntervalRate)
  Else
    DebugPrint("OK")
  EndIf
  */
  
  /*
  If self.userdata.dTime <> Int(1000/self.userdata.FPS)
    Local d = self.userdata.dTime - Round(1000/self.userdata.FPS)
    ;DebugPrint("TIMING ERROR : ", self.userdata.dTime, Round(1000/self.userdata.FPS), d)
    If d < 0
      Wait(-d, #MILLISECONDS)
      ;self.userdata.OldTime = self.userdata.OldTime + d
    EndIf
  EndIf
  */
  
  If GLFX.GL_Context <> self.userdata.Display
    gl.SetCurrentContext(self.userdata.Display)
    GLFX.GL_Context = self.userdata.Display
    SelectDisplay(self.userdata.Display, True)
  EndIf
  
  gl.Clear(self.userdata.GL_Clear)
    
  gl.MatrixMode(#GL_PROJECTION)
  gl.LoadIdentity()
  gl.Ortho(0, self.userdata.Width, self.userdata.Height, 0, -1, 1)

  gl.MatrixMode(#GL_MODELVIEW)
  gl.LoadIdentity()
   
  gl.Color(self.userdata.CommonColor[0], self.userdata.CommonColor[1], self.userdata.CommonColor[2], self.userdata.CommonColor[3])
  
  self.userdata:Update()
  self.userdata:Render()

    
  If self.userdata.showStats
    
    self.userdata.c = self.userdata.c+1
    self.userdata.t = self.userdata.t+GetTimer(1)
    ;StopTimer(1)
    
    If self.userdata.c=self.userdata.FPSSample
      If self.userdata.initStat Then FreeBrush(99999)
      self.userdata.initStat = True
      CreateBrush(99999, 300, 67, #RED, { AlphaChannel = True, Clear = True })
    
      If self.userdata.t = 0 Then self.userdata.t = 0.00001
      Local l, s = 0, 0
      
      Local rTime = self.userdata.t/(self.userdata.FPSSample+1)
      Local cFPS = Int(1000/rTime)
      If self.userdata.maxFPS < cFPS Then self.userdata.maxFPS = cFPS
      If self.userdata.minFPS > cFPS Then self.userdata.minFPS = cFPS
      
      Local cntSpriteEngines, cntSprites = 0
      Local cntParticleSystems, cntParticles = 0, 0
      Local si, se
      For si, se In Pairs(self.userdata.SpriteEngines)
        cntSpriteEngines = cntSpriteEngines + 1
        cntSprites = cntSprites + ListItems(se.SpriteList)
        Local psys, li, lv = se.PartSystems
        For li, lv In Pairs(psys)
          For psi, psv In Pairs(lv)
            cntParticleSystems = cntParticleSystems + 1
            cntParticles = cntParticles + psv.ParticlesCount
          Next
        Next
      Next
      
      Local tBrushes = GetAttribute(#BRUSH, Nil, #ATTRCOUNT)
      Local tDisplays = GetAttribute(#DISPLAY, Nil, #ATTRCOUNT)
      
      SetFont(#MONOSPACE, 14)
      SetFontStyle(#NORMAL+#BOLD)
      SetFontColor($FFFFFF)
      SetFillStyle(#FILLCOLOR)
      SelectBrush(99999, #SELMODE_COMBO, 2)
        Box(0, 0, 300, 67, $55333333)
        TextOut(0,  0, "max fps    : " .. cFPS .. " (" .. self.userdata.minFPS .. "-" .. self.userdata.maxFPS .. ")")
        TextOut(0,  9, "target fps : " .. self.userdata.fps .. "    Frm Time : " .. rTime)
        TextOut(0, 18, "sprite eng : " .. cntSpriteEngines .. ", part sys : " .. cntParticleSystems)
        TextOut(0, 27, "sprite cnt : " .. cntSprites .. ", part cnt : " .. cntParticles)
        TextOut(0, 36, "scene      : " .. self.userdata.currentScene.name)
        TextOut(0, 45, "BR:" .. tBrushes .. " DI:" .. tDisplays)
        TextOut(0, 54, "[color=$FFFF00]" .. self.userdata.UserMessage .. "[/color]")
      EndSelect

      self.userdata.c, self.userdata.t = 0, 0

    EndIf
    
    If self.userdata.initStat
      gl.Disable(#GL_TEXTURE_2D)
      gl.Disable(#GL_BLEND)
      DisplayBrush(99999, GLFX.DBGBoxPos.x, GLFX.DBGBoxPos.y)
    EndIf
    
  EndIf
    
  ;gl.Flush()
  Flip(self.userdata.FlipSync)
  ;CollectGarbage()
  EnableLineHook()
  
EndFunction

Function GLFX:Render()
/******************************************************************************
GLFX:Render()

Renderer function
******************************************************************************/
  DisableLineHook()
  Local engine = self
  
  If RawGet(self.CurrentScene, "clear")
    self.CurrentScene:Clear()
  EndIf
  If RawGet(self.CurrentScene, "render")
    self.CurrentScene:Render()
  ;Else
  ;  self:DrawAllSprites() -> questo lo gestisce lo sprite engine
  EndIf 
 
  EnableLineHook()
EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::: GLFX INPUT :::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; CLASS USED TO HANDLE USER INPUT

GLFX.Input = {}
GLFX.Input.Keyboard = {}
GLFX.Input.Keyboard.Timer = -1
GLFX.Input.Keyboard.LastKey = ""
GLFX.Input.Keyboard.Events = {}

; EVENT HANDLER ONKEYDOWN
; :Enable() 
; :AddKey(event, key, cooldown, callback)
; :RemoveKey(key)
; :Disable()
; :Reset()

Function GLFX.Input.Keyboard.HandleKeyPress(msg) ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard.HandleKeyPress(msg)

Interval function used to track the keypresses and their status, with OpenGL is
not possible to install a proper keyboard handler.
The callback to this function is installed by GLFX.Input.Keyboard:Enable()
;--------------------------------------------------------------------
INPUT
  msg : Standard Hollywood message
  
OUTPUT

******************************************************************************/  
  Local object, i, v, k, w  = msg.userdata

  For i, v In Pairs(object.Events)
    For k, w In Pairs(v)
      If IsKeyDown(k)
        If w.IsDown
          ; Last check time the key was down, verify if it is time to generate
          ; a new event.
          If GetTimer(object.Timer) >= w.NextRead
            ; It's time! Check if it a 'charge'-type event or not
            Switch w.mode
              Case "normal"
                w.Callback(
                  { event   = i,
                    key     = k,
                    action  = "still pushed",
                    details = w })

              Case "charge"
                w.Charge = w.Charge + w.Charger
                ; If the callback function returns 'True' then we have to reset
                ; the charger value.
                If w.Callback(
                    { event   = i,
                      key     = k,
                      action  = "charging",
                      details = w })
                  w.Charge = 0
                  w.IsDown = False

                EndIf
                
            EndSwitch
            
            w.NextRead = GetTimer(object.Timer) + w.CoolDown
            
          EndIf
            
        Else
          ; Last check time the key was not pressed
          Switch w.mode
            Case "normal"
              w.Callback(
                { event   = i,
                  key     = k,
                  action  = "pushed",
                  details = w })

            Case "charge"
              w.Charge = w.Charge + w.Charger
              ; If the callback function returns 'True' then we have to reset
              ; the charger value.
              w.Charge = 0
              If w.Callback(
                  { event   = i,
                    key     = k,
                    action  = "start charging",
                    details = w })
                w.IsDown = False
              EndIf
              
          EndSwitch
          
          w.IsDown = True
          
        EndIf
        
        
      Else
        ; The key is not pressed, check the previous check state
        If w.IsDown
          ; Previously it was pressed!
          w.Callback(
            { event   = i,
              key     = k,
              action  = "released",
              details = w })
          w.IsDown = False
          
        EndIf
        
      EndIf
      
    Next
    
  Next
  
EndFunction

Function GLFX.Input.Keyboard:Enable(freq) ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard:Enable(freq)

Enables the keyboard handler and starts to detect defined key presses
;--------------------------------------------------------------------
INPUT
  freq : Monitor frequency in milliseconds, defaults to 20ms
******************************************************************************/
  
  If IsNil(freq) Then freq = 20
  If HaveItem(self, "interval")
    ; If it already exist removes it
    ClearInterval(self.Interval)
    StopTimer(self.Timer)
    
  EndIf
  
  ; Start the insterval routine and the dedicated timer
  self.Interval = SetInterval(Nil, self.HandleKeyPress, freq, self)
  self.Timer    = StartTimer(Nil)

EndFunction

Function GLFX.Input.Keyboard:Reset() ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard:Reset()

Resets the keyboard handler removing all events defined and keys
;--------------------------------------------------------------------

******************************************************************************/
  
  self.Events = {}
  self.LastKey = ""

EndFunction

Function GLFX.Input.Keyboard:RemoveKey(event, key) ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard:RemoveKey(event, key)

Removes the specified key from the keyboard handler
;--------------------------------------------------------------------
INPUT
  event : The event to remove, defaults to "OnKeyDown"
  key : The key to remove
******************************************************************************/  
  If Not(HaveItem(args, "event")) Then args.event = "OnKeyDown"
  If Not(HaveItem(args, "key"))
    DBG.Console.Out("No key specified!", DBG.Error, GLFXCh)
    Return()
  EndIf
  
  event = LowerStr(event)
  key   = UpperStr(key)
  
  ; Check if the event exists
  If HaveItem(self.Events, event)
    ; Check if the key exists
    If HaveItem(self.Events[Event], key)
      self.Events[Event][key] = Nil
      
    EndIf
    
  EndIf
  
EndFunction

Function GLFX.Input.Keyboard:AddKey(args) ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard:AddKey(args)

Add a keyboard key to the keyboard handler
;--------------------------------------------------------------------
INPUT
  args : A table with the following fields
         .event : The event to track, defaults to "OnKeyDown"
         .key : The character to monitor or "ANY"
         .cooldown : An optional cooldown time for the next detection in ms, defaults to 20ms
         .callback : A callback function to trigger, it will be called with a
                     table with the following fields:
                     .event : The detected event
                     .key : The pressed key (no casing detected)
                     .action : The action detected
                     .details : The original 'args' table
         .userdata : An optional userdata field
         .mode : The detection mode, can be "charge" or "normal", defaults to "normal"
         .charge : An optional charge starting level, defaults to 1
******************************************************************************/
  If Not(HaveItem(args, "event"))   Then args.event = "OnKeyDown"
  If Not(HaveItem(args, "mode"))    Then args.mode = "normal"
  If Not(HaveItem(args, "charger")) Then args.charger = 1
  If Not(HaveItem(args, "key"))
    DBG.Console.Out("No key field defined!", DBG.Error, GLFXCh)
    Return()
  EndIf
  If Not(HaveItem(args, "cooldown")) Then args.cooldown = 20
  If Not(HaveItem(args, "userdata")) Then args.userdata = {}
  If Not(HaveItem(args, "callback"))
    DBG.Console.Out("No callback field defined!", DBG.Error, GLFXCh)
    Return()
  EndIf
  args.Event = LowerStr(args.Event)
  args.Key   = UpperStr(args.Key)
  
  ; Init the field if not defined
  If Not(HaveItem(self.Events, args.event)) Then self.Events[args.event] = {}
  self.Events[args.event][args.key] = { cooldown = args.cooldown,
                                        nextread = 0,
                                        mode     = args.mode,
                                        charger  = args.charger,
                                        charge   = 0,
                                        isdown   = False,
                                        callback = args.callback,
                                        userdata = args.userdata }

EndFunction

Function GLFX.Input.Keyboard:Disable() ; 04/2021
/******************************************************************************
GLFX.Input.Keyboard:Disable()

Disable the keyboard handler
;--------------------------------------------------------------------

******************************************************************************/
  ; Removes the interval function
  ClearInterval(self.Interval)
  
  ; Stop the keyboard timer
  StopTimer(self.Timer)
  
  self.Interval = Nil
  self.Timer    = Nil

EndFunction


GLFX.Input.Joystick = {}
; SUPPORT NOT YET ADDED
;
; POLLING
; :Enable()
; :AddButton(joystick, button, cooldown, callback)
; :AddDirection(joystick, cooldown, callback)
; :Disable()

GLFX.Input.Mouse = {}
; SUPPORT NOT YET ADDED
;







Function GLFX:GenerateMenu(scene, menu, menu_fx, menu_data)
/******************************************************************************
GLFX:GenerateMenu(scene, menu, menu_fx, menu_data)

Generates a working menu on a single screen
---------------------------------------------------------------------
INPUT
  scene => Scene object where this menu should be generated
  menu => Menu definition, each item is an entry, each entry is indexed by
          its name and has the following fields.
    image -> Image name
    menuId -> An unique numeric id
    action -> Can be "nothing", "change scene", "function"
    data -> Data required by the action type specified above
    layout -> A table that defines the item layout with the following fields
      zoom ->> Zoom level
      xs, ys ->> X and Y starting coordinates
      xe, ye ->> X and Y ending coordinates
      easing ->> Easing function to move the item
      time ->> Duration in ms of the movement
  menu_fx => Menu effects table
    hilight -> Effect when the item is hilighted
      color ->> 
******************************************************************************/

  ;::::::::::::::::::::::::::::::::
  ;::: MENU GENERATION FUNCTION :::
  ;::::::::::::::::::::::::::::::::
  Local fw = self
  
  If TB.Item.IsNil(scene, "sprites") Then scene.Sprites = {}
  
  ; Initialize data table
  menu_data.menu_sprites = {}

  ;:::::::::::::::::::::::::::::::::::::
  ;::: CALLBACK FUNCTIONS DEFINITION :::
  ;:::::::::::::::::::::::::::::::::::::

  ;=== HILIGHT FX ===
  scene.hilight_menu_item = 
    Function(sprite)
      ; Input : sprite object or sprite name
      Local s
      If GetType(sprite) = #STRING Then s = scene.SpriteEngine:FindSpriteByName(sprite) Else s = sprite

      ; Hilight fx
      s:Fader({ ColorList = { menu_fx.hilight.color, { 1.0, 1.0, 1.0, 1.0 } }, 
                Timings   = menu_fx.hilight.timings, 
                Loop      = menu_fx.hilight.loop, 
                Easing    = menu_fx.hilight.easing })
    EndFunction
    
  ;=== NORMAL FX ===
  scene.normalize_menu_item =
    Function(sprite)
      ; Input : sprite object or sprite name
      Local s
      If GetType(sprite) = #STRING Then s = scene.SpriteEngine:FindSpriteByName(sprite) Else s = sprite

      ; Normal Fx
      s:Fader({ ColorList = { { 1.0, 1.0, 1.0, 1.0 } }, 
                Timings   = { menu_fx.normal.time }, 
                Loop      = False, 
                Easing    = menu_fx.normal.easing })                  
    EndFunction
    
  ;=== PUSH FX ===
  scene.push_menu_item =
    Function(sprite)
      ; Input : sprite object or sprite name
      Local s
      If GetType(sprite) = #STRING Then s = scene.SpriteEngine:FindSpriteByName(sprite) Else s = sprite

      Switch menu[s.name].action
        Case "change scene"
          ; Apply a zoom effect in case of a scene change
          s:Stretcher({ StretchList = { menu_fx.push.zoom },
                        Timings     = { menu_fx.push.time },
                        Loop        = False,
                        Easing      = menu_fx.push.easing })

        Case "function"
          ; Function callbacks must handle highlight
          

      EndSwitch
    EndFunction
    
  ;=== AFTER PUSH FX ===
  scene.after_menu_push =
    Function(sprite)
      ; Input : sprite object or sprite name
      Local s
      If GetType(sprite) = #STRING Then s = scene.SpriteEngine:FindSpriteByName(sprite) Else s = sprite
      sprite = s
      
      Local longest_time = menu_fx.push.time
      
      ;--- CHANGE SCENE ---
      If sprite.menuaction = "change scene"
        ; AExit animation for the menu items
        For i, v In Pairs(menu)
          ; Disattiva collisione
          sprite:CollisionWithMouse()

          If i <> sprite.name
            scene.Sprites[i]:MoveTo({ x      = fw.Width*v.layout.xs,
                                      y      = fw.Height*v.layout.ys,
                                      time   = menu_fx.push.outtime,
                                      easing = menu_fx.push.easing })
          Else
            scene.Sprites[i]:Fader({ ColorList = { menu_fx.push.hicolor }, 
                                     Timings   = { menu_fx.push.time }, 
                                     Loop      = False, 
                                     Easing    = menu_fx.push.easing })

          EndIf
          
          If menu_fx.push.outtime > longest_time
            longest_time = menu_fx.push.outtime
          EndIf
          
          If menu_fx.push.time > longest_time
            longest_time = menu_fx.push.time
          EndIf
          
        Next
        
        ; Cambia scena al termine della transizione
        Local scene_change_time = longest_time + 250
        
        ; Imposta un timeout per eseguire il cambio di scena alla
        ; fine dell'animazione
        SetTimeout(Nil, 
          Function(msg)
            Local sprite = msg.userdata.sprite
            
            fw:ChangeScene(sprite.menudata)
                
          EndFunction,
          scene_change_time,
          { sprite = sprite, scene = scene }
        )
      
      ;--- CALLBACK FUNCTION ---
      ElseIf sprite.menuaction = "function" And sprite.menu_input
        longest_time = -50
        sprite:Fader({ ColorList = { menu_fx.push.funchicolor, { 1.0, 1.0, 1.0, 1.0 } }, 
                       Timings   = { 50, menu_fx.push.functime }, 
                       Loop      = False, 
                       Easing    = menu_fx.push.funceasing })

        sprite.menu_input = False
        
        menu[sprite.name].data(sprite)
        
        ; Ripristina l'evidenziazione
        SetTimeout(Nil, 
          Function(msg)
            Local sprite = msg.userdata.sprite
            Local scene = msg.userdata.scene
            
            scene.hilight_menu_item(sprite)
            sprite.menu_input = True
            
          EndFunction,
          menu_fx.push.functime + 50,
          { sprite = sprite, scene = scene }
        )
        
      EndIf

  EndFunction
 
  ;=== MENU GENERATION ===
  Local i, v
  For i, v In Pairs(menu)
    ; Collegamento nome-sprite <--> id menu
    menu_data.menu_sprites[v.menuid] = i
    
    ; Caricamento sprite
    Local s =
      self.Sprite:Load(v.Image,
                         scene.SpriteEngine,
                         { x            = self.Width  * v.layout.xs,
                           y            = self.Height * v.layout.ys,
                           AnchorX      = 0.5,
                           AnchorY      = 0,
                           Layer        = 2,
                           blendEnabled = True,
                           name         = i })
    scene.Sprites[i] = s
    
    ; Ridimensionamento
    s:Resize(Nil, self.Width * v.layout.zoom, True)
    
    ; Entrata nello schermo
    s:MoveTo({ x      = self.Width  * v.layout.xe,
               y      = self.Height * v.layout.ye,
               time   = v.layout.time,
               easing = v.layout.easing })

    ; Inizializza i parametri del menu
    s.menuid     = v.menuid
    s.menuaction = v.action
    s.menudata   = v.data
    s.menu_input = True
    
    ; Attivazione collisioni con il mouse
    s:CollisionWithMouse(
      { Enabled = True,
        Events =
          { OnCollision = 
              Function(sprite, cPoint)
                If IsLeftMouse()
                  ; Pressione pulsante
                  scene.push_menu_item(sprite)
                  scene.after_menu_push(sprite)
                EndIf
                
              EndFunction,

            OnCollisionStart = 
              Function(sprite, cPoint)
                ; Fade dell'elemento evidenziato
                If sprite.menuid <> menu_data.current_Item
                  scene.normalize_menu_item(menu_data.menu_sprites[menu_data.current_item]) 
                  scene.hilight_menu_item(sprite)
                  menu_data.current_item = sprite.menuid
                EndIf

              EndFunction,

            OnCollisionEnd =
              Function(sprite, cPoint)
          
              EndFunction
            }
        })
  Next
  
  ; Abilita il controllo da tastiera
  fw.Input.Keyboard:Enable()
  fw.Input.Keyboard:AddKey(
    { event = "OnKeyDown",
      key   = menu_data.controls.keyboard.nxt,
      cooldown = menu_data.controls.keyboard.repspeed,
      callback = Function(msg)
                   Local scene = msg.details.userdata.scene
                   If msg.action <> "pushed" Then Return()
                   scene.normalize_menu_item(menu_data.menu_sprites[menu_data.current_item])
                   menu_data.current_item = menu_data.current_item + 1
                   If menu_data.current_item > ListItems(menu_data.menu_sprites)-1
                     menu_data.current_item = menu_data.current_item - 1
                   EndIf
                   scene.hilight_menu_item(menu_data.menu_sprites[menu_data.current_item])
                 EndFunction,
      userdata = { scene = scene } })

  fw.Input.Keyboard:AddKey(
    { event = "OnKeyDown",
      key   = menu_data.controls.keyboard.prv,
      cooldown = menu_data.controls.keyboard.repspeed,
      callback = Function(msg)
                   Local scene = msg.details.userdata.scene
                   If msg.action <> "pushed" Then Return()
                   scene.normalize_menu_item(menu_data.menu_sprites[menu_data.current_item])
                   menu_data.current_item = menu_data.current_item - 1
                   If menu_data.current_item < 0
                     menu_data.current_item = menu_data.current_item + 1
                   EndIf
                   scene.hilight_menu_item(menu_data.menu_sprites[menu_data.current_item])
                 EndFunction,
      userdata = { scene = scene } })

  fw.Input.Keyboard:AddKey(
    { event = "OnKeyDown",
      key   = menu_data.controls.keyboard.fire1,
      cooldown = menu_data.controls.keyboard.repspeed,
      callback = Function(msg)
                   Local scene = msg.details.userdata.scene
                   If msg.action <> "pushed" Then Return()
                   scene.push_menu_item(menu_data.menu_sprites[menu_data.current_item])
                   scene.after_menu_push(menu_data.menu_sprites[menu_data.current_item])
                 EndFunction,
      userdata = { scene = scene } })

  If TB.Item.Exists(menu_data.controls.keyboard, "fire2")
    fw.Input.Keyboard:AddKey(
      { event = "OnKeyDown",
        key   = menu_data.controls.keyboard.fire2,
        cooldown = menu_data.controls.keyboard.repspeed,
        callback = Function(msg)
                     Local scene = msg.details.userdata.scene
                     If msg.action <> "pushed" Then Return()
                     scene.push_menu_item(menu_data.menu_sprites[menu_data.current_item])
                     scene.after_menu_push(menu_data.menu_sprites[menu_data.current_item])
                   EndFunction,
        userdata = { scene = scene } })
  EndIf
  
  ; Evidenzia la prima opzione (0)
  scene.hilight_menu_item(menu_data.menu_sprites[menu_data.current_item])

EndFunction


;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::: GLFX SCENE CLASS :::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
GLFX.Scene = {}
GLFX.Scene.Name = ""
GLFX.Scene.Engine = {}
GLFX.Scene.SpeedRatio = 1 ; -> NON SERVE
GLFX.Scene.Storyboard = {}
GLFX.Scene.Storyboard.IsPaused = True
GLFX.Scene.Storyboard.Timer = 0
GLFX.Scene.Storyboard.TimedEvents = {}
GLFX.Scene.Storyboard.LastTE = 0
GLFX.Scene.Storyboard.TriggeredEvents = {}
GLFX.Scene.Storyboard.Scene = {}
GLFX.Scene.Update = Function() EndFunction
GLFX.Scene.Clear  = Function() EndFunction
GLFX.Scene.Render = Function() EndFunction
GLFX.Scene.Init   = Function() EndFunction
GLFX.Scene.UnInit = Function() EndFunction

Function GLFX.Scene:New() ; 04/2021
/******************************************************************************
sceneObject = GLFX.Scene:New()

Create a new, blank scene object.
---------------------------------------------------------------------

******************************************************************************/
  DBG.Console.Out(".Scene:New()", DBG.OpenFunc, GLFXCh)
  
  Local obj = CopyTable(self)
  obj.Storyboard.Scene = obj
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
  Return(obj)

EndFunction

Function GLFX.Scene:Setup(Params) ; 04/2021
/******************************************************************************
GLFX.Scene:Setup(params)

Setup a scene object, where you can override methods and define scene variables.
Each scene is composed by 5 functions that can be freely overrided, at
least you should set the 'render' and 'init' function and 'uninit' to
release loaded resources when a scene changes.
---------------------------------------------------------------------
INPUT
  params : A table with all variable you want to change in the scene
    Name : Scene Name
    Update : Function to update the scene (every frame)
    Clear : Function to clear the screen (every frame)
    Render : Function to render the screen (every frame)
    Init : Function to initialize the scene (on scene change)
    UnInit : Function to uninitialize the scene (on scene change)
******************************************************************************/
  TB.Set(self, params, False)
  
EndFunction

Function GLFX.Scene:TransitionSetup(args) ; 04/2021
/******************************************************************************
GLFX.Scene:TransitionSetup(args)

Setup an optional transition effect between scenes.
---------------------------------------------------------------------
INPUT
  args : A table where you have to configure the transition effect
    framework : Framework pointer
    time : Transition duration in milliseconds, defaults to 1000ms
    easing : Easing function, defaults to 'linear' 
    type : The transition type that can be (each with its own additional parameters)
           'crossfade'
             startcolor : A table with the starting color, defaults to { 1.0, 1.0, 1.0, 1.0 }
             endcolor : A table with the ending color, defaults to { 1.0, 1.0, 1.0, 0.0 }
           'move'
             target : Target point, defaults to { x = 0, y = args.Framework.Height } which
                      is a scroll-down effect
******************************************************************************/
  
  If HaveItem(args.Framework, "scenetransition")
    DBG.Console.Out("Stopping previous transition!", DBG.Hilight, GLFXCh)
    tween.stop(args.Framework.SceneTransition.Tween, True)

  EndIf
  
  Local w = args.framework.width
  Local h = args.framework.height
  Local b = args.FrameWork.BrushID
  args.FrameWork.BrushID = args.FrameWork.BrushID + 1
  
  ; This flip() below seems needed to avoid to grab a blank screen
  Flip()
  
  gl.ReadPixelsToBrush(0, 0, w, h, b)
  
  args.FrameWork.SceneTransition =
    { type = args.type }

  Switch args.type
    Case "crossfade"
      If HaveItem(args, "startcolor")
        args.FrameWork.SceneTransition.StartColor = args.StartColor
        
      Else
        args.FrameWork.SceneTransition.StartColor = { 1.0, 1.0, 1.0, 1.0 }
        
      EndIf
      
      If HaveItem(args, "endcolor")
        args.FrameWork.SceneTransition.EndColor = args.EndColor
        
      Else
        args.FrameWork.SceneTransition.EndColor = { 1.0, 1.0, 1.0, 0.0 }
        
      EndIf
      
      If HaveItem(args, "time")
        args.FrameWork.SceneTransition.Time = args.Time
        
      Else
        args.FrameWork.SceneTransition.Time = 1000
        
      EndIf

      If HaveItem(args, "easing")
        args.FrameWork.SceneTransition.Easing = args.Easing
        
      Else
        args.FrameWork.SceneTransition.Easing = "linear"
        
      EndIf
      
      args.Framework.SceneTransition.BrushID = b
    
    
    
    Case "move"
      If HaveItem(args, "time")
        args.FrameWork.SceneTransition.Time = args.Time
        
      Else
        args.FrameWork.SceneTransition.Time = 1000
        
      EndIf

      If HaveItem(args, "easing")
        args.FrameWork.SceneTransition.Easing = args.Easing
        
      Else
        args.FrameWork.SceneTransition.Easing = "linear"
        
      EndIf
      
      If HaveItem(args, "target")
        args.FrameWork.SceneTransition.Target = args.Target
        
      Else
        args.FrameWork.SceneTransition.Target = { x = 0, y = args.Framework.Height }
        
      EndIf


      args.Framework.SceneTransition.BrushID = b
      
    Default
      DBG.Console.Out("UNKNOW SCENE TRANSITION : " .. self.SceneTransition.Type, DBG.Error, GLFXCh)
      
  EndSwitch
  
EndFunction



;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::: STORYBOARD SCENE'S SUBCLASS ::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

Function GLFX.Scene.Storyboard:Start() ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:Start()

Start the storyboard processing all the events.
---------------------------------------------------------------------

******************************************************************************/
  self.IsPaused = False
  If GetType(self.Timer) <> #NUMBER Then StopTimer(self.Timer)
  Local i, v
  For i, v In IPairs(self.TimedEvents) Do v.Executed = False
  self.Timer = StartTimer(Nil)
  self.LastTE = 0

EndFunction

Function GLFX.Scene.Storyboard:Pause() ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:Pause()

Pause the storyboard execution.
---------------------------------------------------------------------

******************************************************************************/
  self.IsPaused = True
  PauseTimer(self.Timer)

EndFunction

Function GLFX.Scene.Storyboard:Resume() ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:Resume()

Resume a previously paused storyboard
---------------------------------------------------------------------

******************************************************************************/
  self.IsPaused = False
  ResumeTimer(self.Timer)

EndFunction

Function GLFX.Scene.Storyboard:Stop() ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:Stop()

Stop a storyboard execution.
---------------------------------------------------------------------

******************************************************************************/
  self.IsPaused = True
  StopTimer(self.Timer)
  self.Timer = 0

EndFunction

Function GLFX.Scene.Storyboard:New() ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:New()

Initialize a scene's storyboard
---------------------------------------------------------------------

******************************************************************************/
  If GetType(self.Timer) <> #NUMBER
    StopTimer(self.Timer)
    
  EndIf
  self.Events = {}
  
EndFunction

Function GLFX.Scene.Storyboard:AddTimedEvent(event) ; 04/2021
/******************************************************************************
GLFX.Scene.Storyboard:AddTimedEvent(event)

Add a timed event to storyboard.
---------------------------------------------------------------------
INPUT
  event : A table defining the event
    name : Event name
    time : Event time (ms), when the event must be executed
    callback : Callback function, this function will be called with
               the following arguments:
                 callback(userdata, time, scene)
    userdata : Free field to pass data to the callback function
******************************************************************************/
  self.TimedEvents[event.time] =
    { name     = event.name,
      callback = event.callback,
      userdata = event.userdata,
      executed = False }

EndFunction

Function GLFX.Scene.Storyboard:AddTriggeredEvent(event) ; 04/2021, NOT YET IMPLEMENTED INTO THE ENGINE
/******************************************************************************
GLFX.Scene.Storyboard:AddTriggeredEvent(event)

Add a condition that will trigger an event.
:::::::::::::::::::::::::
::: NOT YET SUPPORTED :::
:::::::::::::::::::::::::
******************************************************************************/
  ; event
  ;   - name
  ;   - trigger -> { target=What object, param=Which parameter, cond=Condition, value=value to compare}
  ;   - callback
  ;   - userdata
  self.TriggeredEvents[name] =
  { name = event.name,
    trigger  = event.trigger,
    callback = event.callback,
    userdata = event.userdata }

EndFunction


;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::: SPRITE ENGINE CLASS :::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
Const #SE_TRG_SPRITE1 = -99999      ; Target sprite (every node)
Const #SE_TRG_SPRITE2 = -99998      ; Target sprite (continuosly)
Const #SE_STR_CURRENT = -99997      ; Start = Current position

GLFX.SpriteEngine =
  { SpriteList = {},                ; List of all defined sprites
    PartSystems = {},               ; Particle systems of this sprite engine
    Layers     = { },               ; Lists by layer and YOrder
    layermax   = 0,                 ; Max layer defined
    Brushes    = {},                ; SimpleSprite brushes list
    BrushID    = 0,
    Animations = {},                ; ComplexSprite animations list
    Groups     = {},                ; Sprite's group lists
    CollGroups = {},                ; Group collisions
    YSorted    = False,             ; Flag: True = YSorting enabled
    YSortForced = False,            ; Flag: True = YSorting forced for all sprites
    UpdateTimer = -1,               ; Timer used for animations and
                                    ; paths updates
    SpritesToDestroy = {},          ; List of sprites marked to be destroyed
    
    Framework = {}                  ; Father framework
    }

Function GLFX.SpriteEngine:CleanupSprites()
  Local cnt = ListItems(self.SpritesToDestroy)-1
  
  For Local s = 0 To cnt
    
    Local sprite = self.SpritesToDestroy[s]
    
    ; Remove the sprite from the Engine's SpriteList
    For i, v In IPairs(self.SpriteList)
      If v = sprite
        RemoveItem(self.SpriteList, i)
        Break
      EndIf
    Next

    ; Remove the sprite from the Engine's SortedList
    Local Lookup = self.Layers[sprite.Layer].SortedList[sprite.SortedIndex]
    For i, v In Pairs(Lookup)
      If v = sprite
        RemoveItem(Lookup, i)
        Break
      EndIf
    Next
    
    ; Remove the sprite from the Engine's UnsortedList
    Local Lookup = self.Layers[sprite.Layer].UnsortedList
    For i, v In Pairs(Lookup)
      If v = sprite
        RemoveItem(Lookup, i)
        Break
      EndIf
    Next

    ; Remove the sprite from SpriteGroups
    Local Lookup = self.Groups[sprite.Group]
    For i, v In Pairs(Lookup)
      If v = sprite
        RemoveItem(Lookup, i)
        Break
      EndIf
    Next
    
    /*
    ; Remove the sprite from the Framework list
    If Not(self.IsParticle)
      Local Lookup = self.Engine.Framework.Sprites
      For i, v In Pairs(lookup)
        If v = self
          RemoveItem(Lookup, 1)
          Break
        EndIf
      Next
    EndIf
    */
    
    ; Remove all actions
    sprite:ActionRemoveAll()
    /*
    Local Lookup = self.Actions
    For i, v In Pairs(Lookup)
      Switch v.AType
        Case #SE_ATYPE_INTERVAL
  DebugPrint(i, self.name)
          If TB.Item.Exists(v, "intervalid") Then ClearInterval(v.IntervalID)

        Case #SE_ATYPE_TIMEOUT
          If TB.Item.Exists(v, "timeoutid") Then ClearTimeout(v.TimeoutID)
      EndSwitch
    Next
    */
    
    ; MoveTo tween
    If TB.Item.Exists(sprite, "_movetotween")
      tween.stop(sprite._MoveToTween, False)
    EndIf
    ; Remove path's tweens
    If TB.Item.Exists(sprite.Paths, "tweenidx")
      tween.stop(sprite.Paths.TweenIDx, False)
    EndIf
    If TB.Item.Exists(sprite.Paths, "tweenidy")
      tween.stop(sprite.Paths.TweenIDy, False)
    EndIf
    ;| Pause Path command ID
    If TB.Item.Exists(sprite.Paths, "pausetimeoutid")
      ClearTimeout(sprite.Paths.PauseTimeoutID)
    EndIf
    
    ; Brush handling (occhio alla versione simplesprite/complexsprite)
    If sprite.file <> ""
      ; The brush was loaded at creation time, can be freed
      ;DebugPrint("Freeing brush ", self.id)    
      ; DebugPrint("Destroy sprite ", self)
      
      gl.DeleteTextures({ sprite.id })
      FreeBrush(sprite.id)
      
    ElseIf sprite.IsAtlas
      gl.DeleteTextures({ sprite.id })
      FreeBrush(sprite.id)

    EndIf
    
    ; Parallax Fx
    If HaveItem(sprite, "_parallaxsprites")
      ; Non sono altro che DisplayList
      ;For i, v In IPairs(self._parallaxSprites)
        ;v:Destroy()
        gl.DeleteLists(sprite._parallaxSprites, 1)
      ;Next
      sprite._parallaxSprites = Nil
    EndIf
      
  Next
  
  self.SpritesToDestroy = {}

EndFunction

Function GLFX.SpriteEngine:All_DrawOrdered(offsetx, offsety)
/******************************************************************************
GLFX.SpriteEngine:All_DrawOrdered(offsetx, offsety)

Draw all engine's sprites in an ordered mode, for each layer, starting from the
lower layer (0) to the highest one. All sprites will be ordered on their Y
coordinate. This is very useful for isometric and pseudo 3d engines.
---------------------------------------------------------------------
INPUT
  offsetX   Sprites offset x
  offsetY   Sprites offset y
******************************************************************************/

  ;| Update group collisions
  self:_UpdateGroupsCollision()

  ;| Draw all ordered sprites starting from layer 0
  Local i, v, m, n
  For i, v In IPairs(self.Layers)
    For Local k = v.FirstIndex To v.LastIndex
      If TB.Item.Exists(v.SortedList, k)
        For m, n In Pairs(v.SortedList[k])
          n:Draw(offsetx, offsety)
        Next
      EndIf
    Next
  Next
EndFunction

Function GLFX.SpriteEngine:All_DrawUnorderedLayered(offsetx, offsety)
/******************************************************************************
GLFX.SpriteEngine:All_DrawUnorderedLayared(offsetx, offsety)

Draw all engine's sprites starting from the lowest layer (0) to the highest
one but without the Y sorting.
---------------------------------------------------------------------
INPUT
  offsetX   Sprites offset x
  offsetY   Sprites offset y
******************************************************************************/
  self:CleanupSprites()
  
  ;| Update group collisions
  self:_UpdateGroupsCollision()

  ;| Draw all ordered sprites starting from layer 0
  ; The fastest way is to use a for/next with local index whenever possible
  For Local i = 0 To self.LayerMax
    Local v, m, n = self.Layers[i]
    For m, n In IPairs(v.UnsortedList)
      n:Draw(offsetx, offsety)
    Next
    
    ; Check for particle systems
    Local pi, ps
    If RawGet(self.PartSystems, i)
      For pi, ps In Pairs(self.PartSystems[i])
        ps:Draw()
      Next
    EndIf    
  Next

  
  
EndFunction

Function GLFX.SpriteEngine:All_DrawOrderedInv(offsetx, offsety)
/******************************************************************************
GLFX.SpriteEngine:All_DrawOrderedInv(offsetx, offsety)

Draw all engine's sprites in an ordered mode, for each layer, starting from the
higher layer to the lowest one (0). All sprites will be ordered on their Y
coordinate. This is very useful for isometric and pseudo 3d engines.
---------------------------------------------------------------------
INPUT
  offsetX   Sprites offset x
  offsetY   Sprites offset y
******************************************************************************/

  ;| Update group collisions
  self:_UpdateGroupsCollision()

  ;| Draw the sprites starting from the higher layer
  For Local i = self.LayerMax To 0 Step -1
    Local v = self.Layers[i]
    For Local k = v.FirstIndex To v.LastIndex
      If TB.Item.Exists(v.SortedList, k)
        Local m, n
        For m, n In Pairs(v.SortedList[k])
          n:Draw(offsetx, offsety)
        Next
      EndIf
    Next
  Next
EndFunction

Function GLFX.SpriteEngine:All_DrawUnordered(offsetx, offsety) ; OK - PASSATA
/******************************************************************************
GLFX.SpriteEngine:All_DrawUnordered(offsetx, offsety)

Draw all engine's sprites ignoring any layer and Y informations.
---------------------------------------------------------------------
INPUT
  offsetX   Sprites offset x
  offsetY   Sprites offset y
******************************************************************************/

  ;| Update group collisions
  self:_UpdateGroupsCollision()

  Local i, v
  For i, v In IPairs(self.SpriteList)
    v:Draw(offsetx, offsety)
  Next
EndFunction

Function GLFX.SpriteEngine:All_DrawUnorderedInv(offsetx, offsety) ; OK - PASSATA
/******************************************************************************
GLFX.SpriteEngine:All_DrawUnorderedInv(offsetx, offsety)

Draw all engine's sprites ignoring any layer and Y informations but in reverse
sorting.
---------------------------------------------------------------------
INPUT
  offsetX   Sprites offset x
  offsetY   Sprites offset y
******************************************************************************/

  ;| Update group collisions
  self:_UpdateGroupsCollision()

  Local c = ListItems(self.SpriteList)
  For Local i = c-1 To 0 Step -1
    self.SpriteList[i]:Draw(offsetx, offsety)
  Next
  Return(c)
EndFunction

Function GLFX.SpriteEngine:Create(Framework)
/******************************************************************************
spriteEngine = GLFX.SpriteEngine:Create()

Create a new sprite engine.
---------------------------------------------------------------------
OUTPUT
  spriteEngine    A new sprite engine object
******************************************************************************/
  DBG.Console.Out("GLFX.SpriteEngine:Create()", DBG.OpenFunc, GLFXCh)
  
  Local NewObj = CopyTable(self)  
  
  DBG.Console.Out("Starting Engine's private timer...", Nil, GLFXCh)
  NewObj.UpdateTimer = StartTimer(Nil)
  
  DBG.Console.Out("Adding the Sprite Engine to the framework list...", Nil, GLFXCh)
  InsertItem(Framework.SpriteEngines, NewObj)
  NewObj.Framework = Framework

  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  Return(NewObj)
EndFunction

Function GLFX.SpriteEngine:Destroy()
/******************************************************************************
GLFX.SpriteEngine:Destroy()

Destroy a sprite engine
******************************************************************************/
  DBG.Console.Out("GLFX.SpriteEngine:Destroy()", DBG.OpenFunc, GLFXCh)
  
  ; Destroy all attached Particle Systems
  Local psremoved, li, ps = 0
  For li, ps In Pairs(self.PartSystems)
    c = ListItems(ps)
    For Local i = c-1 To 0 Step -1
      psremoved = psremoved + 1
      ps[i]:Free()
    Next
  Next
  DBG.Console.Out("All attached particle systems removed : " .. psremoved, Nil, GLFXCh)

  self.PartSystems = {}
  
  ; Destroy the sprites  
  Local c = ListItems(self.SpriteList)
  For Local i = c-1 To 0 Step -1
    self.SpriteList[i]:Destroy()
    self.SpriteList[i] = Nil
  Next
  DBG.Console.Out("All attached sprites removed : " .. c, Nil, GLFXCh)
  
  ; Remove the sprite engine  
  Local c = ListItems(self.Framework.SpriteEngines)
  For Local i = 0 To c-1
    If self.Framework.SpriteEngines[i] = self
      RemoveItem(self.Framework.SpriteEngines, i)
      self.Framework = Nil
      DBG.Console.Out("Sprite engine removed from framework...", Nil, GLFXCh)
      Break()
    EndIf
  Next
  
  ; Destroy queued sprite for destruction
  self:CleanupSprites()
  
  ; Remove scenes?
  
  
  CollectGarbage()
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX.SpriteEngine:FindSpriteByName(SpriteName)
/******************************************************************************
spriteObject = GLFX.SpriteEngine:FindSpriteByName(SpriteName)

Search a sprite engine by its name.
---------------------------------------------------------------------
INPUT
  SpriteName      Sprite name to search
OUTPUT
  spriteObject    Found sprite object or Nil if not found
******************************************************************************/
  Local i, v
  For i, v In IPairs(self.SpriteList)
    If v.Name = SpriteName
      Return(v)
    EndIf
  Next

  Return(Nil)
EndFunction

Function GLFX.SpriteEngine:YSort_Set(enabled, forced)
/******************************************************************************
GLFX.SpriteEngine:YSort_Set(enabled, forced)

Enable/Disable the sprite Y sorting to produce easily pseudo-3d effects based
on the sprite's Y coordinate.
---------------------------------------------------------------------
INPUT
  enabled     Set to TRUE to enable the YSort feature.
  forced      Set to TRUE to force an Y sort at each sprite redraw.
******************************************************************************/
  If Not(IsNil(enabled)) Then self.YSorted = enabled
  If Not(IsNil(Forced)) Then self.YSortForced = Forced
EndFunction

Function GLFX.SpriteEngine:AddGroupCollision(name, group, groups, callback, callback2, singleevent, continuos)
/******************************************************************************
GLFX.SpriteEngine:AddGroupCollision(name, group1, group2, callback, continuos)

Create a SpriteGroup-SpriteGroups collision
---------------------------------------------------------------------
INPUT
  name        Collision set name
  group       Group 1 for collision check
  groups      One or more groups for collision check
  callback    Function to call when a collision occurs, this function
              will be called with a single table with the following
              fields:
                sprite1     colliding sprite1 object
                sprite2     colliding sprite2 object
  callback2   Function called when the collision ends
  singleevent If TRUE all collisions will be reported with a table to
              the callback function otherwise every single collision
              will be reported separately (default)
  continuos   TRUE (default) for continuos reporting
NOTE
  If singleEvent = False all collisions will be reported encapsulated in
  a table indexed with the collision's set name.
*******************************************************************************/
  If HL.IsNil(singleevent) Then singleevent = True
  If HL.IsNil(continuos) Then continuos = True
  
  self.CollGroups[name] =
    { group = group,
      groups = groups,
      callback = callback,
      callback2 = callback2,
      singleevent = singleevent,
      continuos = continuos
      }

  If TB.Item.IsNil(self.CollGroups[name], "callback")
    self.CollGroups[name].Callback = Function() EndFunction
  EndIf
  If TB.Item.IsNil(self.CollGroups[name], "callback2")
    self.CollGroups[name].Callback2 = Function() EndFunction
  EndIf
EndFunction

Function GLFX.SpriteEngine:RemoveGroupCollision(name)
/******************************************************************************
GLFX.RemoveGroupCollision(name)

Remove a group collision.
---------------------------------------------------------------------
INPUT
  name      Set name to remove or Nil to remove all sets
******************************************************************************/
  If HL.IsNil(name)
    self.CollGroups = Nil
  Else
    If TB.Item.Exists(self.CollGroups, name)
      self.CollGroups[name] = Nil
    EndIf
  EndIf
EndFunction

Function GLFX.SpriteEngine:_UpdateGroupsCollision()
/******************************************************************************
GLFX.SpriteEngine:_UpdateGroupsCollision()

Check all group collisions and execute the callback functions.
******************************************************************************/
  Local i, g
  For i, g In Pairs(self.CollGroups)
    ;DebugPrint(i, g)
    Local collisions = {}
    Local setname = i
    Local g1 = g.group
    Local gs = g.groups
    
    ; Check if the collision group is defined in the SpriteEngine
    If TB.Item.Exists(self.Groups, g1)
      ; Iterate every sprite in the group1
      Local gs1, spriteG1, g2i, g2g, g3i, spriteG2
      For gs1, spriteG1 In Pairs(self.groups[g1])
        If spriteG1.IsVisible And Not(spriteG1.IsKilled)
          ; For each target groups
          For g2i, g2g In Pairs(gs)
            If TB.Item.Exists(self.Groups, g2g)
              For g3i, spriteG2 In Pairs(self.Groups[g2g])
                Local s1x, s1y, s2x, s2y = spriteG1.x, spriteG1.y, spriteG2.x, spriteG2.y
                If spriteG1.Type = #BACKGROUND
                  If spriteG1.BGType = #BGTYPE_HEIGHTMAP
                    s1x, s1y = spriteG1.BGArea.x, spriteG1.BGArea.y
                  EndIf
                EndIf
                If spriteG2.Type = #BACKGROUND
                  If spriteG2.BGType = #BGTYPE_HEIGHTMAP
                    s2x, s2y = spriteG2.BGArea.x, spriteG2.BGArea.y
                  EndIf
                EndIf
                
                If TB.Item.Exists(spriteG1.Attributes, "anchorx")
                  b1w = GetAttribute(#BRUSH, spriteG1.brush_id, #ATTRWIDTH)
                  s1x = s1x - b1w*spriteG1.Attributes.AnchorX
                EndIf
                If TB.Item.Exists(spriteG1.Attributes, "anchory")
                  b1h = GetAttribute(#BRUSH, spriteG1.brush_id, #ATTRHEIGHT)
                  s1y = s1y - b1h*spriteG1.Attributes.AnchorY
                EndIf
                
                If TB.Item.Exists(spriteG2.Attributes, "anchorx")
                  b2w = GetAttribute(#BRUSH, spriteG2.brush_id, #ATTRWIDTH)
                  s2x = s2x - b1w*spriteG2.Attributes.AnchorX
                EndIf
                If TB.Item.Exists(spriteG2.Attributes, "anchory")
                  b2h = GetAttribute(#BRUSH, spriteG2.brush_id, #ATTRHEIGHT)
                  s2y = s2y - b2h*spriteG2.Attributes.AnchorY
                EndIf
                
                /*
                SetFillStyle(#FILLCOLOR)
                Box(s1x, s1y, GetAttribute(#BRUSH, spriteG1.brush_id, #ATTRWIDTH), GetAttribute(#BRUSH, spriteG1.brush_id, #ATTRHEIGHT), #RED)
                Box(s2x, s2y, GetAttribute(#BRUSH, spriteG2.brush_id, #ATTRWIDTH), GetAttribute(#BRUSH, spriteG2.brush_id, #ATTRHEIGHT), #GREEN)
                Flip()
                */
                
                Local brush1 = spriteG1.brush_id
                Local brush2 = spriteG2.brush_id
                
                If spriteG1.Type = #COMPLEX_SPRITE
                  brush1 = CreateBrush(Nil, GetAttribute(#ANIM, spriteG1.Anim.Anim_id, #ATTRWIDTH), GetAttribute(#ANIM, spriteG1.Anim.Anim_id, #ATTRHEIGHT, { AlphaChannel = True}))
                  SelectBrush(brush1, #SELMODE_COMBO)
                  spriteG1:Draw(-s1x, -s1y)
                  EndSelect
                EndIf
                If spriteG2.Type = #COMPLEX_SPRITE
                  brush2 = CreateBrush(Nil, GetAttribute(#ANIM, spriteG2.Anim.Anim_id, #ATTRWIDTH), GetAttribute(#ANIM, spriteG2.Anim.Anim_id, #ATTRHEIGHT, { AlphaChannel = True}))
                  SelectBrush(brush2)
                  spriteG2:Draw(-s1x, -s1y)
                  EndSelect()
                EndIf
                  
                Local CollisionDetected = Collision(#BRUSH, brush1, s1x, s1y, brush2, s2x, s2y)
                
                If spriteG1.Type = #COMPLEX_SPRITE Then FreeBrush(brush1)
                If spriteG2.Type = #COMPLEX_SPRITE Then FreeBrush(brush2)
                
                If CollisionDetected
                  ; COLLISION DETECTED
                  If TB.Item.IsNil(spriteG1.GroupColls, spriteG2)
                    ; No previous collision, raise event
                    If TB.Item.IsNil(collisions, setname) Then collisions[setname] = {}
                    
                    If g.singleevent
                      g.callback({ sprite1 = spriteG1, sprite2 = spriteG2 })
                    Else
                      InsertItem(collisions[setname], { sprite1 = spriteG1, sprite2 = spriteG2 })
                    EndIf
                    spriteG1.GroupColls[spriteG2] = 1
                    spriteG2.GroupColls[spriteG1] = 1
                  Else
                    ; Previous collision, raise event only if countinuos = TRUE
                    If g.continuos
                      If TB.Item.IsNil(collisions, setname) Then collisions[setname] = {}
                      
                      If g.singleevent
                        g.callback({ sprite1 = spriteG1, sprite2 = spriteG2 })
                      Else
                        InsertItem(collisions[setname], { sprite1 = spriteG1, sprite2 = spriteG2 })
                      EndIf
                    EndIf
                  EndIf
                
                Else
                  ; NO COLLISIONS
                  ; Reset previous collisions
                  If TB.Item.Exists(spriteG1.GroupColls, spriteG2)
                    spriteG1.GroupColls[spriteG2] = Nil
                    spriteG2.GroupColls[spriteG1] = Nil
                    If g.singleevent Then g.callback2({ sprite1 = spriteG1, sprite2 = spriteG2 })
                  EndIf
                EndIf
              Next
            EndIf
          Next
        EndIf
      Next
    EndIf

    If Not(g.singleevent) Then g.callback(collisions)

  Next
EndFunction

Function GLFX.SpriteEngine:All_Translate(x, y, Layer)
/******************************************************************************
GLFX.SpriteEngine:All_Translate(x, y, Layer)

translate all defined sprites for the given layer by x and y pixels. If the
layer isn't specified all sprites will be translated.
---------------------------------------------------------------------
INPUT
  x       Horizontal translation value
  y       Vertical translation value
  layer   Layer or nil for the translation effect
******************************************************************************/
  If HL.IsNil(Layer)
    ;| Trasla tutti gli sprite
    Local i, v
    For i, v In Pairs(self.SpriteList) Do v:Translate(x, y)
  Else
    ;| Trasla solo il layer specificato
    If TB.Item.IsNil(self.Layers, Layer) Then Return()
    Local v, m, n = self.Layers[Layer]
    For Local k = v.FirstIndex To v.LastIndex
      If TB.Item.Exists(v.SortedList, k)
        For m, n In Pairs(v.SortedList[k])
          n:Translate(x, y)
        Next
      EndIf
    Next
  EndIf
EndFunction

Function GLFX.SpriteEngine:All_AttributesSet(Attributes, Layer)
/******************************************************************************
GLFX.SpriteEngine:All_AttributesSet(Attributes, Layer)

Overwrite sprite's rendering attributes for the specified layer, i the layer
is not specified changes will be applied to all sprite's layers.
Undefined attributes will be skipped.
---------------------------------------------------------------------
INPUT
  Attributes      A table with all attributes to set
  Layer           Layer ID or Nil
******************************************************************************/
  If HL.IsNil(Layer)
    ;| Aggiorna tutti gli sprite
    Local i, v
    For i, v In Pairs(self.SpriteList) Do v:AttributesSet(Attributes)
  Else
    ;| Aggiorna solo il layer specificato
    If TB.Item.IsNil(self.Layers, Layer) Then Return()
    Local v, m, n = self.Layers[Layer]
    For Local k = v.FirstIndex To v.LastIndex
      If TB.Item.Exists(v.SortedList, k)
        For m, n In Pairs(v.SortedList[k])
          n:AttributesSet(Attributes)
        Next
      EndIf
    Next
  EndIf
EndFunction

Function GLFX.SpriteEngine:All_AttributesAdd(Attributes, Layer)
/******************************************************************************
GLFX.SpriteEngine:All_AttributesAdd(Attributes, Layer)

Overwrite/Add all specified rendering attributes for the given layer or if
layer is not specified, to all sprite's layers.
---------------------------------------------------------------------
INPUT
  Attributes      A table with all attributes to set
  Layer           Layer ID or Nil
******************************************************************************/
  If HL.IsNil(Layer)
    ;| Aggiorna tutti gli sprite
    Local i, v
    For i, v In Pairs(self.SpriteList) Do v:AttributesAdd(Attributes)
  Else
    ;| Aggiorna solo il layer specificato
    If TB.Item.IsNil(self.Layers, Layer) Then Return()
    Local v, m, n = self.Layers[Layer]
    For Local k = v.FirstIndex To v.LastIndex
      If TB.Item.Exists(v.SortedList, k)
        For m, n In Pairs(v.SortedList[k])
          n:AttributesAdd(Attributes)
        Next
        EndIf
    Next
  EndIf
EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::: TILE MAP CLASS ::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
; La implemento utilizzando gli sprite (che potranno essere anche animati), in
; pratica dovrò inizializzare un oggeto TileMap con:
;    TileMapObject = SpriteEngineObject.TileMap:New()
;
; A questo punto posso caricare una mappa predefinita con:
;    TileMapObject:Load()
;
; Potrò anche salvarla con:
;    TileMapObject:Save()
;
; Oppure posso modificarla/crearla con:
;    TileMapObject:Setup()
;
; La mappa ha un solo livello, ma possono essere create più mappe per
; renderizzarle a proprio piacimento con:
;    TileMapObject:Draw()
; 
; La mappa e le relative risorse possono essere liberate con:
;    TileMapObject:Free()
;
; Tutte le mappe sono legate e memorizzate in uno sprite engine.
;
; -----------------------------------------------------------------------------
; Map =
;  { position = { x = <n>, y = <n> },        posizione di rendering prima cella
;    mapSize  = { r = <n>, c = <n> },        numero <r>ighe e <c>olonne della mappa
;    tileSize = { w = <n>, h = <n> },        dimensione singola tile (tutti gli sprite avranno questa dimensione)
;    sprites = { ... },                      lista degli sprite usati per le celle
;    map[r]                                  mappa degli sprite usati per ogni cella
;          [c]                               organizzata in [riga][colonna].
;    }
; -----------------------------------------------------------------------------
; Quando creo gli sprite questi non devo andare assieme a tutti gli altri ma
; in una lista a parte perchè saranno renderizzati da soli con l'apposito
; metodo, anche perchè ci saranno sicuramente delle repliche all'interno della
; mappa che andranno gestite separatamente.
; Questo approccio dinamico permette di avere anche sprite animati come tile
; mentre se dovessi realizzare un'immagine statica, in primo luogo avrei sprecato
; un sacco di memoria e in secondo luogo non potrei animare gli sprite, ma anche
; un semplice aggiornamento della mappa genererebbe un ricalcolo completo.
; Durante il rendering della mappa posso verificare se la cella è visibile o
; meno e procedere o meno al rendering dello sprite.
; -----------------------------------------------------------------------------
GLFX.TileMap = {}
GLFX.TileMap.Name       = ""
GLFX.TileMap.Position   = { x = 0, y = 0 }
GLFX.TileMap.Scale      = { w = 1, h = 1 }
GLFX.TileMap.mapSize    = { r = 16, c = 16 }
GLFX.TileMap.tileSize   = { w = 16, h = 16 }
GLFX.TileMap.Sprites    = {}
GLFX.TileMap.Map        = {}
GLFX.TileMap.Map.Layers = {}

Function GLFX.TileMap:New(args)
  ; args
  ;   .name           = Map Name
  ;   .mapSize        = Map Size in cells (rows, columns)
  ;   .tileSize       = Single tile size (width, height)
  ;   .sourceTiles    = Atlas sprite
  ;   .framesDef      = Atlas definition
  
  ; Create a new empty tile map and preload all the needed
  ; tiles.
  
  DBG.Console.Out("GLFX.TileMap:New()", DBG.OpenFunc, GLFXCh)
  
  If TB.Item.IsNil(args, "sourcetiles")
    DBG.Console.Out("Source tiles atlas not specified!", DBG.Error, GLFXCh)
    DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
    Return(False)
  EndIf
    
  Local newMap = CopyTable(self)
  If TB.Item.Exists(args, "name") Then newMap.Name = args.Name
  If TB.Item.Exists(args, "mapsize") Then newMap.mapSize = args.mapSize
  If TB.Item.Exists(args, "tileSize") Then newMap.tileSize = args.tileSize
  
  Return(newMap)
  
EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::: SPRITE PATH SEQUENCES ::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
GLFX.PathNode = {}
GLFX.PathNode.startPos = {}          ; Starting position
GLFX.PathNode.startPos.x = 0         ; Starting x
GLFX.PathNode.startPos.y = 0         ; Starting y
GLFX.PathNode.startOffset = {}       ; Starting position offset
GLFX.PathNode.startOffset.x = 0      ; Offset x
GLFX.PathNode.startOffset.y = 0      ; Offset y
GLFX.PathNode.endPos = {}            ; Ending position
GLFX.PathNode.endPos.x = 0           ; Ending x
GLFX.PathNode.endPos.y = 0           ; Ending y
GLFX.PathNode.endOffset = {}         ; Ending offset
GLFX.PathNode.endOffset.x = 0        ; Offset x
GLFX.PathNode.endOffset.y = 0        ; Offset y
GLFX.PathNode.runtime = 0            ; Movement duration (ms)
GLFX.PathNode.modex = "linear"       ; Movement x easing (see tween library)
GLFX.PathNode.modey = "linear"       ; Movement y easing (see tween library)

; NODI PARTICOLARI SONO STRINGHE
; startPos = JUMPNODE <node_number>   Jump to a node number
; startPos = JUMPSEQ <sequence name>  Jump to a sequence    
; startPos = PAUSE <milliseconds>     Call the next node after <milliseconds>

Function GLFX.PathNode:New(params) ; 04/2021
/******************************************************************************
node = GLFX.PathNode:New(params)

Create a PathNode object, used when sequences are defined
---------------------------------------------------------------------
INPUT
  params : A table to setup the node
    startPos : Node starting position, must have x and y fields
    startOffset : Optional offset, must have x and y fields
    endPos : Node ending position, must have x and y fields
    endOffset : Optional offset, must have x and y fields
    runtime : Movement duration in milliseconds
    mode : Movement easing, see tween library for a complete list

OUTPUT
  node : The created node

NOTE
  startPos and endPos can be anything that have x and y fields, so
  you can pass here also a sprite because it have the x and y fields.
  startPos can also be a string, in this case it will be interpreted as a
  special command as follow:
    JUMPNODE:<nodenumber>     Jump to the given node number
    JUMPSEQ:<sequencename>    Jump to the given sequence name
    PAUSE:<milliseconds>      Pause the path for the given milliseconds
******************************************************************************/
  ; Create a new PathNode instance
  Local obj = CopyTable(self)
  
  ; Setup all passed parameters
  TB.Set(obj, params, False)
  obj.startPos = params.startPos
  If HaveItem(params, "endpos") Then obj.endPos = params.endPos
  
  Return(obj)
  
EndFunction


GLFX.PathSequences = {}                  ; Path sequences object
GLFX.PathSequences.Sequences = {}        ; All available sequences
GLFX.PathSequences.currentSequence = {}  ; Current sequence
GLFX.PathSequences.currentNode = 0       ; Current node in current sequence
GLFX.PathSequences.sequenceCount = 0     ; Sequence count
GLFX.PathSequences.tweenIDx = Nil        ; Current movement tween id x
GLFX.PathSequences.tweenIDy = Nil        ; Current movement tween ID y
GLFX.PathSequences.PauseTimeoutID = Nil  ; Pause special command timeout ID


GLFX.PathSequence = {}                 ; Path sequence object
GLFX.PathSequence.Name = ""            ; Sequence name
GLFX.PathSequence.Nodes = {}           ; List of all nodes in this path
GLFX.PathSequence.nodeCount = 0        ; Node count
GLFX.PathSequence.Loop = False         ; TRUE to enable path loops
GLFX.PathSequence.onEnd = Function() EndFunction   ; onEnd event callback function

  
Function GLFX.PathSequences:New() ; 04/2021
/******************************************************************************
obj = GLFX.PathSequences:New()

Create a new PathSequences object.
---------------------------------------------------------------------

******************************************************************************/
  Local obj = CopyTable(self)
  
  Return(Obj)
  
EndFunction

Function GLFX.PathSequences:AddSequence(name, nodes, loop, onEnd) ; 04/2021
/******************************************************************************
GLFX.PathSequences:AddSequence(name, nodes, loop, onEnd)

Add a new path sequence to a PathSequences object.
---------------------------------------------------------------------
INPUT
  name : Sequence name
  nodes : A list of PathNode objects
  loop : TRUE to make this sequence loop
  onEnd : Callback function called at the end of the sequence
******************************************************************************/
  Local seq = CopyTable(GLFX.PathSequence)
  seq.Name = name
  seq.Nodes = nodes
  seq.NodeCount = ListItems(nodes)
  seq.Loop = loop
  If Not(IsNil(onEnd)) Then seq.onEnd = onEnd
  
  self.sequences[name] = seq
  self.sequenceCount = self.sequenceCount + 1

EndFunction

Function GLFX.PathSequences:SetSequence(name) ; 04/2021
/******************************************************************************
GLFX.PathSequences:SetSequence(name)

Set an existing sequence active in a PathSequences object.
---------------------------------------------------------------------
INPUT
  name : Sequence name to activate
******************************************************************************/
  If TB.Item.Exists(self.sequences, name)
    self.currentSequence = self.Sequences[name]
    self.currentNode = 0
    
  EndIf
  
EndFunction 

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::: SIMPLE SPRITE CLASS :::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

; OBSOLETE STUFF
GLFX.SimpleSprite = {} 
GLFX.SimpleSprite.Name = ""              ; Sprite name
GLFX.SimpleSprite.Layer = 0              ; Layer (draw order, lowest=higher)
GLFX.SimpleSprite.Type = #SIMPLE_SPRITE  ; Sprite type
GLFX.SimpleSprite.x = 0                  ; X Coordinate
GLFX.SimpleSprite.y = 0                  ; Y Coordinate
GLFX.SimpleSprite.z = 0                  ; Z Coordinate
GLFX.SimpleSprite.Group = 0              ; Sprite Group
GLFX.SimpleSprite.Brush_ID = -1          ; Associated brush
GLFX.SimpleSprite.Hidden = False         ; Invisible sprite?
GLFX.SimpleSprite.Attributes = {}        ; Draw attributes
GLFX.SimpleSprite.Attributes.Width = -1  ; Sprite Width in pixels
GLFX.SimpleSprite.Attributes.Height = -1 ; Sprite Height in pixels
GLFX.SimpleSprite.Attributes.ScaleW = 1  ; Width scale factor
GLFX.SimpleSprite.Attributes.ScaleH = 1  ; Height scale factor
GLFX.SimpleSprite.Attributes.AnchorX = 0 ; Horizontal anchor point
GLFX.SimpleSprite.Attributes.AnchorY = 0 ; Vertical anchor point
GLFX.SimpleSprite.Attributes.Color = { 1.0, 1.0, 1.0, 1.0 } ; Color and transparency
GLFX.SimpleSprite.Attributes.Angle = 0   ; Current rotation angle
GLFX.SimpleSprite.Attributes.BlendSrc = #GL_SRC_ALPHA ; Blend mode : source
GLFX.SimpleSprite.Attributes.BlendDst = #GL_DST_ALPHA ; Blend mode : destination
GLFX.SimpleSprite.Attributes.texMapping = { 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0 } ; Texture mapping
GLFX.SimpleSprite.SortIndex = Nil        ; Z Sorting index
GLFX.SimpleSprite.Engine = Nil           ; Sprite engine
GLFX.SimpleSprite.Collisions = {}        ; Collision handling table
GLFX.SimpleSprite.Collisions.WithMouse = {}              ; Collision Sprite-Mouse
GLFX.SimpleSprite.Collisions.WithMouse.Enabled = False   ; Collision enabled?
GLFX.SimpleSprite.Collisions.WithMouse.Collide = False   ; Colliding now?
GLFX.SimpleSprite.Collisions.WithMouse.OnCollision = Function() EndFunction      ; Callback function on collision
GLFX.SimpleSprite.Collisions.WithMouse.OnCollisionStart = Function() EndFunction ; Callback function on collision start
GLFX.SimpleSprite.Collisions.WithMouse.OnCollisionEnd = Function() EndFunction   ; Callback function on collision end
GLFX.SimpleSprite.Collisions.WithSprites = {}            ; Collision Sprite-Sprites
GLFX.SimpleSprite.Collisions.WithSprites.Enabled = False ; Collision enabled
GLFX.SimpleSprite.Collisions.WithSprites.Collide = False ; Colliding now?
GLFX.SimpleSprite.Collisions.WithSprites.SpriteList = {} ; Target sprite list
GLFX.SimpleSprite.Collisions.WithSprites.OnCollision = Function() EndFunction      ; Callback function on collision
GLFX.SimpleSprite.Collisions.WithSprites.OnCollisionStart = Function() EndFunction ; Callback function on collision start
GLFX.SimpleSprite.Collisions.WithSprites.OnCollisionEnd = Function() EndFunction   ; Callback function on collision end
GLFX.SimpleSprite.Zoom = {}              ; Zoom handling
GLFX.SimpleSprite.Zoom.Enabled = False   ; Zoom effect enabled?
GLFX.SimpleSprite.Zoom.StartTime = 0     ; Zoom start time
GLFX.SimpleSprite.Zoom.EndTime = 0       ; Zoom end time
GLFX.SimpleSprite.Zoom.Time = 0          ; Execution time in ms
GLFX.SimpleSprite.Zoom.StartZoom = 0     ; Starting zoom value
GLFX.SimpleSprite.Zoom.EndZoom = 0       ; Ending zoom value
GLFX.SimpleSprite.Zoom.Pulse = False     ; Invert zoom at end?
GLFX.SimpleSprite.Zoom.EndEvent = Function() EndFunction ; Callback function when the effect ends
GLFX.SimpleSprite.Fade = {}              ; Fade handling
GLFX.SimpleSprite.Fade.Enabled = False   ; Fade effect enabled?
GLFX.SimpleSprite.Fade.StartTime = 0     ; Fade start time
GLFX.SimpleSprite.Fade.EndTime = 0       ; Fade end time
GLFX.SimpleSprite.Fade.Time = 0          ; Execution time (ms)
GLFX.SimpleSprite.Fade.StartFade = 0     ; Starting fade value
GLFX.SimpleSprite.Fade.EndFade = 0       ; Ending fade value
GLFX.SimpleSprite.Fade.Pulse = False     ; Invert fade at end?
GLFX.SimpleSprite.Fade.EndEvent = Function() EndFunction ; Callback function when the effect ends
GLFX.SimpleSprite.Roto = {}              ; Rotation handling
GLFX.SimpleSprite.Roto.Enabled = False   ; Rotation effect enabled?
GLFX.SimpleSprite.Roto.StartTime = 0     ; Rotation start time
GLFX.SimpleSprite.Roto.EndTime = 0       ; Rotation end time
GLFX.SimpleSprite.Roto.Time = 0          ; Execution time (ms)
GLFX.SimpleSprite.Roto.StartRoto = 0     ; Starting angle
GLFX.SimpleSprite.Roto.EndRoto = 0       ; Ending angle
GLFX.SimpleSprite.Roto.Loop = False      ; Loop rotation?
GLFX.SimpleSprite.Roto.EndEvent = Function() EndFunction ; Callback function when the effect ends
GLFX.SimpleSprite.Path = {}              ; Path handling

GLFX.SimpleSprite.isClone = False
GLFX.SimpleSprite.isParallax = False
GLFX.SimpleSprite.isParallaxMaster = False
GLFX.SimpleSprite.isParticle = False
GLFX.SimpleSprite.Killed = False
GLFX.SimpleSprite.isDisabled = False

GLFX.SimpleSprite.colorEnabled = False
GLFX.SimpleSprite.angleEnabled = False
GLFX.SimpleSprite.blendEnabled = False

GLFX.SimpleSprite.Paths = GLFX.PathSequences:New()    ; Path sequences

GLFX.SimpleSprite.Actions = {}           ; Stores all actions associated to this sprite added
                                         ; with the method :ActionAdd().
GLFX.SimpleSprite.GroupColls = {}        ; Used to cache group collisions



Function GLFX.SimpleSprite:SetCollisionsWithSprites(params) ; 04/2021
/******************************************************************************
GLFX.SimpleSprite:SetCollisionsWithSprites(params)

Enable collisions handling between this sprite and a list of sprites.
---------------------------------------------------------------------
INPUT
  params : A table that defines the collision behaviours.
    spriteList : A table with all sprite objects to check
    onCollision : Raised when this sprite collide with one of the list
    onCollisionStart : Raised when the collision begins
    onCollisionEnd : Raised when the collision ends

NOTE
  Callback functions will be called with two arguments:
    sprite1 : This sprite
    sprite2 : The colliding sprite in the list
******************************************************************************/
  self.Collisions.WithSprites.Enabled = True
  If HaveItem(params, "oncollision")      Then self.Collisions.WithSprites.OnCollision = Params.OnCollision
  If HaveItem(params, "oncollisionstart") Then self.Collisions.WithSprites.OnCollisionStart = Params.OnCollisionStart
  If HaveItem(params, "oncollisionend")   Then self.Collisions.WithSprites.OnCollisionEnd = Params.OnCollisionEnd
  If HaveItem(params, "spritelist")
    self.Collisions.WithSprites.SpriteList = Params.SpriteList
    For Local i = 0 To ListItems(Params.SpriteList) Do self.Collisions.WithSprites.Collide[i] = False
    
  EndIf

EndFunction

Function GLFX.SimpleSprite:ClearCollisionsWithSprites(events) ; 04/2021
/******************************************************************************
GLFX.SimpleSprite:ClearCollisionsWithSprites(events)

Remove collisions detection with previous specified sprites.
---------------------------------------------------------------------
INPUT
  events : Table with the events to clear
    onCollision : TRUE, clear this event detection
    onCollisionStart : TRUE, clear this event detection
    onCollisionEnd : TRUE, clear this event detection
*******************************************************************************/
  If HaveItem(events, "oncollision")
    If events.OnCollision Then self.Collisions.WithSprites.OnCollision = Nil
    
  EndIf
  
  If HaveItem(events, "oncollisionstart")
    If events.OnCollisionStart Then self.Collisions.WithSprites.OnCollisionStart = Nil
    
  EndIf

  If HaveItem(events, "oncollisionend")
    If events.OnCollisionEnd Then self.Collisions.WithSprites.OnCollisionEnd = Nil
    
  EndIf

  If IsNil(self.Collisions.WithSprites.OnCollision) And 
     IsNil(self.Collisions.WithSprites.OnCollisionOnCollisionStart) And 
     IsNil(self.Collisions.WithSprites.OnCollisionOnCollisionEnd)
    self.Collisions.WithSprites.Enabled = False
    self.Collisions.WithSprites.Collide = {}
    
  EndIf
  
EndFunction


;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::: COMPLEX SPRITE CLASS ::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
GLFX.ComplexSprite = CopyTable(GLFX.SimpleSprite)

GLFX.ComplexSprite.Type = #COMPLEX_SPRITE
GLFX.ComplexSprite.AlphaChannel = True
GLFX.ComplexSprite.Mask = False

GLFX.ComplexSprite.Anim = {}
GLFX.ComplexSprite.Anim.Enabled = True
GLFX.ComplexSprite.Anim.TimerID = -1
GLFX.ComplexSprite.Anim.NextTimeout = -1
GLFX.ComplexSprite.Anim.CurrentSequence = -1
GLFX.ComplexSprite.Anim.CurrentFrame    = -1
GLFX.ComplexSprite.Anim.SequenceFrames  = -1
GLFX.ComplexSprite.Anim.Sequences = {}
GLFX.ComplexSprite.Anim.EndEvent = Nil
GLFX.ComplexSprite.Anim.Anim_ID = -1



Function GLFX:DrawAllSprites()
/******************************************************************************
GLFX:DrawAllSprites()

Renders all engine's sprites
******************************************************************************/

  ; For each layer
  Local i, v, ii, vv, pi, ps
  For i, v In IPairs(self.Sprites)
    ; For each sprite
    For ii, vv In IPairs(v)
      If vv.isVisible Then vv:Draw()
    Next
    If RawGet(self.PartSystems, i)
      ; PartSystems in this layer
      For pi, ps In IPairs(self.PartSystems[i])
        ; Update each particle
        ps:Draw()
      Next
    EndIf
  Next

EndFunction








Function GLFX.Scene:Destroy() ; 04/2021, METHOD NOT YET IMPLEMENTED
  DebugPrint("*** GLFX.Scene:Destroy() MISSING ***")

EndFunction



;=======================================
; SPRITE CLASS
;=======================================

; Sprite Object
; -------------
GLFX.Sprite = 
  { name             = "",        ; Sprite name (optional, if not specified a random one will be used)
    layer            = 0,         ; Sprite layer
    group            = 0,         ; Sprite group (optional)
    id               = -1,        ; Associated brush ID
    order            = -1,        ; Draw order
    file             = "",        ; Source file
    engine           = {},        ; Sprite Engine
    ;hardware         = True,
    
    animated         = False,     ; Animated sprite?
    useAtlas         = False,     ; Use atlas for animation frames?
    atlas            = {},        ; Used atlas
    atlasIndex       = -1,        ; Atlas index
    frameList        = {},        ; List of current animation frames
    animations       = {},        ; All defined animations
    currentAnimation = 0,         ; Current animation index
    currentFrame     = 0,         ; Current animation frame
    animationFrames  = 0,         ; Total frames of current animation
    nextFrameTime    = 0,         ; When the next frame must be switched
    lastUpdateTime   = 0,         ; Last time of update
    animDirection    = 1,         ; Animation direction (1=Forward, -1=Backward)
    animationPaused  = True,      ; Is animation paused?
    atlasAnimation   = False,     ; Animation frames use atlas?
    
    x                = 0,         ; X coordinate
    y                = 0,         ; Y Coordinate
    z                = 0,         ; Z Coordinate
    width            = 0,         ; Width
    height           = 0,         ; Height
    scaleW           = 1,         ; Scale Width (factor)
    scaleH           = 1,         ; Scale Height (factor)
    anchorX          = 0.5,       ; Anchor X
    anchorY          = 0.5,       ; Anchor Y
    lockInside       = False,     ; Is it locked inside the screen area?
    color            = { 1.0,     ; Main color, Red
                         1.0,     ;  Green
                         1.0,     ;  Blue
                         1.0 },   ;  Transaprency
    polyColor        = { 1.0,     ; Collision polygon color, Red
                         0.0,     ;  Green
                         0.0,     ;  Blue
                         0.5 },   ;  Transparency
    angle            = 0,         ; Current angle
    
    blendSrc         = #GL_SRC_ALPHA,           ; Blend source (OpenGL)
    blendDst         = #GL_ONE_MINUS_SRC_ALPHA, ; Blend Destination (OpenGL)
                       ; Texture mapping brush -> texture
    texMapping       = { 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0 },
    ;   (A)----(B)        +--A--+   +--B--+   +--C--+   +--D--+
    ;    |      |
    ;    |      |
    ;   (C)----(D)
    
    static           = False,     ; Static texture?
    staticDispList   = -1,        ; Static display list?
    
    transparency     = -1,        ; Transparent color
    haveAlpha        = False,     ; Brush has alpha channel?
    haveTransparency = False,     ; Brush has transparency color?
    isVector         = False,     ; Brush is a vector?
    
    isVisible        = True,      ; Sprite is visible?
    isClone          = False,     ; Sprite is a clone of another sprite?
    
    isParallax       = False,     ; Sprite is a parallax item?
    isParallaxMaster = False,     ; Sprite is the parallax root?
    
    isParticle       = False,     ; Sprite is a particle?
    
    isKilled         = False,     ; Sprite has been killed?
    
    isAtlas          = False,     ; Sprite is an atlas?
    
    colorEnabled     = False,     ; is color mode enabled?
    angleEnabled     = False,     ; is rotation enabled?
    blendEnabled     = False,     ; is blending enabled
    
    actions          = {},        ; Actions associated with this sprite
    paths            = {},        ; Paths associated with this sprite
    collisions       =                                  ; Collision definitions
      { withmouse =                                     ;  COLLISIONS WITH MOUSE
        { enabled          = False,                     ;  Enabled/Disabled
          collide          = False,                     ;  Collision flag
          Events =                                      ;  Collision events
           { OnCollision      = Function() EndFunction, ;   During collision
             OnCollisionStart = Function() EndFunction, ;   When collision is detected for the first time
             OnCollisionEnd   = Function() EndFunction  ;   When collision ends
             }
          },
        withsprites =                                   ;  COLLISIONS WITH SPRITES
        { enabled       = False,                        ;  Enabled/Disabled
          collide       = {},                           ;   Table of collision flags with other sprites
          polycoll      = {},                           ;   Table of polygon collisions
          polyrender    = False,                        ;   Flag to enable the polygon collision rendering
          spritelist    = {},                           ;   Sprite list to monitor for collisions
          Events =                                      ;   Collision events
           { OnCollision      = Function() EndFunction, ;    During collisions
             OnCollisionStart = Function() EndFunction, ;    When collision starts
             OnCollisionEnd   = Function() EndFunction  ;    When collision ends
             }
          },
        withgroups =                                    ;  COLLISIONS WITH GROUPS
        { enabled = False,                              ;  Enabled/Disabled
          collide       = {},                           ;   Table of collision flags with other sprites
          polycoll      = {},                           ;   Table of polygon collisions
          polyrender    = False,                        ;   Flag to enable the polygon collision rendering
          grouplist     = {},                           ;   Group list to monitor for collisions
          Events =                                      ;   Collision events
           { OnCollision      = Function() EndFunction, ;    During collisions
             OnCollisionStart = Function() EndFunction, ;    When collision starts
             OnCollisionEnd   = Function() EndFunction  ;    When collision ends
             }

          }
          
        },
    
    boundaries       = Nil,        ; Sprite boundaries      
    sortedIndex      = -1000000    ; Internal index
    }

Function GLFX.Sprite:_UpdateAnimation() ; 26/11/2020
  ;| This func is called by the :draw() method, it's an internal func to
  ;| update the animation's frame of animated sprites.
  ;+-------------------------------------------------------
  If self.Animated
    If self.AnimationPaused
      ; No need to update paused sprites
      Return()
      
    EndIf
    
    ; Use the engine timer to check when to change frame
    Local now = GetTimer(self.Engine.Framework.TimerID)
    
    If now > self.NextFrameTime
      Local delta = now - self.NextFrameTime
      self:NextAnimationFrame()
      Local frameDuration = self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
      
      ; It could be possible that we need to change more than
      ; one frame.
      While delta > frameDuration
        self:NextAnimationFrame()
        delta = delta - frameDuration
        frameDuration = self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
      Wend
      self.NextFrameTime = self.NextFrameTime - delta
      self:SetAnimationFrame(self.currentAnimation, self.currentFrame)
      
    EndIf
    
  EndIf
  
EndFunction

Function GLFX.Sprite:SetAnimationFrame(animation, frame) ; 26/11/2020
  ;| Used with animated sprites, it sets the givend 'frame' number
  ;| as current frame in the specified 'animation'.
  ;+-------------------------------------------------------
 self.currentFrame = frame
 self.id = self.frameList[self.Animations[animation].frames[frame].frame].brush

EndFunction

Function GLFX.Sprite:_UpdatePolyColl() ; 26/11/2020
  ;| Internal func used to update the collisions between object
  ;| using the surrounding polygons.
  ;+-------------------------------------------------------
  Local PolyColl = self.Collisions.WithSprites.PolyColl
  Local Cloned   = self.Collisions.WithSprites.PolyCollClone
  Local Angle    = Rad(self.Angle)
  Local s = Sin(Angle)
  Local c = Cos(Angle)
  Local ssw = PolyColl.SpriteScale.w * self.ScaleW
  Local ssh = PolyColl.SpriteScale.h * self.ScaleH
  Local verts = ListItems(PolyColl.Vertices) ; bufferizzare

  For Local i = 0 To verts-2 Step 2
    ; Ancoraggio
    cloned.Vertices[i]   = PolyColl.Vertices[i] - self.AnchorX
    cloned.Vertices[i+1] = PolyColl.Vertices[i+1] - self.AnchorY
      
    ; Dimensione
    cloned.Vertices[i]   = cloned.Vertices[i] * ssw
    cloned.vertices[i+1] = cloned.Vertices[i+1] * ssh
      
    ; Rotazione
    Local v1 = cloned.Vertices[i]   ; x
    Local v2 = cloned.Vertices[i+1] ; y
    cloned.Vertices[i]   = c*v1 - s*v2
    cloned.Vertices[i+1] = s*v1 + c*v2
      
    ; Posizione
    cloned.Vertices[i]   = cloned.Vertices[i] + self.x
    cloned.Vertices[i+1] = cloned.Vertices[i+1] + self.y
  Next
    
  ; #TODO#
  ; I could try to expand this loop avoiding the G2D:Point objects
  ; to try to speed it up a bit.
  For Local i = 0 To verts-4 Step 2
    Local p1 = G2D.Point:New(cloned.vertices[i], cloned.vertices[i+1])
    Local p2 = G2D.Point:New(cloned.vertices[i+2], cloned.vertices[i+3])
    cloned.normals[i/2] = p1:Normal2D(p2, 0)
  Next

EndFunction

Function GLFX.Sprite:SetBoundaries(boundaries) ; 26/11/2020
  ;| GLFX.Sprite:SetBoundaries(boundaries)
  ;|
  ;| Set sprite boundaries, it can be used also to clear previously
  ;| set boundaries.
  ;| Set boundaries to NIL to remove any existing boundary
  ;|
  ;| INPUT
  ;|   boundaries : Boundaries table
  ;|    top : Top boundary
  ;|    bottom : Bottom boundary
  ;|    left : Left boundary
  ;|    right : Right boundary
  ;+-------------------------------------------------------
  self.boundaries = boundaries

EndFunction

Function GLFX.Sprite:Show()
/******************************************************************************
GLFX.Sprite:Show()

Set the sprite as visible
******************************************************************************/
  self.isVisible = True
EndFunction

Function GLFX.Sprite:Hide()
/******************************************************************************
GLFX.Sprite:Hide()

Set the sprite as hidden
******************************************************************************/
  self.isVisible = False
EndFunction

Function GLFX.Sprite._TimeoutCaller(msg) ; 04/2021
/******************************************************************************
GLFX.Sprite._TimeoutCaller(msg)

INTERNAL function called by the action handler associated with the sprite.
;--------------------------------------------------------------------
******************************************************************************/
  If TB.Item.IsNil(msg.userdata.sprite.Actions, msg.userdata.name) Then Return()
  Local func = msg.userdata.sprite.Actions[msg.userdata.name].Func
  msg.userdata.sprite.Actions[msg.userdata.name] = Nil
  func(msg)

EndFunction

Function GLFX.Sprite:ActionAdd(params) ; 04/2021
/******************************************************************************
GLFX.Sprite:ActionAdd(params)

Add an action to the sprite.
---------------------------------------------------------------------
INPUT
  params : A table with the following fields:
    name : Action name
    atype : Action type, can be one of the following
              #SE_ATYPE_INTERVAL to assign to the sprite an interval function
              #SE_ATYPE_TIMEOUT to assign to the sprite a timeout function
    func : Callback function to call when the event occurs
    args : Additional args for the callback function:
              #SE_ATYPE_INTERVAL -> args = milliseconds (frequency)
              #SE_ATYPE_TIMEOUT  -> args = milliseconds (timeout)
NOTE
  Callback functions will be called with a table as argument with the 
  following fields in the userdata subtable:
    sprite   Sprite object associated with the callback function
    name     Action name
  Existing actions will be deactivated and overwritten.
******************************************************************************/
  If TB.Item.Exists(self.Actions, params.name) Then self:ActionRemove(params.name)

  Switch params.atype
    Case #SE_ATYPE_INTERVAL
      ; Add an interval function call
      self.Actions[params.name] = { atype = params.atype, func = params.func, args = params.args }
      self.Actions[params.name].IntervalID = SetInterval(Nil, params.func, params.args, { sprite = self, name = params.name })

    Case #SE_ATYPE_TIMEOUT
      ; Add a timeout function call
      self.Actions[params.name] = { atype = params.atype, func = params.func, args = params.args }
      self.Actions[params.name].TimeoutID = SetTimeout(Nil, self._TimeoutCaller, params.args, { sprite = self, name = params.name })

  EndSwitch
  
EndFunction

Function GLFX.Sprite:ActionRemoveAll() ; 04/2021
/******************************************************************************
GLFX.Sprite:ActionRemoveAll()

Remove all previously added actions to this sprite
;--------------------------------------------------------------------
******************************************************************************/
  Local i, v
  For i, v In Pairs(self.Actions)
    self:ActionRemove(i)
    
  Next
  
  self.Actions = {}

EndFunction

Function GLFX.Sprite:ActionRemove(name) ; 04/2021
/******************************************************************************
GLFX.Sprite:ActionRemove(name)

Remove the given action from this sprite, if exists.
---------------------------------------------------------------------
INPUT
  name : Name of the action(s) to remove
******************************************************************************/
  If TB.Item.IsNil(self.Actions, name) Then Return()
  
  Switch self.Actions[name].atype
    Case #SE_ATYPE_INTERVAL
      ; Remove an interval function
      ClearInterval(self.Actions[name].IntervalID)
      self.Actions[name].IntervalID = Nil
      
    Case #SE_ATYPE_TIMEOUT
      ; Remove a timeout function
      If HaveItem(self.Actions[name], TimeoutID)
        ClearTimeout(self.Actions[name].TimeoutID)
        self.Actions[name].TimeoutID = Nil

      EndIf

  EndSwitch
  
  self.Actions[name] = Nil
  
EndFunction

Function GLFX.Sprite:BeginDraw(drawMode, mode)
/******************************************************************************
GLFX.Sprite:StartDraw(drawMode)

Target the sprite brush where we can draw additional graphics.
******************************************************************************/
  GFX.OutputDevice.Select(#BRUSH, self.id, drawMode, mode)
EndFunction

Function GLFX.Sprite:EndDraw()
/******************************************************************************
GLFX.Sprite:EndDraw()

Ends the draw mode and update the sprite texture.
******************************************************************************/
  GFX.OutputDevice.EndSelect()
  GLFX._texInit(self.id, True)
EndFunction

Function GLFX.Sprite:Destroy()
/******************************************************************************
GLFX.Sprite:Destroy()

Destroy the sprite an free its resources.
******************************************************************************/
  If self.IsKilled And Not(self.IsParallax)
    ;DBG.Console.Out("Attempt to destroy an already destroyed sprite.", DBG.Error, dCh)
    Return()
  EndIf
  
  ; Put this sprite in the destroy list
  InsertItem(self.Engine.SpritesToDestroy, self)
  
  self.IsKilled = True
  
EndFunction

Function GLFX.Sprite:NewFromFrameBuffer(engine, args)
  Local w = engine.framework.width
  Local h = engine.framework.height
  gl.ReadPixelsToBrush(0, 0, w, h, 9999999)
  Local sprite = self:NewFromBrush(9999999, engine, args)
  Return(sprite)
EndFunction

Function GLFX.Sprite:NewFromBrush(brushID, engine, args)
/******************************************************************************
GLFX.Sprite:NewFromBrush(brushID, engine, args)

Create a new sprite from a loaded brush with the given args
******************************************************************************/
  Local obj = CopyTable(self)
  
  TB.Set(obj, args, False)
   
  obj.width            = GetAttribute(#BRUSH, brushID, #ATTRWIDTH)
  obj.height           = GetAttribute(#BRUSH, brushID, #ATTRHEIGHT)
  obj.haveAlpha        = GetAttribute(#BRUSH, brushID, #ATTRHASALPHA)
  obj.isVector         = IIf(GetAttribute(#BRUSH, brushID, #ATTRTYPE)=#IMAGETYPE_VECTOR, True, False)
  ;obj.haveTransparency = infos.transparency
  ;obj.file             = brushFile
  obj.engine           = engine
    
  Local loadArgs = {}
  If obj.haveAlpha
    loadArgs.LoadAlpha = True
  ElseIf obj.haveTransparency
    loadArgs.LoadTransparency = True
  ElseIf obj.transparency <> -1
    loadArgs.Transparency = obj.transparency
  EndIf
  
  obj.id = BrushID ; ???
  obj.Brush_ID = BrushID
  
  GLFX._TexInit(obj.id)

    ; Save the sprite in the spriteEngine spritelist
    If TB.Item.IsNil(Engine.Layers, obj.Layer)
      Engine.Layers[obj.Layer] = 
        { SortedList = {},
          UnsortedList = {},
          FirstIndex = 0,
          LastIndex  = 0 }
    EndIf

    If TB.Item.IsNil(Engine.Groups, obj.Group)
      Engine.Groups[obj.Group] = {}
      InsertItem(Engine.Groups[obj.Group], obj)
    Else
      InsertItem(Engine.Groups[obj.Group], obj)
    EndIf
    
    If TB.Item.Exists(Engine.Layers[obj.Layer].SortedList, obj.y)
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    Else
      Engine.Layers[obj.Layer].SortedList[obj.y] = {}
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    EndIf

    If TB.Item.Exists(Engine.Layers[obj.Layer], "unsortedlist")
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    Else
      Engine.Layers[obj.Layer].UnsortedList = {}
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    EndIf

    If Engine.Layers[obj.Layer].FirstIndex > obj.y Then Engine.Layers[obj.Layer].FirstIndex = obj.y
    If Engine.Layers[obj.Layer].LastIndex < obj.y Then Engine.Layers[obj.Layer].LastIndex = obj.y

    obj.SortedIndex = obj.y
    obj.Engine = Engine

    ;| Durante l'inserimento verifica i layer intermedi
    For Local i = 0 To obj.Layer - 1
      If TB.Item.IsNil(Engine.Layers, i)
        Engine.Layers[i] = 
          { SortedList = {},
            FirstIndex = 0,
            LastIndex  = 0,
            UnsortedList = {} }
      EndIf
    Next

    If obj.Engine.LayerMax < obj.Layer Then obj.Engine.LayerMax = obj.Layer
    
    ;InsertItem(Engine.Framework.Sprites, obj)
    InsertItem(Engine.SpriteList, obj)
    
    Return(obj)

EndFunction

Function GLFX.Sprite:Clone(args)
/******************************************************************************
GLFX.Sprite:Clone(args)

Clone the current sprite and changes the given args in the cloned sprite.
-----------------------------------------
args
  standard sprite args
  
  cloneActions = True|False : Default = True
******************************************************************************/
  If IsNil(args) Then args = { CloneActions = True }
  If TB.Item.IsNil(args, "cloneactions") Then args.CloneActions = True
  
  Local engine = self.engine
  
  self.engine = {}
  
  ; Serve per evitare un overflow nella duplicazione della tabella
  If TB.Item.Exists(self, "_movetotween")
    self._movetotween = Nil
  EndIf
  
  Local obj = CopyTable(self)
  
  TB.Set(obj, args, False)

  self.engine = engine
  obj.engine  = engine
  obj.isClone = True
  obj.file    = ""

  Local Framework = Engine.Framework
  
  If args.CloneActions
    ; Actions cannot be cloned but recreated
    Local actions = CopyTable(obj.Actions)
    obj.Actions = {}
    For ai, ar In Pairs(actions)
      obj:ActionAdd(
        { name = ai,
          atype = ar.atype,
          args = ar.args,
          func = ar.func
          })
    Next
  EndIf
  
    ; Save the sprite in the spriteEngine spritelist
    If TB.Item.IsNil(Engine.Layers, obj.Layer)
      Engine.Layers[obj.Layer] = 
        { SortedList = {},
          UnsortedList = {},
          FirstIndex = 0,
          LastIndex  = 0 }
    EndIf

    If TB.Item.IsNil(Engine.Groups, obj.Group)
      Engine.Groups[obj.Group] = {}
      InsertItem(Engine.Groups[obj.Group], obj)
    Else
      InsertItem(Engine.Groups[obj.Group], obj)
    EndIf
    
    If TB.Item.Exists(Engine.Layers[obj.Layer].SortedList, obj.y)
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    Else
      Engine.Layers[obj.Layer].SortedList[obj.y] = {}
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    EndIf

    If TB.Item.Exists(Engine.Layers[obj.Layer], "unsortedlist")
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    Else
      Engine.Layers[obj.Layer].UnsortedList = {}
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    EndIf

    If Engine.Layers[obj.Layer].FirstIndex > obj.y Then Engine.Layers[obj.Layer].FirstIndex = obj.y
    If Engine.Layers[obj.Layer].LastIndex < obj.y Then Engine.Layers[obj.Layer].LastIndex = obj.y

    obj.SortedIndex = obj.y
    obj.Engine = Engine

    ;| Durante l'inserimento verifica i layer intermedi
    For Local i = 0 To obj.Layer - 1
      If TB.Item.IsNil(Engine.Layers, i)
        Engine.Layers[i] = 
          { SortedList = {},
            FirstIndex = 0,
            LastIndex  = 0,
            UnsortedList = {} }
      EndIf
    Next

    If obj.Engine.LayerMax < obj.Layer Then obj.Engine.LayerMax = obj.Layer
    
;    InsertItem(Framework.Sprites, obj)
    InsertItem(Engine.SpriteList, obj)
  
  Return(obj)
  
EndFunction

Function GLFX.Sprite:New(engine, args)
/******************************************************************************
GLFX.Sprite:New(args)

Create a new sprite with the given args.
******************************************************************************/
  DBG.Console.Out(".Sprite:New()", DBG.OpenFunc, GLFXCh)
  
  ; POSSIBILITA' DI CREARE SPRITE VUOTI DA USARE COME BUFFER PER POTER ASSEGNARE
  ; DELLE ANIMAZIONI
  ; VEDI GLFX.ComplexSprite:Draw(offsetx, offsety)
  ; BASTA AGGIUNGERE QUALCHE PICCOLA VARIAZIONE
  If TB.Item.IsNil(args, "width") Then args.Width = 64
  If TB.Item.IsNil(args, "height") Then args.Height = 64
  If TB.Item.IsNil(args, "haveAlpha") Then args.haveAlpha = False
  If TB.Item.IsNil(args, "haveTransparency")
    args.haveTransparency = False
  Else
    args.haveAlpha = False
    If TB.Item.IsNil(args, "transparency")
      args.Transparency = $000000
    EndIf
  EndIf
  If TB.Item.IsNil(args, "bgcolor") Then args.BGColor = #WHITE

  
  args.id = GLFX.BrushID
  GLFX.BrushID = GLFX.BrushID + 1
  
  CreateBrush(args.Id, args.Width, args.Height, args.BGColor,  { AlphaChannel = args.haveAlpha, Clear = True })
  Local obj = self:NewFromBrush(args.id, engine, args)

  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
  Return(obj)
  
EndFunction

Function GLFX.Sprite:_UpdateCollisions()
/******************************************************************************
GLFX.Sprite:_UpdateCollisions()

Updates all active sprite collisions.
******************************************************************************/
  ;| For hidden and killed sprites skip collision checks
  If Not(self.IsVisible) Or self.IsKilled Then Return()

  If self.Collisions.WithMouse.Enabled
    ;##########################################################################
    ;### SPRITE-MOUSE COLLISIONS ##############################################
    ;##########################################################################
    Local CWM = self.Collisions.WithMouse

    Local w = GetAttribute(#BRUSH, self.id, #ATTRWIDTH) * self.scaleW
    Local h = GetAttribute(#BRUSH, self.id, #ATTRHEIGHT) * self.scaleH

    ; PROBLEMA -> QUESTO METODO NON CONSIDERA LA ROTAZIONE
    ; DELLO SPRITE METTERLO NELLA DOCUMENTAZIONE
    
    Local xs = self.x - w * self.anchorx
    Local ys = self.y - h * self.anchory
    Local xe = xs + w
    Local ye = ys + h
    
    ;Local poly = G2D.Poly:New({ vertices = { 0, 0, w, 0, w, h, 0, h }, x = xs, y = ys, color = { 1.0, 0, 0, 0.3 }})   
    ;poly:Draw()
    
    Local frameWork = self.Engine.Framework

    Local mx, my = MouseX()/frameWork.PixelSize[0], MouseY()/frameWork.PixelSize[1]
    
    If xs <= mx And mx <= xe
      If ys <= my And my <= ye
        ;| COLLISIONE RILEVATA
        ;| Verifica collisione dettagliata
        Local cpx = Int(mx - xs)
        Local cpy = Int(my - ys)
        
        Local cpv = 0
        If TB.Item.Exists(self.CollisionMap.Data, cpy)
          If TB.Item.Exists(self.CollisionMap.Data[cpy], cpx)
            cpv = self.CollisionMap.Data[cpy][cpx]
          EndIf
        EndIf
        
        If cpv = 1
          If CWM.Collide
            ;| There was an active collision, handle the OnCollision event
            CWM.Events.OnCollision(self, { x = cpx, y = cpy })
          Else
            ;| No previous active collision, handle the OnCollision and
            ;| OnCollisionStart events
            CWM.Events.OnCollisionStart(self, { x = cpx, y = cpy })
            CWM.Events.OnCollision(self, { x = cpx, y = cpy })
            CWM.Collide = True
          EndIf
        Else
          ;| No collisions
          If CWM.Collide      
            ;| There was a previous active collision, handle the OnCollisionEnd event.
            CWM.Events.OnCollisionEnd(self, { x = cpx, y = cpy })
            CWM.Collide = False
          EndIf          
        EndIf

      Else
        ;| No collisions
        If CWM.Collide
          ;| There was a previous active collision, handle the OnCollisionEnd event.
          CWM.Events.OnCollisionEnd(self, { x = cpx, y = cpy })
          CWM.Collide = False
        EndIf
      EndIf

    Else
      ;| No collisions
      If CWM.Collide
        ;| There was a previous active collision, handle the OnCollisionEnd event.
        CWM.Events.OnCollisionEnd(self, { x = cpx, y = cpy })
        CWM.Collide = False
        EndIf
    EndIf
  EndIf  
  

  
  
  
  If self.Collisions.WithSprites.Enabled
    ;##########################################################################
    ;### SPRITE-SPRITES COLLISIONS ############################################
    ;##########################################################################
    Local CWS = self.Collisions.WithSprites
    
    ; Aggiorna la geometria del poligono associato alle collisioni
    self:_UpdatePolyColl()
    
    ; Processa gli sprite nella lista collisioni
    Local s
    For _, s In Pairs(self.Collisions.WithSprites.SpriteList)
      If GetType(s) = #TABLE
        ; SPRITE OBJECT
        s:_UpdatePolyColl()
        
        ; Test collisioni
        If self.Collisions.WithSprites.PolyCollClone:Collide(s.Collisions.WithSprites.PolyCollClone)
          ;DebugPrint("COLLISION!! ", self, s, GetDate(True))
          ; COLLISIONE RILEVATA
          If TB.Item.IsNil(CWS.Collide, s)
            ; Inizio collisione
            CWS.Events.OnCollisionStart(self, s)
            CWS.Collide[s] = 1
          Else
            ; Collisione in corso
            CWS.Events.OnCollision(self, s)
          EndIf
        Else
          ;DebugPrint("---")
          If TB.Item.Exists(CWS.Collide, s)
            ; Fine collision
            CWS.Events.OnCollisionEnd(self, s)
            CWS.Collide[s] = Nil
          EndIf
        EndIf
        
      ElseIf GetType(s) = #STRING
        ; GROUP NAME
        If TB.Item.Exists(self.Engine.Groups, s)
          ; Il gruppo <s> essite, aggiorno le collisioni
          For gi, gs In Pairs(self.Engine.Groups[s])
            gs:_UpdatePolyColl()
            
            ; Test collisioni
            If self.Collisions.WithSprites.PolyCollClone:Collide(gs.Collisions.WithSprites.PolyCollClone)
              ;DebugPrint("COLLISION!! ", self, s, GetDate(True))
              ; COLLISIONE RILEVATA
              If TB.Item.IsNil(CWS.Collide, gs)
                ; Inizio collisione
                CWS.Events.OnCollisionStart(self, gs)
                CWS.Collide[gs] = 1
              Else
                ; Collisione in corso
                CWS.Events.OnCollision(self, gs)
              EndIf
            Else
              ;DebugPrint("---")
              If TB.Item.Exists(CWS.Collide, gs)
                ; Fine collision
                CWS.Events.OnCollisionEnd(self, gs)
                CWS.Collide[gs] = Nil
              EndIf
            EndIf
            
          Next
          
        EndIf
        
      EndIf
      
      /*
      ; Test collisioni
      If self.Collisions.WithSprites.PolyCollClone:Collide(s.Collisions.WithSprites.PolyCollClone)
        ;DebugPrint("COLLISION!! ", self, s, GetDate(True))
        ; COLLISIONE RILEVATA
        If TB.Item.IsNil(CWS.Collide, s)
          ; Inizio collisione
          CWS.Events.OnCollisionStart(self, s)
          CWS.Collide[s] = 1
        Else
          ; Collisione in corso
          CWS.Events.OnCollision(self, s)
        EndIf
      Else
        ;DebugPrint("---")
        If TB.Item.Exists(CWS.Collide, s)
          ; Fine collision
          CWS.Events.OnCollisionEnd(self, s)
          CWS.Collide[s] = Nil
        EndIf
      EndIf
    */
    Next

    Return()
    
    
    
    Local CWM = self.Collisions.WithSprites
    Local w1 = GetAttribute(#BRUSH, self.id, #ATTRWIDTH)*self.scaleW
    Local h1 = GetAttribute(#BRUSH, self.id, #ATTRHEIGHT)*self.scaleH

    Local xs1 = self.x - w*self.anchorx
    Local ys1 = self.y - h*self.anchory
    Local xe1 = xs1 + w1
    Local ye1 = ys1 + h1
    
    For i, s In IPairs(CWM.SpriteList)
      Local w2 = GetAttribute(#BRUSH, s.id, #ATTRWIDTH)*s.scaleW
      Local h2 = GetAttribute(#BRUSH, s.id, #ATTRHEIGHT)*s.scaleH

      Local xs2 = s.x - w*s.anchorx
      Local ys2 = s.y - h*s.anchory
      Local xe2 = xs + w
      Local ye2 = ys + h
      
      
      If Collision(#BOX, xs1, ys1, w1, h1, xs2, ys2, w2, h2)
      /*
        ; Overlapping box
        Local ox, oy = xs1-xs2, ys1-ys2
        Local ow, oh = 
        
          ;| COLLISION DETECTED
          If CWM.Collide[i]
            ;| Collision already active
            If TB.Item.Exists(CWM, "oncollision") Then CWM.OnCollision(self, s)
          Else
            ;| Initial collision
            If TB.Item.Exists(CWM, "oncollisionstart") Then CWM.OnCollisionStart(self, s)
            If TB.Item.Exists(CWM, "oncollision") Then CWM.OnCollision(self, s)
            CWM.Collide[i] = True
          EndIf
          
        Else
          ;| NO COLLISIONS
          If CWM.Collide[i]
            ;| Previously there was an active collision
            If TB.Item.Exists(CWM, "oncollisionend") Then CWM.OnCollisionEnd(self, s)
            CWM.Collide[i] = False
          EndIf
          */
        EndIf
    Next
    
  EndIf
  
EndFunction

Function GLFX.Sprite:_BuildCollisionMap()
/******************************************************************************
GLFX.Sprite:_BuildCollisionMap(resolution)

Build or replace an existing collision map.
---------------------------------------------------------------------
INPUT
  resolution      Resolution in pixels
NOTES
  - This method will create the table <CollisionMap> in the sprite
    structure with the following fields:
    - width           Map width
    - height          Map height
    - data            Map data with the format
                      data[r][c] where [r] = row index and
                      [c] = column index
******************************************************************************/
  Local bid = self.id
  Local bw, bh = self.width, self.height
  Local mw, mh = Int(bw*self.scaleW), Int(bh*self.scaleH)
  
  Local map = 
    { width      = mw,
      height     = mh,
      data       = {} }
      
  Local copied = CopyBrush(bid, Nil)
  If mw <> bw Or mh <> bh Then ScaleBrush(copied, mw, mh, True)
  
  For Local r = 0 To mh
    map.data[r] = {}
    For Local c = 0 To mw
      Local v, t = ReadBrushPixel(copied, c, r)
      If t > 0 Then t = 1
      map.data[r][c] = t
    Next
  Next
  FreeBrush(copied)
  
  self.CollisionMap = map
  
EndFunction

Function GLFX.Sprite:CollisionWithMouse(args)
/******************************************************************************
GLFX.Sprite:CollisionWithMouse(args)

Setup collision detection with mouse pointer for this sprite.
---------------------------------------------------------------------
INPUT
  args
    Enabled         True/False
    Events          Callback functions
      OnCollision   Raised at every check if the mouse collides with the sprite
      OnCollisionStart  Raised when the collision starts
      OnCollisionEnd    Raised when the collision ends
NOTE
  - Callback function will be called with the sprite object as single parameter.
  - Pass <args> = Nil to remove the collision detection.
******************************************************************************/
  
  If IsNil(args)
    self.Collisions.WithMouse =
      { Enabled = False,
        Collide = False,
        Events = 
          { OnCollision = Function() EndFunction,
            OnCollisionStart = Function() EndFunction,
            OnCollisionEnd = Function() EndFunction 
            }
        }
  Else
    If TB.Item.IsNil(args, "resolution") Then args.Resolution = 1
    self:_BuildCollisionMap(args.Resolution)
    Local cwm = self.Collisions.WithMouse
    If TB.Item.Exists(args, "enabled") Then cwm.Enabled = True
    If TB.Item.Exists(args, "events")
      If TB.Item.Exists(args.events, "oncollision") Then cwm.Events.OnCollision = args.Events.OnCollision
      If TB.Item.Exists(args.events, "oncollisionstart") Then cwm.Events.OnCollisionStart = args.Events.OnCollisionStart
      If TB.Item.Exists(args.events, "oncollisionend") Then cwm.Events.OnCollisionEnd = args.Events.OnCollisionEnd
    EndIf
    self.Collisions.WithMouse.Collide = False
  EndIf
  
EndFunction

Function GLFX.Sprite:Draw()
/******************************************************************************
GLFX.Sprite:Draw()

Render the sprite
******************************************************************************/
  If self.isParticle Or 
     self.IsParallax
    Return()
  EndIf
  
  ;--- Animations ---
  self:_UpdateAnimation()
  
  ;--- Collisions ---
  self:_UpdateCollisions()
  
  ;--- Forced y sorted ? ---
  If self.Engine.YSortForced
    self:_Reorder()
  EndIf
  
  ;--- Check Boundaries ---
  If HaveItem(self, "boundaries")
    If HaveItem(self.Boundaries, "top")
      If self.y < self.boundaries.top Then self.y = self.boundaries.top
    EndIf
    If HaveItem(self.Boundaries, "bottom")
      If self.y > self.boundaries.bottom Then self.y = self.boundaries.bottom
    EndIf
    If HaveItem(self.Boundaries, "left")
      If self.x < self.boundaries.left Then self.x = self.boundaries.left
    EndIf
    If HaveItem(self.Boundaries, "right")
      If self.x > self.boundaries.right Then self.x = self.boundaries.right
    EndIf
  EndIf
  
  ;--- Lock Inside ---
  If self.lockInside
    Local realXS = self.x-self.AnchorX*self.width
    Local realYS = self.y-self.AnchorY*self.height
    Local realXE = realXS+self.width
    Local realYE = realYS+self.height
    Local deltaX, deltaY = 0, 0
    If realXE < self.Engine.Framework.Width Then deltaX = self.Engine.Framework.Width - realXE
    If realYE < self.Engine.Framework.Height Then deltaY = self.Engine.Framework.Height - realYE
    If realXS > 0 Then deltaX = -realXS
    If realYS > 0 Then deltaY = -realYS
    self.x = self.x + deltaX
    self.y = self.y + deltaY
  EndIf
  
  ;DebugPrint("--- ATTENZIONE : Sprite:Draw() => MANCA GESTIONE DELLE ANIMAZIONI")

  If self.id <> -1
    gl.Enable(#GL_TEXTURE_2D)
    If GLFX.LastTexture <> self.id
      gl.BindTexture(#GL_TEXTURE_2D, self.id)
      GLFX.LastTexture = self.id
    EndIf
  Else
    gl.Disable(#GL_TEXTURE_2D)
  EndIf
  
  If self.blendEnabled
    gl.Enable(#GL_BLEND)
    If self.blendSrc <> self.engine.framework.GL_blendSrc Or
       self.blendDst <> self.engine.framework.GL_blendDst
      gl.BlendFunc(self.blendSrc, self.blendDst)
      self.engine.framework.GL_blendSrc = self.blendSrc
      self.engine.framework.GL_blendDst = self.blendDst
    EndIf
  Else
    gl.Disable(#GL_BLEND)
  EndIf

  Local needToPushPop = False
  If self.angleEnabled
    needToPushPop = True
  EndIf
  
  If needToPushPop Then gl.PushMatrix()

  Local w  = self.width  * self.scaleW
  Local h  = self.height * self.scaleH
  Local ox = self.anchorX * w
  Local oy = self.anchorY * h
  Local x  = self.x - ox
  Local y  = self.y - oy  

  If self.angleEnabled
    ; Ma l'angolo non gira sull'anchor point?
    gl.Translate(self.x, self.y, 0)
    gl.Rotate(self.angle, 0, 0, 1)
    gl.Translate(-self.x, -self.y, 0)
  EndIf
  
  Local xw, yh = x+w, y+h
  gl.Begin(#GL_QUADS)
    gl.Color(self.Color[0], self.Color[1], self.Color[2], self.Color[3])
    gl.TexCoord(self.texMapping[0], self.texMapping[1])
    gl.Vertex(x, y)
    gl.TexCoord(self.texMapping[2], self.texMapping[3])
    gl.Vertex(xw, y)
    gl.TexCoord(self.texMapping[4], self.texMapping[5])
    gl.Vertex(xw, yh)
    gl.TexCoord(self.texMapping[6], self.texMapping[7])
    gl.Vertex(x, yh)
  gl.End
    
  If self.IsParallaxMaster
    ; La strip è memorizzata in una DisplayList con un solo
    ; quad e texture ripetuta.   
    gl.PushMatrix()   
    If self.IsHorizontal
      gl.Translate(self.x+self.width*self.scaleW, self.y, 0)
    Else
      gl.Translate(self.x, self.y+self.height*self.scaleH, 0)
    EndIf
    gl.CallList(self._ParallaxSprites)
    ; gl.PopMatrix() <-- E' incluso nella DisplayList
  EndIf
  
  If self.Collisions.WithSprites.Enabled
    If self.Collisions.WithSprites.PolyRender
      gl.Disable(#GL_TEXTURE_2D)
      gl.Color(self.polyColor)
      
      If self.angleEnabled
        gl.Translate(self.x, self.y, 0)
        gl.Rotate(-self.angle, 0, 0, 1)
        gl.Translate(-self.x, -self.y, 0)
      EndIf
      
      Local cloned = self.Collisions.WithSprites.PolyCollClone
      gl.Begin(#GL_POLYGON)
        For Local i = 0 To ListItems(cloned.Vertices)-1 Step 2
          gl.Vertex(cloned.Vertices[i], cloned.Vertices[i+1])
        Next
      gl.End
    EndIf
  EndIf

  If needToPushPop Then gl.PopMatrix()

  If blendEnabled Then gl.Disable(#GL_BLEND)
  
EndFunction

Function GLFX._TexInit(brushID, force)
/******************************************************************************
GLFX._TextInit(brushID)

INTERNAL function called to initialize a texture
******************************************************************************/
  ;DebugPrint("INIT BRUSH ", brushid)
  If IsNil(force) Then force = False
  
  If (brushID <> -1 And brushID <> GLFX.GL_lastTexInit) Or force
    gl.Enable(#GL_TEXTURE_2D)
    gl.BindTexture(#GL_TEXTURE_2D, brushID)
    GLFX.LastTexture = brushID

    gl.TexImageFromBrush(0, brushID)

    gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_MIN_FILTER, #GL_LINEAR)
    gl.TexParameter(#GL_TEXTURE_2D, #GL_TEXTURE_MAG_FILTER, #GL_LINEAR)

    ;gl.Enable(#GL_TEXTURE_2D)
    
    GLFX.GL_lastTexInit = brushID
  EndIf
  
EndFunction

Function GLFX:Reshape(msg)
/******************************************************************************
GLFX:Reshape()

INTERNAL func used when the window is resized.
******************************************************************************/
  DBG.Console.Out(":Reshape()", DBG.OpenFunc, GLFXCh)
  
  Local width, height
  If IsNil(msg)
    width = self.width
    height = self.height
    DBG.Console.Out("New window size : " .. width .. "x" .. height, Nil, GLFXCh)
  Else
    width  = msg.width
    height = msg.height
    self.PixelSize = { width/self.width, height/self.height }
    DBG.Console.Out("New window size : " .. width .. "x" .. height, Nil, GLFXCh)
    DBG.Console.Out("Pixel Sizes : " .. self.PixelSize[0] .. ", " .. self.PixelSize[1] )
  EndIf

  self.ScreenRatio = width/height
  DBG.Console.Out("New screen ratio : " .. self.ScreenRatio, Nil, GLFXCh)
      
 
  
  gl.SetCurrentContext(self.Display)    
	gl.MatrixMode(#GL_PROJECTION)
	gl.LoadIdentity()
	glu.Perspective(170.0, self.ScreenRatio, 1.0, 100.0)

	gl.MatrixMode(#GL_MODELVIEW)
	gl.Viewport(0, 0, width, height)
	gl.ClearColor(self.ClearColor[0], self.ClearColor[1], self.ClearColor[2], self.ClearColor[3])
	gl.ClearDepth(1.0)
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX.Sprite.SetCollisions(SpriteList, WithMouse) ; 04/2021
/******************************************************************************
GLFX.Sprite.SetCollisions(SpriteList, WithMouse)

Enable or disable collisions for a list of sprites.
-------------------------------------------------------------------------------
INPUT
  SpriteList : A list of sprite objects we want to change the collision state
  WithMouse : TRUE or FALSE to enable or disable the collision between the
              sprite and the mouse pointer.
******************************************************************************/
  DBG.Console.Out(".Sprite.SetCollisions()", DBG.OpenFunc, GLFXCh)
  
  Local i, v
  For i, v In Pairs(SpriteList)
    v.Collisions.WithMouse.Enabled = WithMouse

  Next
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX.Sprite:Resize(width, height, keepAspect)
/******************************************************************************
GLFX.Sprite:Resize(width, Height, keepAspect)

Resizes a sprite.
******************************************************************************/
  DBG.Console.Out("GLFX.Sprite:Resize() -> " .. ToString(self.id), DBG.OpenFunc, GLFXCh)
  DBG.Console.Out("Target size : " .. ToString(width) .. "x" .. ToString(height) .. ", aspect:" .. ToString(keepAspect), Nil, GLFXCh)
  
  ;DBG.Console.Out("Original Size : ")

  If keepAspect
    If Not(IsNil(width))
      self.scaleW = width/GetAttribute(#BRUSH, self.id, #ATTRWIDTH)
      self.scaleH = self.scaleW
    ElseIf Not(IsNil(height))
      self.scaleH = height/GetAttribute(#BRUSH, self.id, #ATTRHEIGHT)
      self.scaleW = self.scaleH
    EndIf
  Else
    self.scaleW = width/GetAttribute(#BRUSH, self.id, #ATTRWIDTH)
    self.scaleH = height/GetAttribute(#BRUSH, self.id, #ATTRHEIGHT)
  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
EndFunction

Function GLFX.Sprite:ParallaxCreate(args)
/******************************************************************************
GLFX.Sprite:ParallaxCreate(args)

Make, from the current sprite, a parallax effect.
---------------------------------------------------------------------
INPUT
  args      Table to define the parallax
    horizontal      TRUE for horizontal scrolling, FALSE for vertical
    position        y position if Horizontal, x position if vertical
    stride          Scrolling step at each update
    single          TRUE for a single instance or FALSE to create a strip
    ratems          Update frequency in milliseconds
NOTES
  Data is accessible from the source sprite object in the following fields:
    ._sourceWidth or sourceHeight     Strip width or height in pixels
    ._neededClones                    How many strips are used
    ._parallaxSprites                 List of sprites used for the effect
    ._stride                          Scrolling step (updatable)
    ._rateMS                          Update frequency (read only)
    ._prevTime                        Used for delta time computing
  You can use resized sprites as well.
  Source position is linked to the parallax clones, moving the source sprite
  will move also all the clones involved in the effect.
******************************************************************************/
  ; Default values
  Local params = 
    { horizontal = True,
      position   = 100,
      stride     = 1,
      ratems     = 20,
      OnParallaxReset = Function() EndFunction,
      single     = False
      }
  
  ; Override default values
  TB.Set(params, args, False)

  self.OnParallaxReset = params.OnParallaxReset
  
  ; Setup the effect
  If params.horizontal
    ; HORIZONTAL PARALLAX
    self.y                = params.position
    self:_Reorder()
    ;self.x                = 0
    self.anchorX = 0
    self.anchorY = 0
    
    self._sourceWidth     = GetAttribute(#BRUSH, self.id, #ATTRWIDTH) * self.scaleW
    self._neededClones    = self.Engine.Framework.Width/self._sourceWidth   
    self._neededClones    = Round(self._neededClones+0.5)
    self._parallaxSprites = {}
    self._stride          = params.stride
    self._ratems          = params.ratems
    self._prevTime        = GetTimer(self.Engine.Framework.TimerID)
    
    self.isParallaxMaster = True

    ; Creat, self.anchorYe the needed clones
    If Not(params.single)
      ; Per realizzare una strip utilizzo un quad con la texture (brush)
      ; ripetuto più volte.
      Local DisplayList = gl.GenLists(1)
      self._parallaxSprites = DisplayList  
      gl.NewList(DisplayList, #GL_COMPILE)
        gl.Begin(#GL_QUADS)
          gl.Color(self.Color[0], self.Color[1], self.Color[2], self.Color[3])
          Local px, py, pw, ph = 0, 0, self.width*self.scaleW, self.height*self.scaleH
            Local pxw, pyh = px+pw, py+ph    
            pxw = pw*self._neededClones
            gl.TexCoord(self.texMapping[0]*self._neededClones, self.texMapping[1])
            gl.Vertex(px, py)
            gl.TexCoord(self.texMapping[2]*self._neededClones, self.texMapping[3])
            gl.Vertex(pxw, py)
            gl.TexCoord(self.texMapping[4]*self._neededClones, self.texMapping[5])
            gl.Vertex(pxw, pyh)
            gl.TexCoord(self.texMapping[6]*self._neededClones, self.texMapping[7])
            gl.Vertex(px, pyh)
        gl.End
        gl.PopMatrix()
      gl.EndList
    EndIf
    
    ; Use the actions system to setup the animation
    self:ActionAdd(
      { name  = "parallax_mover",
        atype = #SE_ATYPE_INTERVAL,
        func  = Function(msg)
                  ; Setup some variables and compute the delta time
                  Local sprite1 = msg.userdata.sprite
                  Local t2      = GetTimer(sprite1.Engine.Framework.TimerID)
                  Local t1      = sprite1._prevTime
                  Local delta   = t2-t1

                  sprite1._prevTime = t2
                  Local multiplier = delta/sprite1._rateMS
                  Local stride     = sprite1._stride * multiplier
                  
                  ; Update the source sprite and the clones
                  sprite1.x = sprite1.x - stride

                  If sprite1.x < -sprite1._sourceWidth
                    ; Reset
                    sprite1.x = sprite1.x + sprite1._sourceWidth
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })                    
                  ElseIf sprite1.x > 0
                    ; Reset
                    sprite1.x = sprite1.x - sprite1._sourceWidth
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })                    
                  EndIf
                EndFunction,
        args  = params.rateMS
        })
    
  Else
    ; VERTICAL PARALLAX
    self.x                = params.position
    
    ;self.y                = 0
    self.anchorY = 0
    self.anchorX = 0
    
    self._sourceHeight    = GetAttribute(#BRUSH, self.id, #ATTRHEIGHT) * self.scaleH
    self._neededClones    = self.Engine.Framework.Height/self._sourceHeight
    self._neededClones    = Round(self._neededClones+0.5)
    self._parallaxSprites = {}
    self._stride          = params.stride
    self._ratems          = params.ratems
    self._prevTime        = GetTimer(self.Engine.Framework.TimerID)
    
    self.isParallaxMaster = True
    
    ; Create the needed clones
    If not(params.single)
      ; Per realizzare una strip utilizzo un quad con la texture (brush)
      ; ripetuto più volte.
      Local DisplayList = gl.GenLists(1)
      self._parallaxSprites = DisplayList  
      gl.NewList(DisplayList, #GL_COMPILE)
        gl.Begin(#GL_QUADS)
          gl.Color(self.Color[0], self.Color[1], self.Color[2], self.Color[3])
          Local px, py, pw, ph = 0, 0, self.width*self.scaleW, self.height*self.scaleH
            Local pxw, pyh = px+pw, py+ph    
            pyh = ph*self._neededClones
            gl.TexCoord(self.texMapping[0], self.texMapping[1]*self._neededClones)
            gl.Vertex(px, py)
            gl.TexCoord(self.texMapping[2], self.texMapping[3]*self._neededClones)
            gl.Vertex(pxw, py)
            gl.TexCoord(self.texMapping[4], self.texMapping[5]*self._neededClones)
            gl.Vertex(pxw, pyh)
            gl.TexCoord(self.texMapping[6], self.texMapping[7]*self._neededClones)
            gl.Vertex(px, pyh)
        gl.End
        gl.PopMatrix()
      gl.EndList

    EndIf
    
    ; Use the actions system to setup the animation
    self:ActionAdd(
      { name  = "parallax_mover",
        atype = #SE_ATYPE_INTERVAL,
        func  = Function(msg)
                  ; Setup some variables and compute the delta time
                  Local sprite1 = msg.userdata.sprite
                  Local t2      = GetTimer(sprite1.Engine.Framework.TimerID)
                  Local t1      = sprite1._prevTime
                  Local delta   = t2-t1
                  
                  sprite1._prevTime = t2
                  Local multiplier = delta/sprite1._rateMS
                  Local stride     = sprite1._stride * multiplier
                  
                  ; Update the source sprite and the clones
                  sprite1.y = sprite1.y - stride
                  If sprite1.y < -sprite1._sourceHeight
                    ; Reset
                    sprite1.y = sprite1.y + sprite1._sourceHeight
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })                    
                    ;For nc = 0 To sprite1._neededClones-1 Do sprite1._parallaxSprites[nc].y = sprite1.y + self._sourceHeight * (nc + 1)
                  ElseIf sprite1.y > 0
                    ; Reset
                    sprite1.y = sprite1.y - sprite1._sourceHeight
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })                    
                    ;For nc = 0 To sprite1._neededClones-1 Do sprite1._parallaxSprites[nc].y = sprite1.y + self._sourceHeight * (nc + 1)
                  Else
                    ; Scroll
                    /*
                    For nc = 0 To sprite1._neededClones-1
                      Local sprite2 = sprite1._parallaxSprites[nc]                   
                      sprite2.y = sprite2.y - stride
                      sprite2.x = sprite1.x
                    Next */
                  EndIf
                EndFunction,
        args  = params.rateMS
        })

  EndIf

  self.IsHorizontal = params.horizontal
  
EndFunction

Function GLFX.Sprite:ParallaxItem(args)
/******************************************************************************
GLFX.Sprite:ParallaxItem(args)

Make, from the current sprite, a parallax item.
---------------------------------------------------------------------
INPUT
  args      Table to define the parallax
    horizontal      TRUE for horizontal scrolling, FALSE for vertical
    position        y position if Horizontal, x position if vertical
    stride          Scrolling step at each update
    ?? single          TRUE for a single instance or FALSE to create a strip
    ratems          Update frequency in milliseconds
NOTES
  Data is accessible from the source sprite object in the following fields:
    ._sourceWidth or sourceHeight     Strip width or height in pixels
    ._stride                          Scrolling step (updatable)
    ._rateMS                          Update frequency (read only)
    ._prevTime                        Used for delta time computing
  You can use resized sprites as well.
  Source position is linked to the parallax clones, moving the source sprite
  will move also all the clones involved in the effect.
******************************************************************************/
  ; Default values
  Local params = 
    { horizontal = True,
      position   = 100,
      stride     = 1,
      ratems     = 20,
      OnParallaxReset = Function() EndFunction,
      single     = False ; ??
      }
  
  ; Override default values
  TB.Set(params, args, False)
  
  self.OnParallaxReset = params.OnParallaxReset
  
  ; Setup the effect
  If params.horizontal
    ; HORIZONTAL PARALLAX
    self.y                = params.position
    self:_Reorder()
    self.anchorX          = 0
    
    self._sourceWidth     = GetAttribute(#BRUSH, self.id, #ATTRWIDTH) * self.scaleW
    self._stride          = params.stride
    self._ratems          = params.ratems
    self._prevTime        = GetTimer(self.Engine.Framework.TimerID)
    
    ; Use the actions system to setup the animation
    self:ActionAdd(
      { name  = "parallaxitem_mover",
        atype = #SE_ATYPE_INTERVAL,
        func  = Function(msg)
                  ; Setup some variables and compute the delta time
                  Local sprite1 = msg.userdata.sprite
                  Local t2      = GetTimer(sprite1.Engine.Framework.TimerID)
                  Local t1      = sprite1._prevTime
                  Local delta   = t2-t1
                  
                  sprite1._prevTime = t2
                  Local multiplier = delta/sprite1._rateMS
                  Local stride     = sprite1._stride * multiplier
                  
                  ; Update the source sprite and the clones
                  sprite1.x = sprite1.x - stride
                  If sprite1.x < -sprite1._sourceWidth
                    ; Reset
                    sprite1.x = sprite1.x + sprite1.engine.framework.width + sprite1._sourceWidth
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })
                  ElseIf sprite1.x > sprite1.engine.framework.width
                    ; Reset
                    sprite1.x = sprite1.x - sprite1.engine.framework.width - sprite1._sourceWidth
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })                    
                  EndIf
                EndFunction,
        args  = params.rateMS
        })
    
  Else
    ; VERTICAL PARALLAX
    self.y                = params.position
    self.anchorY          = 0
    
    self._sourceHeight    = GetAttribute(#BRUSH, self.id, #ATTRHEIGHT) * self.scaleH
    self._stride          = params.stride
    self._ratems          = params.ratems
    self._prevTime        = GetTimer(self.Engine.Framework.TimerID)
    
    ; Use the actions system to setup the animation
    self:ActionAdd(
      { name  = "parallax_mover",
        atype = #SE_ATYPE_INTERVAL,
        func  = Function(msg)
                  ; Setup some variables and compute the delta time
                  Local sprite1 = msg.userdata.sprite
                  Local t2      = GetTimer(sprite1.Engine.Framework.TimerID)
                  Local t1      = sprite1._prevTime
                  Local delta   = t2-t1
                  
                  sprite1._prevTime = t2
                  Local multiplier = delta/sprite1._rateMS
                  Local stride     = sprite1._stride * multiplier
                  
                  ; Update the source sprite and the clones
                  sprite1.y = sprite1.y - stride
                  If sprite1.y < -sprite1._sourceHeight
                    ; Reset
                    sprite1.y = sprite1.y + sprite1.engine.framework.height + sprite1._sourceHeight
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })
                  ElseIf sprite1.y > sprite1.engine.framework.height
                    ; Reset
                    sprite1.y = sprite1.y - sprite1.engine.framework.height - sprite1._sourceHeight
                    sprite1.OnParallaxReset({ event      = "OnParallaxReset",
                                              objectType = "Sprite",
                                              object     = sprite1 })
                  EndIf
                EndFunction,
        args  = params.rateMS
        })

  EndIf

EndFunction

Function GLFX.Sprite:SetAtlas(framesDef)
/******************************************************************************
GLFX.Sprite:SetAtlas(frameDef)

Set this sprite as a GL Atlas so you can use it later to extract frames for
other sprites.
frameDef is used to define how the single cells are arranged into the Atlas.
---------------------------------------------------------------------
INPUT
  frameDef      A table made of subtables indexed by numbers or frame names
                with the following fields:
                  x, y    Top-right coordinates
                  w, h    Width and Height in pixels
******************************************************************************/
  DBG.Console.Out(".Sprite:SetAtlas()", DBG.OpenFunc, GLFXCh)

  self.IsAtlas = True
  self.AtlasMap = {}

  ; Store the frames using the half-pixel correction algorhythm
  For i, v In Pairs(framesDef)
    self.AtlasMap[i] =
      { x = (v.x + 0.5)/self.Width,
        y = 1-(v.y + 0.5)/self.Height,
        w = v.w/self.Width,
        h = v.h/self.Height }
  Next
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
EndFunction

Function GLFX.Sprite:Load(brushFile, engine, args)
/******************************************************************************
result = GLFX.Sprite:Load(brushFile, engine, args)

Load a brush ready to be used by the GLFX system.
---------------------------------------------------------------------
INPUT
  brushFile     File name to load or an Atlas frame, you can address Atlas
                passing a table with the following fields:
                AtlasSprite : AtlasSprite object
                FrameIndex : Frame index as you have defined with :SetAtlas()
                method.
                
  args          Arguments table, same as the LoadBrush command but with these
                additional fields:
                  name      User defined name
                  layer     User defined layer (default 0)
                  order     User defined draw order (default 0)
OUTPUT
  result        True : load ok, False : load failed
******************************************************************************/
  ;DBG.Console.Out("GLFX.Sprite:Load()", DBG.OpenFunc, GLFXCh)

  Local obj = CopyTable(self)
  
  TB.Set(obj, args, False)
  
  If GetType(brushFile) = #TABLE
    ;DBG.Console.Out("Addressing an Atlas frame...", Nil, GLFXCh)
    obj.UseAtlas = True
    obj.Atlas = brushFile.AtlasSprite
    obj.AtlasIndex = brushFile.FrameIndex
    
    obj.width            = obj.Atlas.Width * obj.Atlas.AtlasMap[obj.AtlasIndex].w
    obj.height           = obj.Atlas.Height * obj.Atlas.AtlasMap[obj.AtlasIndex].h
    obj.haveAlpha        = obj.Atlas.haveAlpha
    obj.isVector         = obj.Atlas.isVector
    obj.haveTransparency = obj.Atlas.haveTransparency
    obj.file             = ""
    obj.engine           = engine
    
    obj.id = obj.Atlas.id
    obj.brush_id = obj.Atlas.id
    
    Local map = obj.Atlas.AtlasMap[obj.AtlasIndex]
    obj.texMapping = 
      { map.x, map.y,
        map.x + map.w, map.y,
        map.x + map.w, map.y - map.h,
        map.x, map.y - map.h }
    
    ; Save the sprite in the spriteEngine spritelist
    If TB.Item.IsNil(Engine.Layers, obj.Layer)
      Engine.Layers[obj.Layer] = 
        { SortedList = {},
          UnsortedList = {},
          FirstIndex = 0,
          LastIndex  = 0 }
    EndIf
    
    ; Group
    If TB.Item.IsNil(Engine.Groups, obj.Group)
      Engine.Groups[obj.Group] = {}
      InsertItem(Engine.Groups[obj.Group], obj)
    Else
      InsertItem(Engine.Groups[obj.Group], obj)
    EndIf
    
    If TB.Item.Exists(Engine.Layers[obj.Layer].SortedList, obj.y)
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    Else
      Engine.Layers[obj.Layer].SortedList[obj.y] = {}
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    EndIf

    If TB.Item.Exists(Engine.Layers[obj.Layer], "unsortedlist")
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    Else
      Engine.Layers[obj.Layer].UnsortedList = {}
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    EndIf

    If Engine.Layers[obj.Layer].FirstIndex > obj.y Then Engine.Layers[obj.Layer].FirstIndex = obj.y
    If Engine.Layers[obj.Layer].LastIndex < obj.y Then Engine.Layers[obj.Layer].LastIndex = obj.y

    obj.SortedIndex = obj.y
    obj.Engine = Engine

    ;| Durante l'inserimento verifica i layer intermedi
    For Local i = 0 To obj.Layer - 1
      If TB.Item.IsNil(Engine.Layers, i)
        Engine.Layers[i] = 
          { SortedList = {},
            FirstIndex = 0,
            LastIndex  = 0,
            UnsortedList = {} }
      EndIf
    Next

    If obj.Engine.LayerMax < obj.Layer Then obj.Engine.LayerMax = obj.Layer
    
;    InsertItem(Framework.Sprites, obj)
    InsertItem(Engine.SpriteList, obj)
    
    ;DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
    Return(obj)
    
  EndIf
  
  ; Caricamento sprite da file, normale
  
  Local result, infos = IsPicture(brushFile)
  
  If result
    obj.width            = infos.width
    obj.height           = infos.height
    obj.haveAlpha        = infos.alpha
    obj.isVector         = infos.vector
    obj.haveTransparency = infos.transparency
    obj.file             = brushFile
    obj.engine           = engine
    
    Local loadArgs = {}
    If obj.haveAlpha
      DBG.Console.Out("Detected Alpha Channel.", Nil, GLFXCh)
      loadArgs.LoadAlpha = True
    ElseIf obj.haveTransparency
      DBG.Console.Out("Detected Transparency.", Nil, GLFXCh)
      loadArgs.LoadTransparency = True
    ElseIf obj.transparency <> -1
      DBG.Console.Out("Detected Transparency Color : " .. ToString(obj.Transparency), Nil, GLFXCh)
      loadArgs.Transparency = obj.transparency
    EndIf
    
    Local Framework = Engine.Framework

    DBG.Console.Out("Loading brush : " .. brushFile .. ", id = " .. ToString(GLFX.BrushID), Nil, GLFXCh)
    obj.id = GLFX.BrushID
    
    LoadBrush(obj.id, obj.file, loadArgs)
    
    ; verifica se il sistema necessita del PowerOfTwo
    If engine.Framework.PowerOfTwo
      ; Verifica se le dimensioni sono PowerOfTwo
      Local wl = GLFX.GetNearestPowerOfTwo(obj.Width)
      Local hl = GLFX.GetNearestPowerOfTwo(obj.Height)

      ; wl e hl sono le dimensioni del brush da trasformare
      ; in texture affinchè venga visualizzata correttamente.
      Local ratioW = obj.Width / wl
      Local ratioH = obj.Height / hl
      DebugPrint("RW, RH : " .. ratioW .. ", " .. ratioH)
      If ratioW > ratioH
        ScaleBrush(obj.id, wl, #KEEPASPRAT, True)
      Else
        ScaleBrush(obj.id, #KEEPASPRAT, hl, True)
      EndIf

      ; Creo un brush delle dimensioni della texture e ci stampo sopra
      ; il brush ridimensionato
      Local tmpID = GLFX.BrushID + 1
      CreateBrush(tmpID, wl, hl, #RED, { AlphaChannel = obj.HaveAlpha, Clear = True })
      SelectBrush(tmpID, #SELMODE_COMBO, 2)
        DisplayBrush(obj.id, 0, 0)
      EndSelect

      ; Libero e sostituisco il brush caricato originale
      FreeBrush(obj.id)
      obj.id = tmpID
      obj.Width = wl
      Obj.Height = hl
      
      GLFX.BrushID = GLFX.BrushID + 1
      
    EndIf
    
    GLFX._TexInit(obj.id)
    GLFX.BrushID = GLFX.BrushID + 1

    ; Save the sprite in the spriteEngine spritelist
    If TB.Item.IsNil(Engine.Layers, obj.Layer)
      Engine.Layers[obj.Layer] = 
        { SortedList = {},
          UnsortedList = {},
          FirstIndex = 0,
          LastIndex  = 0 }
    EndIf

    ; Group
    If TB.Item.IsNil(Engine.Groups, obj.Group)
      Engine.Groups[obj.Group] = {}
      InsertItem(Engine.Groups[obj.Group], obj)
    Else
      InsertItem(Engine.Groups[obj.Group], obj)
    EndIf
    
    If TB.Item.Exists(Engine.Layers[obj.Layer].SortedList, obj.y)
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    Else
      Engine.Layers[obj.Layer].SortedList[obj.y] = {}
      InsertItem(Engine.Layers[obj.Layer].SortedList[obj.y], obj)
    EndIf

    If TB.Item.Exists(Engine.Layers[obj.Layer], "unsortedlist")
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    Else
      Engine.Layers[obj.Layer].UnsortedList = {}
      InsertItem(Engine.Layers[obj.Layer].UnsortedList, obj)
    EndIf

    If Engine.Layers[obj.Layer].FirstIndex > obj.y Then Engine.Layers[obj.Layer].FirstIndex = obj.y
    If Engine.Layers[obj.Layer].LastIndex < obj.y Then Engine.Layers[obj.Layer].LastIndex = obj.y

    obj.SortedIndex = obj.y
    obj.Engine = Engine

    ;| Durante l'inserimento verifica i layer intermedi
    For Local i = 0 To obj.Layer - 1
      If TB.Item.IsNil(Engine.Layers, i)
        Engine.Layers[i] = 
          { SortedList = {},
            FirstIndex = 0,
            LastIndex  = 0,
            UnsortedList = {} }
      EndIf
    Next

    If obj.Engine.LayerMax < obj.Layer Then obj.Engine.LayerMax = obj.Layer
    
;    InsertItem(Framework.Sprites, obj)
    InsertItem(Engine.SpriteList, obj)
    
    ;DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
    Return(obj)
  
  Else
    DBG.Console.Out("Unrecognized image format -> " .. brushFile, DBG.Warning, GLFXCh)
  EndIf
  
  ;DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  Return(Nil)
    
EndFunction

Function GLFX.Sprite:NewFromText(engine, args)
/******************************************************************************
sprite = GLFX.Sprite:CreateFromText(engine, args)
---------------------------------------------------------------------
INPUT
  Engine         Sprite engine to use
  Args
    -- same as newFromBrush --
    text         source text
    textAttrs    text attributes
    splitted     create a single sprite or a sprite for character
    tfontname    font name
    tfontsize    font size
    tencoding    text encoding
    fengine      font engine
    tstyle       text style
    tcolor       text color (RGB)
    align_x, align_y  Text alignment inside the sprite
    textrawidth
    textraheight
OUTPUT
  sprite          Sprite object or a list of sprites
******************************************************************************/
  If TB.Item.IsNil(args, "align_x") Then args.Align_x = #CENTER
  If TB.Item.IsNil(args, "align_y") Then args.Align_y = #CENTER
  
  ;| Open the specified font
  Local fEngine = #FONTENGINE_INBUILT
  If TB.Item.Exists(args, "fengine") Then fEngine = args.fEngine
  OpenFont(999, args.tfontname, args.tfontsize, { Engine = fEngine })
  UseFont(999)

  ;| Apply styles and color
  SetFontColor(args.tcolor)
  SetFontStyle(args.tstyle)

  ;| Calcola le dimensioni del testo e crea un brush adeguato dove sarà
  ;| renderizzato il testo
  If TB.Item.Exists(args, "encoding")
    args.TextAttrs.Encoding = Args.fEncoding
  EndIf

  If Not(args.splitted)
    Local w, h = GFX.Text.GetWidth(args.text) + args.textrawidth, TextHeight(args.text) + args.textraheight
    ;| Verifica se dobbiamo usare PowerOfTwo per le dimensioni
    Local cdelta_x, cdelta_y = 0, 0

    ;==================================================================
    If engine.Framework.PowerOfTwo
      ;| La texture potrebbe essere più grande di quanto necessitiamo
      ;| per cui la centratura dovrà essere ricalcolata per la differenza.
      w1 = GLFX.GetNearestPowerOfTwo(w)
      h1 = GLFX.GetNearestPowerOfTwo(h)
      cdelta_x = w1-w
      cdelta_y = h1-h
      w, h = w1, h1
    EndIf
    ;==================================================================
    
    Local bid = GLFX.BrushID
    CreateBrush(bid, w, h, #RED, { AlphaChannel = True, Clear = True })
    GLFX.BrushID = GLFX.BrushID + 1
    SelectBrush(bid, #SELMODE_COMBO)
      TextOut(args.Align_x, args.Align_y-cdelta_y/2, args.text, args.textattrs)
    EndSelect
    CloseFont(999)
    ;| Crea lo sprite usando come sorgente il brush generato
    Local sob = GLFX.Sprite:NewFromBrush(bid, engine, args)

    ;| Inserisce manualmente il brush nella lista delle risorse che dovranno
    ;| essere liberate in caso di :Free()
    Engine.Brushes[sob.ID] = 1
    sob.file = "*TEXTBRUSH*"
    sob.textArgs = args
    sob.textArgs.cDelta_y = cDelta_y
    
    ; Metodo :setText(text)
    Function sob:setText(text)
      Local args = self.textArgs
      If Not(args.splitted)
        ;FreeBrush(sob.Brush_ID)
        ;self.Engine.Brushes[self.ID] = Nil
        If TB.Item.Exists(args, "fengine") Then fEngine = args.fEngine

        OpenFont(999, args.tfontname, args.tfontsize, { Engine = fEngine })
        UseFont(999)
        SetFontColor(args.tcolor)
        SetFontStyle(args.tstyle)

        Local w, h = self.width, self.height
        Local bid = self.id
        ;DebugPrint("Creatng brush ", bid, self.id, w, h)
        ;FreeBrush(bid)
        CreateBrush(bid, w, h, #RED, { AlphaChannel = True, Clear = True })
        ;GLFX.BrushID = GLFX.BrushID + 1
        ;SetFillStyle(#FILLCOLOR)
        
        SelectBrush(bid, #SELMODE_COMBO)
        ;Box(Rnd(50), 0, Rnd(100)+50, Rnd(100)+50, ARGB($00, GetRandomColor()))
          TextOut(args.Align_x, args.Align_y-args.cDelta_y/2, text, args.textattrs)
        EndSelect
        CloseFont(999)
        GLFX._texInit(bid, True)
      EndIf
    EndFunction
    
    ;| Restituisce l'oggetto creato
    Return(sob)
    
  Else
    Local spriteList, text = {}, args.text
    args.splitted = False
    For Local i = 0 To StrLen(text)-1
      Local c = MidStr(text, i, 1)
      args.text = c
      Local sprite = GLFX.Sprite:NewFromText(engine, args)
      InsertItem(spriteList, sprite)
    Next
    Return(spriteList)
  EndIf
EndFunction

Function GLFX.Sprite:Translate(x, y)
/******************************************************************************
GLFX.Sprite:Translate(x, y)

Translate the sprite to the given offsets
******************************************************************************/
  self.x = self.x + x
  self.y = self.y + y

  ;If self.Type = #BACKGROUND Then self:Move(self.x, self.y)
  
  If self.Engine.YSorted
    If self.SortedIndex <> y Then self:_Reorder()
  EndIf
EndFunction

Function GLFX.Sprite:YSortTarget(target)
/******************************************************************************
GLFX.Sprite:YSortTarget(target)

Set the ySorting target for this sprite, pass NIL to remove the target.
---------------------------------------------------------------------
INPUT
  target    Any table with an <y> field
******************************************************************************/
  self.YSortTrg = target
  
EndFunction

Function GLFX.Sprite:MakePolyCollision(shape, args)
  Local poly = {}
  If IsNil(args) Then args = {}
  
  Switch shape
    Case #POLY_DOT
      poly = G2D.Poly:New({ vertices = { 0.5, 0.5 } })

      
    Case #POLY_BOX
      poly = G2D.Poly:New({ vertices = { 0, 0, 1, 0, 1, 1, 0, 1 } })

    
    Case #POLY_OCTA
      poly = G2D.Poly:New({ vertices = { 0, 0.33, 0.33, 0, 0.66, 0, 1, 0.33, 1, 0.66, 0.66, 1, 0.33, 1, 0, 0.66 }})

      
    Case #POLY_TRIANGLE
      poly = G2D.Poly:New({ vertices = { 0, 1, 0.5, 0, 1, 1 }})
      
      

    Default

  EndSwitch
  
  If TB.Item.IsNil(args, "scaleoffset") Then args.ScaleOffset = { w = 0, h = 0 }

  poly.SpriteScale = { w = self.Width + args.ScaleOffset.w, h = self.height + args.ScaleOffset.h }
  
  If Not(IsNil(args))
    If TB.Item.Exists(args, "translate")
      poly:Translate(args.Translate.x, args.Translate.y)
    EndIf
  EndIf
  
  self:SetPolyCollision(poly)
  
EndFunction

Function GLFX.Sprite:_Reorder()
/******************************************************************************
GLFX.Sprite:_Reorder()

Used to reorder this sprite on its vertical position.
This method is called automatically by the movement handling routines.
******************************************************************************/    
  Local si, y = Int(self.SortedIndex), Int(self.y)
  Local i, v
  
  If HaveItem(self, "ysorttrg") Then y = Int(self.YSortTrg.y)
  
  If si <> y
    Local SortedList = self.Engine.Layers[self.Layer].SortedList
    For i, v In Pairs(SortedList[si])
      If v = self
        SortedList[si][i] = Nil
        Break
      EndIf
    Next

    If TB.Item.Exists(SortedList, y)
      InsertItem(SortedList[y], self)
    Else
      SortedList[y] = {}
      InsertItem(SortedList[y], self)
    EndIf

    If self.Engine.Layers[self.Layer].FirstIndex > y Then self.Engine.Layers[self.Layer].FirstIndex = y
    If self.Engine.Layers[self.Layer].LastIndex < y Then self.Engine.Layers[self.Layer].LastIndex = y

    self.SortedIndex = y
    
  EndIf
  
EndFunction

Function GLFX.Sprite:Fader(args) ; OK
/******************************************************************************
GLFX.Sprite:Fader(args)

Start a fade effect on the sprite color
---------------------------------------------------------------------
INPUT
  args          Arguments table
    ColorList   A table of one or more colors (RGBA)
    Timings     A list of timings in milliseconds
    Loop        TRUE to make the fade loop
    Easing      Easing function
******************************************************************************/
  If TB.Item.Exists(self, "_fade") Then self:FadeStop()
  
  self._Fade =
    { ColorList = args.ColorList,
      Timings   = args.Timings,
      Loop      = args.Loop,
      Easing    = args.Easing,
      Index     = 0 }
  
  Local col = self._Fade.ColorList[self._Fade.Index]
  
  self._FadeTween = tween.start(self._Fade.Timings[self._Fade.Index], self, { color = col }, self._Fade.Easing, self._FadeHandler, self)
  
EndFunction

Function GLFX.Sprite:FadeStop() ; OK
/******************************************************************************
GLFX.Sprite:FadeStop()

Stop a fade effect.
******************************************************************************/
  If TB.Item.Exists(self, "_fade")
    If TB.Item.Exists(self, "_fadetween")
      tween.stop(self._FadeTween, False)
      self._FadeTween = Nil
      self._Fade = Nil
    EndIf
    self._fade = Nil
  EndIf
EndFunction

Function GLFX.Sprite:FadeIn(ms, easing)
  ; Shortcut to make a sprite appear
  If IsNil(easing) Then easing = "linear"
  
  self:Fader(
    { ColorList = { { 1, 1, 1, 0 }, { 1, 1, 1, 1 } }, 
       Timings   = { 1, ms-1 }, 
       Loop      = False, 
       Easing    = easing })
EndFunction

Function GLFX.Sprite:FadeOut(ms, easing)
  ; Shortcut to make a sprite disappear
  If IsNil(easing) Then easing = "linear"
  
  self:Fader(
    { ColorList = { { 1, 1, 1, 1 }, { 1, 1, 1, 0 } }, 
       Timings   = { 1, ms-1 }, 
       Loop      = False, 
       Easing    = easing })
EndFunction

Function GLFX.Sprite._FadeHandler(sprite) ; 04/2021
/******************************************************************************
GLFX.Sprite._FadeHandler(sprite)

INTERNAL, called to update the ColorList.
;--------------------------------------------------------------------
******************************************************************************/
  Local fade = sprite._Fade
  fade.Index = fade.Index + 1

  If fade.Index > ListItems(fade.ColorList)-1
    If fade.Loop
      fade.Index = 0
      
    Else
      sprite._FadeTween = Nil
      sprite._Fade = Nil
      Return()
      
    EndIf
    
  EndIf
  
  Local col = fade.ColorList[fade.Index]

  sprite._FadeTween = tween.start(fade.Timings[fade.Index], sprite, { color = col }, fade.Easing, sprite._FadeHandler, sprite)

EndFunction

Function GLFX.Sprite:Stretcher(args) ; OK
/******************************************************************************
GLFX.Sprite:Stretcher(args)

Start a stretch effect on the sprite size
---------------------------------------------------------------------
INPUT
  args          Arguments table
    StretchList A table of two or more sizes (horizontal, vertical scales)
    Timings     A list of timings in milliseconds
    Loop        TRUE to make the fade loop
    Easing      Easing function
******************************************************************************/
  If TB.Item.Exists(self, "_stretch") Then self:StretchStop()
  
  self._Stretch =
    { StretchList = args.StretchList,
      Timings     = args.Timings,
      Loop        = args.Loop,
      Easing      = args.Easing,
      Index       = 0 }
  
  Local ang = self._Stretch.StretchList[self._Stretch.Index]
  self._StretchTween = tween.start(self._Stretch.Timings[self._Stretch.Index], self, { scaleW = ang[0], scaleH = ang[1] }, self._Stretch.Easing, self._StretchHandler, self)
  
EndFunction

Function GLFX.Sprite:StretchStop() ; OK
/******************************************************************************
GLFX.Sprite:StretchStop()

Stop a stretch effect.
******************************************************************************/
  If TB.Item.Exists(self, "_stretch")
    If TB.Item.Exists(self, "_stretchtween")
      tween.stop(self._StretchTween, False)
      self._StretchTween = Nil
    EndIf
    self._Stretch = Nil
  EndIf
EndFunction

Function GLFX.Sprite._StretchHandler(sprite) ; 04/2021
/******************************************************************************
GLFX.Sprite._StretchHandler(sprite)

INTERNAL, called to update the StretchList.
;--------------------------------------------------------------------
******************************************************************************/
  Local stretch = sprite._Stretch
  stretch.Index = stretch.Index + 1
  
  If stretch.Index > ListItems(stretch.StretchList)-1
    If stretch.Loop
      stretch.Index = 0
      
    Else
      sprite._Stretch = Nil
      sprite._StretchTween = Nil
      Return()
      
    EndIf
    
  EndIf
      
  Local ang = stretch.StretchList[stretch.Index]
  sprite._StretchTween = tween.start(stretch.Timings[stretch.Index], sprite, { scaleW = ang[0], scaleH = ang[1] }, stretch.Easing, sprite._StretchHandler, sprite)

EndFunction

Function GLFX.Sprite:Rotator(args) ; <-- Rotator
/******************************************************************************
GLFX.Sprite:Rotator(args)

Start a rotation effect on the sprite angle
---------------------------------------------------------------------
INPUT
  args          Arguments table
    AngleList   A table of two or more angles
    Timings     A list of timings in milliseconds
    Loop        TRUE to make the fade loop
    Easing      Easing function
******************************************************************************/
  If TB.Item.Exists(self, "_angle") Then self:RotateStop()
  
  self._Angle =
    { AngleList = args.AngleList,
      Timings   = args.Timings,
      Loop      = args.Loop,
      Easing    = args.Easing,
      Index     = 0 }
  
  Local ang = self._Angle.AngleList[self._Angle.Index]
  self._AngleTween = tween.start(self._Angle.Timings[self._Angle.Index], self, { angle = ang }, self._Angle.Easing, self._AngleHandler, self)
  
EndFunction

Function GLFX.Sprite:RotateStop()
/******************************************************************************
GLFX.Sprite:RotateStop()

Stop a rotation effect.
******************************************************************************/
  If TB.Item.Exists(self, "_angle")
    If TB.Item.Exists(self, "_angletween") 
      tween.stop(self._AngleTween, False)
      self._AngleTween = Nil
      self._Angle = Nil
    EndIf
    self._Angle = Nil
  EndIf
EndFunction

Function GLFX.Sprite._AngleHandler(sprite) ; 04/2021
/******************************************************************************
GLFX.Sprite._AngleHandler(sprite)

INTERNAL, called to update the AngleList.
;--------------------------------------------------------------------
******************************************************************************/
  Local angle = sprite._Angle
  angle.Index = angle.Index + 1
  
  If angle.Index > ListItems(angle.AngleList)-1
    If angle.Loop
      angle.Index = 0
      
    Else
      sprite._AngleTween = Nil
      sprite._Angle = Nil
      Return()
      
    EndIf
    
  EndIf
      
  Local ang = angle.AngleList[Angle.Index]
  sprite._AngleTween = tween.start(angle.Timings[angle.Index], sprite, { angle = ang }, angle.Easing, sprite._AngleHandler, sprite)

EndFunction

Function GLFX.Sprite:Blink(args) ; OK
/******************************************************************************
GLFX.Sprite:Blink(args)

Makes the sprite blink for a given amount of time
---------------------------------------------------------------------
INPUT
  args          Arguments table
    color       Blink color (RGBA)
    time        Blink duration
******************************************************************************/
  If TB.Item.Exists(self, "_blink") Then self:BlinkStop()
  
  self._blink =
    { savedColor = self.Color }
  
  self.Color = args.Color
  self._blink.TimeoutID = SetTimeout(Nil, GLFX.Sprite._blinkRestore, args.time, self)
  
EndFunction

Function GLFX.Sprite:_blinkRestore() ; OK
/******************************************************************************
GLFX.Sprite:_blinkRestore()

Restore the original color
******************************************************************************/
  self.userdata.Color   = self.userdata._blink.savedColor
  self.userdata._blink  = Nil
  
EndFunction

Function GLFX.Sprite:BlinkStop() ; OK
/******************************************************************************
GLFX.Sprite:BlinkStop()

Stop a previously started blink effect.
******************************************************************************/
  If TB.Item.Exists(self, "_blink")
    self.Color = self._blink.savedColor
    ClearTimeout(self._blink.TimeoutID)
    self._blink = Nil
  EndIf
EndFunction


Function GLFX.Sprite:Flash(args) ; OK
/******************************************************************************
GLFX.Sprite:Flash(args)

Starts a flash effect
---------------------------------------------------------------------
INPUT
  args
    Color     Flash color (RGBA)
    OnTime    Flash on time
    OffTime   Flash off time
    Timeout   Flash stop timeout
    UpdateRate
******************************************************************************/
  If TB.Item.Exists(self, "_flash") Then self:FlashStop()
  
  self._flash =
    { running = True,
      flashOn = True,
      color = args.Color,
      originalColor = self.Color,
      onTime = args.onTime,
      offTime = args.offTime,
      updateRate = args.updateRate,
      timerID = self.Engine.UpdateTimer,
      timeout = args.Timeout + GetTimer(self.Engine.UpdateTimer),
      updateID = SetInterval(Nil, GLFX.Sprite._FlashUpdate, args.UpdateRate, self),
      nextCheck = GetTimer(self.Engine.UpdateTimer) + args.OnTime
      }

  self.Color = args.Color

EndFunction
    
Function GLFX.Sprite:_FlashUpdate() ; OK
/******************************************************************************
GLFX.Sprite:_FlashUpdate()

INTERNAL, used to manage the flash effect
******************************************************************************/
  If TB.Item.Exists(self.userdata, "_flash")
    Local now = GetTimer(self.userdata._Flash.TimerID)
    Local delta = now - self.userdata._Flash.NextCheck
    If self.userdata._Flash.Running And self.userdata._Flash.NextCheck <= now
      If self.userdata._Flash.FlashOn
        self.userdata._Flash.FlashOn = False
        self.userdata.Color = self.userdata._Flash.OriginalColor
        self.userdata._Flash.NextCheck = now + self.userdata._Flash.OffTime - delta
        If self.userdata._Flash.Timeout <= now
          ClearInterval(self.userdata._Flash.UpdateID)
          self.userdata._Flash.Running = False
        EndIf
      Else
        self.userdata._Flash.FlashOn = True
        self.userdata.Color = self.userdata._Flash.Color
        self.userdata._Flash.NextCheck = now + self.userdata._Flash.OnTime - delta
      EndIf
    EndIf
  EndIf
  
EndFunction

Function GLFX.Sprite:FlashStop() ; OK
/******************************************************************************
GLFX.Sprite:FlashStop()

Stop a running flash effect.
******************************************************************************/
  If TB.Item.Exists(self, "_flash")
    If self._Flash.Running
      self._Flash.FlashOn = False
      self.Color = self._Flash.OriginalColor
      ClearInterval(self._Flash.UpdateID)
      self._Flash = Nil
    EndIf
  EndIf
  
EndFunction

Function GLFX.Sprite:SetAnimationFrames(framelist, args) ; - testare -
/******************************************************************************
GLFX.Sprite:SetFrames(framelist)

Defines a list of frames (images or brushes) to use to animate this sprite.
******************************************************************************/
  DBG.Console.Out("GLFX.Sprite:SetAnimationFrames()", DBG.OpenFunc, GLFXCh)
  
  ; DA SISTEMARE PER BENE LE ROUTINE DI CARICAMENTO PER ALPHA, TRANS-MONO, 
  ; TRANS-COLOR
  
  If GetType(framelist) = #TABLE
    ; FRAMELIST IS A TABLE OF FRAMES
    ; You can pass a frameList of image files, each one representing
    ; an animation frame or a preloaded brush id.
    Local i, f
    For i, f In Pairs(frameList)
      If GetType(f) = #STRING
        ; THIS FRAME IS A FILENAME (IMAGE) [testato]
        Local r, info = IsPicture(f)
        
        If r
          If info.Alpha
            LoadBrush(GLFX.BrushID, f, { LoadAlpha = True })
            GLFX._TexInit(GLFX.BrushID)
          ElseIf info.Transparency
            LoadBrush(GLFX.BrushID, f, { LoadTransparency = True, Transparency = self.Transparency })
            GLFX._TexInit(GLFX.BrushID)
          Else
            LoadBrush(GLFX.BrushID, f)
            GLFX._TexInit(GLFX.BrushID)
          EndIf
          
          self.frameList[i] = { indipendent = True, brush = GLFX.BrushID }
          GLFX.BrushID = GLFX.BrushID + 1
        Else
          ; Error loading <f>
          DBG.Console.Out("Loading of <" .. f .. "> failed!", DBG.Error, GLFXCh)
        EndIf
        
      Else
        ; THIS FRAME IS A PRELOADED BRUSH ID [testato]
        DBG.Console.Out("Preloaded brushe specified : " .. ToString(f), Nil, GLFXCh)
        self.frameList[i] = { indipendent = False, brush = f }
        GLFX._TexInit(f)
      EndIf
    Next
    
  ElseIf GetType(framelist) = #STRING
    If LeftStr(framelist, 13) = "SPRITESHEET::"
      ; FRAMELIST IS A SPRITESHEET
      ; You can specify a spritesheet using the prefix SPRITESHEET::
      ; followed by the image file with all the needed frames.
      ; You have to specify also the following arguments in <args>:
      ; - width     The single frame width
      ; - height    The single frame height
      ; - frames    The total number of frames
      ; You can also pass a preloaded spritesheet using instead of the
      ; image file the string BRUSH, in this case you have to provide
      ; also
      ; - brush     The preloaded brush id
      
      framelist = UnrightStr(framelist, 13)
      
      Local r, info = IsPicture(framelist)
      
      If frameList = "BRUSH"
        r = True
        info.alpha = GetAttribute(#BRUSH, args.brush, #ATTRHASALPHA)
        info.width = GetAttribute(#BRUSH, args.brush, #ATTRWIDTH)
        info.height = GetAttribute(#BRUSH, args.brush, #ATTRHEIGHT)
        info.transparency = GetAttribute(#BRUSH, args.brush, #ATTRHASMASK)
      EndIf

      If r
        Local indipendent, tmpBrush = True, -1
        self.frameList = {}
        self.id = GLFX.BrushID

        If info.Alpha
          If framelist = "BRUSH"
            indipendent = False
            tmpBrush = args.brush
          Else
            tmpBrush = LoadBrush(Nil, framelist, { LoadAlpha = True, Hardware = False })
          EndIf
          
        ElseIf info.Transparency
          If framelist = "BRUSH"
            indipendent = False
            tmpBrush = args.brush
          Else
            tmpBrush = LoadBrush(Nil, framelist, { LoadTransparency = True, Hardware = False })
          EndIf

        Else
          If framelist = "BRUSH"
            indipendent = False
            tmpBrush = args.brush
          Else
            tmpBrush = LoadBrush(Nil, framelist)
          EndIf
        EndIf
          
        Local x, y, w, h = 0, 0, args.width, args.height
        Local bw, bh = info.width, info.height
        For Local f = 1 To args.frames
          CreateBrush(GLFX.BrushID, w, h, #RED, { AlphaChannel = True, Clear = True })
          GFX.OutputDevice.Select(#BRUSH, GLFX.BrushID, #SELMODE_COMBO)
            DisplayBrushPart(tmpBrush, x, y, 0, 0, w, h)
          GFX.OutputDevice.EndSelect()
          GLFX._TexInit(GLFX.brushID)
          self.frameList[f-1] = { indipendent = indipendent, brush = GLFX.BrushID }
          GLFX.BrushID = GLFX.BrushID + 1
          x = x + w
          If x >= bw
            x = 0
            y = y + h
          EndIf
        Next
        
        If framelist <> "BRUSH" Then FreeBrush(tmpBrush)
          
      Else
        ; Error loading <r>
        DBG.Console.Out("Loading failed : " .. framelist, DBG.Error, GLFXCh)
      EndIf
  
    ElseIf LeftStr(framelist, 11) = "ANIMATION::"
      ; FRAMELIST IS AN ANIMATION
      framelist = UnrightStr(framelist, 11)
      
      Local r = IsAnim(framelist)
      
      If r
        Local indipendent, tmpBrush = True, -1
        self.frameList = {}
        self.id = GLFX.BrushID

        If TB.Item.IsNil(args, "loadalpha") Then args.LoadAlpha = False
        If TB.Item.IsNil(args, "loadtransparency") Then args.LoadTransparency = False

        Local tmpAnim, mask = -1, False
        If TB.Item.Exists(args, "transparency")
          tmpAnim = LoadAnim(Nil, framelist, 
          { LoadAlpha = args.LoadAlpha, 
            LoadTransparency = args.LoadTransparency,
            Transparency = args.Transparency,
            Hardware = False })
          mask = True
          self.Transparency = args.Transparency
        Else
          tmpAnim = LoadAnim(Nil, framelist, 
          { LoadAlpha = args.LoadAlpha, 
            LoadTransparency = args.LoadTransparency,
            Hardware = False })
        EndIf

        Local x, y, w, h = 0, 0, args.width, args.height
        args.frames = GetAttribute(#ANIM, tmpAnim, #ATTRNUMFRAMES)
        For Local f = 1 To args.frames
          CreateBrush(GLFX.BrushID, w, h, #BLACK, { Mask = mask, AlphaChannel = args.LoadAlpha, Clear = True })
          GFX.OutputDevice.Select(#BRUSH, GLFX.BrushID, #SELMODE_COMBO, Nil,0)
            DisplayAnimFrame(tmpAnim, 0, 0, f)
          GFX.OutputDevice.EndSelect()
          GLFX._TexInit(GLFX.brushID)
          self.frameList[f-1] = { indipendent = indipendent, brush = GLFX.BrushID }
          GLFX.BrushID = GLFX.BrushID + 1
        Next
        
        FreeAnim(tmpAnim)
          
      Else
        ; Error loading <r>
        DBG.Console.Out("Loading failed : " .. framelist, DBG.Error, GLFXCh)
      EndIf
      
    EndIf
    
    self.Animated = False
    self.Animations = {}
    self.CurrentAnimation = 0
    self.CurrentFrame = 0
    self.AnimationFrames = 0
    self.NextFrameTime = 0
    self.LastUpdateTime = 0
    self.AnimationPaused = True
    self.AnimDirection = 1

  EndIf
  
  DBG.Console.Out(Nil, DBG.CloseFunc, GLFXCh)
  
EndFunction

Function GLFX.Sprite:NewAnimationSequence(args) ; - testare -
  ; args
  ;   name
  ;   frames -> { frame, duration, callback }
  ;   onEnd
  ;   type ("oneshot", "loop", "pingpong", "random")
  
  Local i, v
  For i, v In Pairs(args.frames)
    If TB.Item.IsNil(v, "callback") Then v.Callback = Function() EndFunction
  Next
  
  self.Animations[args.name] = CopyTable(args)
  If TB.Item.IsNil(args, "onend") Then self.Animations[args.name].OnEnd = Function() EndFunction
  
EndFunction

Function GLFX.Sprite:SetAnimationSequence(seqName, firstFrame) ; - testare -
  self.CurrentAnimation = seqName
  self.CurrentFrame = self.Animations[seqName].Frames[firstFrame].Frame
  self.AnimationFrames = ListItems(self.Animations[seqName].Frames)
  self.Animated = True
  ; Callback per frame
  self.Animations[self.CurrentAnimation].Frames[self.CurrentFrame].Callback({ event = "Animation", type = "OnFrame", sprite = self, animation = self.CurrentAnimation, frame = self.CurrentFrame })
  self.NextFrameTime = GetTimer(self.Engine.Framework.TimerID) + self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
  
EndFunction

Function GLFX.Sprite:AnimationStart(resume) ; 04/2021 -> TO TEST <-
/******************************************************************************
GLFX.Sprite:AnimationStart(resume)

Start (or resume) a sprite's animation playback.
;--------------------------------------------------------------------
INPUT
  resume : Optional flag to resume the animation instead of starting it from
           the beginning.
******************************************************************************/
  self.AnimationPaused = False
  If Not(Resume) Then self.CurrentFrame = 0
  self.NextFrameTime = 0 ;GetTimer(self.Engine.Framework.TimerID) + self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
  
EndFunction

Function GLFX.Sprite:AnimationStop() ; 04/2021 -> TO TEST <-
/******************************************************************************
GLFX.Sprite:AnimationStop(resume)

Stop a sprite's animation playback.
;--------------------------------------------------------------------
******************************************************************************/
  self.AnimationPaused = True

EndFunction

Function GLFX.Sprite:NextAnimationFrame() ; - testare -

  If self.Animated
    If self.Animations[self.CurrentAnimation].Type <> "random"

      self.CurrentFrame = self.CurrentFrame + self.AnimDirection
      
      If self.CurrentFrame > (self.AnimationFrames-1)
        If self.Animations[self.CurrentAnimation].Type = "loop"
          self.CurrentFrame = 0
        ElseIf self.Animations[self.CurrentAnimation].Type = "pingpong"
          self.AnimDirection = -self.AnimDirection
          self.CurrentFrame = self.CurrentFrame + self.AnimDirection
        Else
          self.AnimationPaused = True
          self.CurrentFrame = self.AnimationFrames-1
          self.Animations[self.currentAnimation].OnEnd({ event = "Animation", type = "OnEnd", sprite = self, animation = self.CurrentAnimation })
        EndIf
        
      /*
      ElseIf self.CurrentFrame < 0
        If self.Animations[self.CurrentAnimation].Type = "loop"
          self.CurrentFrame = self.AnimationFrames-1
        ElseIf self.Animations[self.CurrentAnimation].Type = "pingpong"
          self.AnimDirection = -self.AnimDirection
          self.CurrentFrame = self.CurrentFrame + self.AnimDirection
        Else
          self.AnimationPaused = True
          self.CurrentFrame = 0
          self.Animations[self.currentAnimation].OnEnd({ event = "Animation", type = "OnEnd", sprite = self, animation = self.CurrentAnimation })
        EndIf */
      EndIf
    Else
      self.CurrentFrame = Rnd(self.AnimationFrames)
    EndIf
    
    ; Qua devo manipolare il self.BrushID ( o quello che è ) per infilarci
    ; dentro il frame corrente.
    self.Animations[self.CurrentAnimation].Frames[self.CurrentFrame].Callback({ event = "Animation", type = "OnFrame", sprite = self, animation = self.CurrentAnimation, frame = self.CurrentFrame })
    self.NextFrameTime = GetTimer(self.Engine.Framework.TimerID) + self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
  EndIf
EndFunction

Function GLFX.Sprite:PrevAnimationFrame() ; - testare -

  If self.Animated
    If self.Animations[self.CurrentAnimation].Type <> "random"
      
      self.CurrentFrame = self.CurrentFrame - self.AnimDirection
      
      If self.CurrentFrame < 0
        If self.Animations[self.CurrentAnimation].Type = "loop"
          self.CurrentFrame = self.AnimationFrames-1
        ElseIf self.Animations[self.CurrentAnimation].Type = "pingpong"
          self.AnimDirection = -self.AnimDirection
          self.CurrentFrame = self.CurrentFrame + self.AnimDirection
        Else
          self.AnimationPaused = True
          self.CurrentFrame = 0
          self.Animations[self.currentAnimation].OnEnd({ event = "Animation", type = "OnEnd", sprite = self, animation = self.CurrentAnimation })
        EndIf
        
      EndIf
    Else
      self.CurrentFrame = Rnd(self.AnimationFrames)
    EndIf
    
    self.Animations[self.CurrentAnimation].Frames[self.CurrentFrame].Callback({ event = "Animation", type = "OnFrame", sprite = self, animation = self.CurrentAnimation, frame = self.CurrentFrame })
    self.NextFrameTime = GetTimer(self.Engine.Framework.TimerID) + self.Animations[self.CurrentAnimation].frames[self.CurrentFrame].Duration
  EndIf
EndFunction

Function GLFX.Sprite:Attach(args) ; 04/2021
/******************************************************************************
GLFX.Sprite:Attach(args)

Attaches the sprite to another object
---------------------------------------------------------------------
INPUT
  args : A table with the following fields:
    target : Target object, must have at least an 'x' and an 'y' fields
    updateRate : Update rate in milliseconds
    offset : Object offset from the target, it's a table with two fields:
      x : Horizontal offset
      y : Vertical offset

NOTES
You can set an offset field to nil to ignore a coordinate.
This is a good example on how you can use the :ActionAdd() method, here it is used
to keep the sprite position updated with the target object.
******************************************************************************/
  If HaveItem(self, "_attach") Then self:Detach()
  
  self._attach = 
    { target = args.target,
      offset = args.offset 
      }
      
  self:ActionAdd(
    { name  = ":attach_method",
      atype = #SE_ATYPE_INTERVAL,
      func  = Function(msg)
                Local sprite = msg.userdata.sprite
                If HaveItem(sprite._attach.offset, "x") Then sprite.x = sprite._attach.target.x + sprite._attach.offset.x
                If HaveItem(sprite._attach.offset, "y") Then sprite.y = sprite._attach.target.y + sprite._attach.offset.y

              EndFunction,
      args = args.updateRate })
      
EndFunction

Function GLFX.Sprite:Detach() ; OK
/******************************************************************************
GLFX.Sprite:Detach()

Detaches the sprite from the object
******************************************************************************/
  If TB.Item.Exists(self, "_attach")
    self._attach = Nil
    self:ActionRemove(":attach_method")
  EndIf
  
EndFunction


Function GLFX.Sprite:FollowStart(args)
/******************************************************************************
GLFX.Sprite:Follow(args)

Starts to follow the given target
---------------------------------------------------------------------
INPUT
  args
    updateRate      Update rate in milliseconds (-1 means one shot)
    target          An object target with <x> and <y> fields
    easing          Easing to use
    speed           Speed expressed in pixels per seconds
    continuos       Detect target continuosly (True/False)
    faceDirection   Face target direction (True/False)
    angleOffset     Angle offset
******************************************************************************/
  self._follow_target = args.target
  self._follow_easing = args.easing
  self._follow_speed  = args.speed
  self._follow_continuos = args.continuos
  self._follow_tween  = -1
  self._follow_running = False
  self._follow_face = args.facedirection
  self._follow_offset = args.angleoffset
  self._follow_lastangle = -1
  
  If self._follow_face Then self.angleEnabled = True
  
  If args.updateRate > 0
    self:ActionAdd(
      { name  = "follower",
        atype = #SE_ATYPE_INTERVAL,
        func  = Function(msg)
                  Local sprite   = msg.userdata.sprite
                  Local target   = sprite._follow_target
                  Local distance = Sqrt((sprite.x-target.x)^2+(sprite.y-target.y)^2)
                  Local duration = (distance/sprite._follow_speed)*1000
                  Local angle    = sprite.angle
                  ;If (sprite.x - target.x) <> 0 And sprite._follow_face
                    angle = ATan2(target.y - sprite.y, target.x - sprite.x )
                    angle = Int((angle * (180/3.14) + self._follow_offset)*100)/100                                       
                  ;EndIf
                  If duration > 0 And Not(self._follow_running) And Not(self._follow_continuos)
                    sprite._follow_tween = tween.start(duration, sprite, { x=target.x, y=target.y }, sprite._follow_easing, Function() sprite._follow_running = False EndFunction)
                    self._follow_lastangle = angle
                    sprite._follow_running = True
                    If sprite._follow_face Then sprite.angle = angle
                  ElseIf duration > 0 And self._follow_continuos And angle <> self._follow_lastangle
                    If GetType(sprite._follow_tween) = #TABLE Then tween.stop(sprite._follow_tween)
                    sprite._follow_tween = tween.start(duration, sprite, { x=target.x, y=target.y }, sprite._follow_easing, Function() sprite._follow_running = False EndFunction)
                    self._follow_lastangle = angle
                    sprite._follow_running = True
                    If sprite._follow_face Then sprite.angle = angle
                  EndIf
                EndFunction,
        args  = args.updateRate})
  ElseIf args.updateRate = -1
    Local sprite   = msg.userdata.sprite
    Local target   = sprite._follow_target
    Local distance = Sqrt((sprite.x-target.x)^2+(sprite.y-target.y)^2)
    Local duration = (distance/sprite._follow_speed)*1000
    Local angle    = sprite.angle
    If (sprite.x - target.x) <> 0
      angle = ATan2(target.y - sprite.y, target.x - sprite.x )
      angle = Int((angle * (180/3.14) + self._follow_offset)*100)/100
    EndIf
    If duration > 0
      sprite._follow_tween = tween.start(duration, sprite, { x=target.x, y=target.y }, sprite._follow_easing, Function() sprite._follow_running = False EndFunction)
      sprite._follow_running = True
      sprite.angle = angle
    EndIf
  EndIf
EndFunction

Function GLFX.Sprite:FollowStop()
  If TB.Item.Exists(self, "_follow_target")
    self._follow_target = Nil
    self:ActionRemove("follower")
    If self._follow_tween <> -1
      tween.stop(self._follow_tween)
      self._follow_tween = -1
    EndIf
  EndIf
EndFunction

Function GLFX.Sprite:AttachToMouse(args) ; OK
/******************************************************************************
GLFX.Sprite:AttachToMouse(args)

Attaches the sprite to the mouse pointer
---------------------------------------------------------------------
INPUT
  args
    updateRate      Update rate in milliseconds
    offset          Mouse offset
      x
      y
Set an offset to nil to ignore a coordinate
******************************************************************************/
  If TB.Item.Exists(self, "_mouse_attach") Then self.DetachFromMouse()
  If TB.Item.IsNil(args, "updaterate") Then args.UpdateRate = 15
  If TB.Item.IsNil(args, "offset") Then args.offset = { x = 0, y = 0 }
  If TB.Item.IsNil(args.offset, "x") Then args.offset.x = 0
  If TB.Item.IsNil(args.offset, "y") Then args.offset.y = 0
  
  self._mouse_attached =
    { offset = args.offset }
    
  ;self._mouse_offset = args.offset
  self:ActionAdd(
    { name  = ":attachtomouse_method",
      atype = #SE_ATYPE_INTERVAL,
      func  = Function(msg)
                Local sprite, x, y = msg.userdata.sprite
                Local frameWork = self.Engine.Framework               
                If HaveItem(sprite._mouse_attached.offset, "x") Then x = (MouseX() + sprite._mouse_attached.offset.x)/frameWork.PixelSize[0]
                If HaveItem(sprite._mouse_attached.offset, "y") Then y = (MouseY() + sprite._mouse_attached.offset.y)/frameWork.PixelSize[1]
                sprite:MoveAbs(x, y)
              EndFunction,
      args = args.updateRate })
EndFunction

Function GLFX.Sprite:DetachFromMouse() ; OK
/******************************************************************************
GLFX.Sprite:DetachFromMouse()

Detaches the sprite from the mouse pointer
******************************************************************************/
  If TB.Item.Exists(self, "_mouse_attach")
    self:ActionRemove(":attachtomouse_method")
    self._mouse_attach = Nil    
  EndIf
  
EndFunction

Function GLFX.Sprite:MoveRel(x, y, wrapFlag)
/******************************************************************************
GLFX.Sprite:MoveRel(x, y, wrap)

Move the sprite adding the given coordinates
******************************************************************************/
  If x > 0
    ; Incremento
    self.x = self.x + x
    If wrapFlag
      Local rw = self.AnchorX*self.width*self.scaleW
      Local realX = self.x - rw
      If realX > self.Engine.Framework.Width Then self.x = -rw
    EndIf
  ElseIf x < 0
    ; Decremento
    self.x = self.x + x
    If wrapFlag
      Local rw = self.AnchorX*self.width*self.scaleW
      Local realX = self.x - rw
      If self.x < -rw Then self.x = self.Engine.Framework.Width + rw
    EndIf
  EndIf
  
  If y > 0
    ; Incremento
    self.y = self.y + y
    If wrapFlag
      Local rh = self.AnchorY*self.height*self.scaleH
      Local realY = self.y - rh
      If realY > self.Engine.Framework.Height Then self.y = -rh
    EndIf
  ElseIf y < 0
    ; Decremento
    self.y = self.y + y
    If wrapFlag
      Local rh = self.AnchorY*self.height*self.scaleH
      Local realY = self.y - rh
      If self.y < -rh Then self.y = self.Engine.Framework.Height + rh
    EndIf
  EndIf
  
  If self.Engine.YSorted
    If self.SortedIndex <> self.y Then self:_Reorder()
  EndIf
  
EndFunction

Function GLFX.Sprite:MoveAbs(x, y)
/******************************************************************************
GLFX.Sprite:MoveRel(x, y)

Move the sprite to the given coordinates
******************************************************************************/

  If Not(IsNil(x)) Then self.x = x
  If Not(IsNil(y)) Then self.y = y
    
  If self.Engine.YSorted
    If self.SortedIndex <> self.y Then self:_Reorder()
  EndIf
EndFunction

Function GLFX.Sprite:MoveTo(args) ; *
/******************************************************************************
GLFX.Sprite:MoveTo(args)

Move the sprite from its current position to the given position.
---------------------------------------------------------------------
INPUT
  args      Table with all needed parameters
    x       Target x
    y       Target y
    time    Movement time in milliseconds (speed is ignored)
    speed   Movement speed in pixel/sec (time is ignored)
    OnEnd   Function to call when the movement is finished
    easing  Movement easing function
******************************************************************************/
  ; Validation
  If TB.Item.IsNil(args, "x") Then args.x = self.x
  If TB.Item.IsNil(args, "y") Then args.y = self.y
  If TB.Item.IsNil(args, "speed")
    ; Mandatory <time> argument
    If TB.Item.IsNil(args, "time") Then args.time = 1
  Else
    ; Calculate movement time
    Local p1 = G2D.Point:New(self.x, self.y)
    Local p2 = G2D.Point:New(args.x, args.y)
    Local distance = p1:Distance(p2)
    args.time = distance/args.speed
  EndIf
  If TB.Item.IsNil(args, "onend") Then args.OnEnd = Function() EndFunction
  If TB.Item.IsNil(args, "easing") Then args.easing = "linear"
  
  ; Setup a tween to handle the movement
  If TB.Item.Exists(self, "_movetotween")
    tween.stop(self._MoveToTween, False)
    self._MoveToTween = Nil
  EndIf
  
  self._MoveToTween = tween.start(args.time, self, { x = args.x, y = args.y }, args.easing, 
    Function(sprite)
      args.OnEnd({ event  = "MoveTo:OnEnd",
                   sprite = sprite })
      sprite._MoveToTween = Nil
    EndFunction,
    self
    )

EndFunction

Function GLFX.Sprite:OrbitStart(args)
/******************************************************************************
GLFX.Sprite:Orbit(args)

Makes the sprite to orbit around an object with <x> and <y> coordinates.
---------------------------------------------------------------------
INPUT
  args
    target          Target object
    updateRate      Update rate in milliseconds
    time            Revolution time in milliseconds
    distance        Distance from the target point in pixels
    faceTarget      True to make the sprite face the target point
    angleOffset     Angle offset
    easing          easing
    start           start angle
    direction       direction (1 | -1)
******************************************************************************/
  self._orbit_target      = args.target
  self._orbit_time        = args.time
  self._orbit_distance    = args.distance
  self._orbit_faceTarget  = args.faceTarget
  self._orbit_angleOffset = args.angleOffset
  If args.direction = -1 Then self._orbit_angleOffset = self._orbit_angleOffset - 180
  self._orbit_easing      = args.easing
  self._orbit_start       = args.startAngle
  self._orbit_direction   = args.direction
  self._orbit_running     = False
  self._orbit_tween       = -1
  self._orbit_angle       = 0
  
  If self._orbit_faceTarget Then self.angleEnabled = True
  
  self:ActionAdd(
    { name  = "orbiter",
      atype = #SE_ATYPE_INTERVAL,
      func  = Function(msg)
                Local sprite   = msg.userdata.sprite
                Local target   = sprite._orbit_target
                Local radius   = sprite._orbit_distance
                Local distance = Sqrt((sprite.x-target.x)^2+(sprite.y-target.y)^2)
                Local duration = sprite._orbit_time
                Local angle    = sprite.angle
           
                ;If (sprite.x - target.x) <> 0 And sprite._orbit_faceTarget
                ;  angle = ATan2(target.y - sprite.y, target.x - sprite.x )
                ;  angle = Int((angle * (180/3.14)  + sprite._orbit_angleoffset)*100)/100
                  sprite.angle = -sprite._orbit_angle + sprite._orbit_angleoffset
                ;EndIf
                
                If Not(sprite._orbit_running)
                  sprite._orbit_angle = sprite._orbit_start
                  sprite._orbit_tween = tween.start(duration, sprite, { _orbit_angle = 360*sprite._orbit_direction + sprite._orbit_start }, sprite._orbit_easing, Function() sprite._orbit_running = False EndFunction)
                  sprite._orbit_running = True
                EndIf
                
                Local d = Rad(sprite._orbit_angle)
                Local position = { x = Sin(d)*radius, y = Cos(d)*radius }
                ;DebugPrint(Round(radius/10), Round(distance/10))
                 sprite.x = target.x + position.x
                 sprite.y = target.y + position.y
              EndFunction,
      args  = args.updateRate
      })
  
EndFunction

Function GLFX.Sprite:OrbitStop()
  If self._orbit_Running
    tween.stop(self._orbit_tween)
  EndIf
  
  self._orbit_Running = False
  self:ActionRemove("orbiter")  
  
EndFunction

Function GLFX.Sprite:AttachPaths(Sequences, seqName) ; 04/2021
/******************************************************************************
GLFX.Sprite:AttachPaths(Sequences, seqName)

Attach a sequence to the sprite, a sequence is an object that is composed
by 'nodes' that are points which form a path.
Since 'Sequences' object can have multiple node-sequences (or path) inside,
you have to specify which path name to start with using the 'seqName' argument.
;--------------------------------------------------------------------
INPUT
  Sequences : An object created by GLFX.PathSequences:New() method and filled
              by SeqObj:AddSequence() method.
  seqName : The sequence's name to start with for the sprite path.
******************************************************************************/
  self.Paths = Sequences
  self.Paths:SetSequence(seqName)

EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::: PARTICLE SYSTEM CLASS :::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
GLFX.ParticleSystem = {}
GLFX.ParticleSystem.DListCnt = 1
GLFX.ParticleSystem.UpdateRate = 20
GLFX.ParticleSystem.Layer = 0
GLFX.ParticleSystem.Order = -1
GLFX.ParticleSystem.Emitter = {}
GLFX.ParticleSystem.Emitter.x = 600
GLFX.ParticleSystem.Emitter.y = 300
GLFX.ParticleSystem.Emitter.rate = 200
GLFX.ParticleSystem.Emitter.quantity = 1
GLFX.ParticleSystem.Emitter.nextEmission = 0
GLFX.ParticleSystem.Emitter.count = -1
GLFX.ParticleSystem.Emitter.spreadx = 10
GLFX.ParticleSystem.Emitter.spready = 10
GLFX.ParticleSystem.Gravity = {}
GLFX.ParticleSystem.Gravity.x = -0.01
GLFX.ParticleSystem.Gravity.y = 0.075
GLFX.ParticleSystem.Gravity.velocity = 0.05
GLFX.ParticleSystem.ParticlesInfo = {}
GLFX.ParticleSystem.ParticlesInfo.velocity = 1.50
GLFX.ParticleSystem.ParticlesInfo.velocityVar = 0.25
GLFX.ParticleSystem.ParticlesInfo.angle = 270
GLFX.ParticleSystem.ParticlesInfo.angleVar = 30
GLFX.ParticleSystem.ParticlesInfo.anchorX = 0.5
GLFX.ParticleSystem.ParticlesInfo.anchorY = 0.5

GLFX.ParticleSystem.ParticlesInfo.fade1 = { 1.0, 1.0, 1.0, 1.0 }
GLFX.ParticleSystem.ParticlesInfo.fade2 = { 0.0, 0.0, 0.0, 0.0 }
GLFX.ParticleSystem.ParticlesInfo.fadeTime = 3000
GLFX.ParticleSystem.ParticlesInfo.fadeVar = 0
GLFX.ParticleSystem.ParticlesInfo.linkedFade = True

GLFX.ParticleSystem.ParticlesInfo.scale1 = 0.5
GLFX.ParticleSystem.ParticlesInfo.scale2 = 3.0
GLFX.ParticleSystem.ParticlesInfo.scaleTime = 2000
GLFX.ParticleSystem.ParticlesInfo.scaleVar = 0
GLFX.ParticleSystem.ParticlesInfo.linkedScale = True

GLFX.ParticleSystem.ParticlesInfo.roto1 = 0
GLFX.ParticleSystem.ParticlesInfo.roto2 = 360
GLFX.ParticleSystem.ParticlesInfo.rotoTime = 3000
GLFX.ParticleSystem.ParticlesInfo.rotoVar = 60
GLFX.ParticleSystem.ParticlesInfo.rotoMatrix = { 0, 0, 1 }
GLFX.ParticleSystem.ParticlesInfo.linkedRoto = True

GLFX.ParticleSystem.ParticlesInfo.life = 3000
GLFX.ParticleSystem.ParticlesInfo.lifeVar = 0

GLFX.ParticleSystem.Particles = {}
GLFX.ParticleSystem.ParticlesCount = 0
GLFX.ParticleSystem.Textures = {}
GLFX.ParticleSystem.Textures.Brushes = False
GLFX.ParticleSystem.Textures.Items = {}
GLFX.ParticleSystem.TexturesCount = 0
GLFX.ParticleSystem.UseAtlas = False
GLFX.ParticleSystem.Atlas = {}
GLFX.ParticleSystem.SpriteEngine = {}
GLFX.ParticleSystem.IntervalID = -1
GLFX.ParticleSystem.Active = True
GLFX.ParticleSystem.Group = 0
GLFX.ParticleSystem.Color = { 1.0, 1.0, 1.0, 1.0 }    
GLFX.ParticleSystem.blendSrc = #GL_SRC_ALPHA
GLFX.ParticleSystem.blendDst = #GL_ONE_MINUS_SRC_ALPHA
GLFX.ParticleSystem.texMapping = { 0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0 }
GLFX.ParticleSystem.blendEnabled = True
GLFX.ParticleSystem.angleEnabled = True
GLFX.ParticleSystem.colorEnabled = True
GLFX.ParticleSystem.scaleEnabled = True
GLFX.ParticleSystem.PolyCollEnabled = False
GLFX.ParticleSystem.PolyCollGeometry = #POLY_DOT
;--- experimental, seems ok ---
GLFX.ParticleSystem.Inverted = False
;--------------------



Function GLFX.ParticleSystem:New(args) ; 04/2021
/******************************************************************************
obj = GLFX.ParticleSystem:New(args)
                             
Create a new particle system.
;--------------------------------------------------------------------
INPUT
  args : A table with all the parameters you want to customize, all default
         values are stored in GLFX.ParticleSystem along with all the needed
         methods.
******************************************************************************/
  ; Instantiate a new particle system object
  Local NewObj = CopyTable(GLFX.ParticleSystem)
  
  If TB.Item.Exists(args, "layer")             Then NewObj.Layer = args.Layer
  If TB.Item.Exists(args, "updaterate")        Then NewObj.UpdateRate = args.UpdateRate
  If TB.Item.Exists(args, "emitter")           Then TB.Set(NewObj.Emitter, args.Emitter, False)
  If TB.Item.Exists(args, "particlesinfo")     Then TB.Set(NewObj.ParticlesInfo, args.ParticlesInfo, False)
  If TB.Item.Exists(args, "gravity")           Then TB.Set(NewObj.Gravity, args.Gravity, False)
  If TB.Item.Exists(args, "group")             Then NewObj.Group = args.Group
  If TB.Item.Exists(args.textures, "useatlas") Then NewObj.UseAtlas = args.Textures.UseAtlas
  If TB.Item.Exists(args.textures, "atlas")    Then NewObj.Atlas = args.Textures.Atlas
  ;--- experimental, seems ok ---
  If TB.Item.Exists(args, "inverted")          Then NewObj.Inverted = args.Inverted
  ;--------------------

  ; Attach the sprite engine to the particle system
  NewObj.SpriteEngine = args.SpriteEngine

  ; Handle the layer
  If Not(HaveItem(NewObj.SpriteEngine.PartSystems, NewObj.layer))
    NewObj.SpriteEngine.PartSystems[NewObj.layer] = {}
  EndIf
  
  ; Handle the order into the layer
  If NewObj.order = -1
    NewObj.order = ListItems(args.SpriteEngine.PartSystems[NewObj.layer])
  EndIf

  ; Finally the particle system into the sprite engine respecting the layer
  InsertItem(args.SpriteEngine.PartSystems[NewObj.layer], NewObj, NewObj.order)
 
  ; Check if we have to use an Atlas or brushes
  If Not(NewObj.UseAtlas)
    If Not(args.Textures.Brushes)
      DBG.Console.Out("Loading textures...", Nil, GLFXCh)
      Local i, v
      For i, v In IPairs(args.Textures.Items)
        Local c, info = IsPicture(v)

        ;==================================================================
        If NewObj.SpriteEngine.Framework.PowerOfTwo
          info.width = GLFX.GetNearestPowerOfTwo(info.width)
          info.height = GLFX.GetNearestPowerOfTwo(info.height)
        EndIf
        ;==================================================================
        
        If c
          Local bid = GLFX.BrushID
          DBG.Console.Out(bid .. " - " .. v, Nil, GLFXCh)
          LoadBrush(bid, v, { LoadAlpha = info.Alpha,
                              scaleWidth = info.Width,
                              scaleHeight = info.Height,
                              smoothScale = False
                              })        
          InsertItem(NewObj.Textures.Items, bid)
          GLFX.BrushID = GLFX.BrushID + 1
            
        Else
          DBG.Console.Out("Error loading the texture -> " .. v, DBG.Warning, GLFXCh)
          
        EndIf
        
      Next
      
    Else
      DBG.Console.Out("Setting up textures...", Nil, GLFXCh)
      Local i, v
      For i, v In IPairs(NewObj.Textures.Items)
        If GetType(v) = #NUMBER
          DBG.Console.Out("- Setting up brush " .. v, Nil, GLFXCh)
          InsertItem(NewObj.Textures.Items, v)
          
        Else
          DBG.Console.Out("Textures can be only numeric indexed brushes!", DBG.Warning, GLFXCh)
          
        EndIf
        
      Next
      
    EndIf
    
  Else
    NewObj.Textures = args.Textures
    
  EndIf
  
  NewObj.TexturesCount = ListItems(NewObj.Textures.Items)
  
  ; Use a DisplayList to draw particles
  ; -----------------------------------
  ; Generate an id for the DisplayList
  If NewObj.UseAtlas
    ; Generated at runtime
    
  Else
    NewObj.DisplayList = gl.GenLists(1)
    ; self.DListCnt = self.DListCnt + 1
    DBG.Console.Out("Creating a new DisplayList : " .. NewObj.DisplayList, Nil, GLFXCh)
    ; NewObj.DisplayList = self.DListCnt
    gl.NewList(NewObj.DisplayList, #GL_COMPILE)
      gl.Begin(#GL_QUADS)
        gl.TexCoord(0.0, 1.0)
        gl.Vertex( -1, -1, 0)
        gl.TexCoord(1.0, 1.0)
        gl.Vertex(  1, -1, 0)
        gl.TexCoord(1.0, 0.0)
        gl.Vertex(  1,  1, 0)
        gl.TexCoord(0.0, 0.0)
        gl.Vertex( -1,  1, 0)
        ;gl.LoadIdentity()
      gl.End()
    gl.EndList()
  EndIf
  
  ; Create an interval function for the particles emission, pass itself as userdata
  If NewObj.Emitter.Rate > 0 Then NewObj.IntervalID = SetInterval(Nil, GLFX.ParticleSystem._Update, NewObj.UpdateRate, NewObj)
  
  Return(NewObj)
  
EndFunction

Function GLFX.ParticleSystem:EmitON() ; 04/2021
/******************************************************************************
GLFX.ParticleSystem:EmitON()

Switch on the particle-system's emitter
;--------------------------------------------------------------------

******************************************************************************/
  self.Active = True
  
EndFunction

Function GLFX.ParticleSystem:EmitOFF() ; 04/2021
/******************************************************************************
GLFX.ParticleSystem:EmitOFF()

Switch off the particle-system's emitter
;--------------------------------------------------------------------

******************************************************************************/
  self.Active = False

EndFunction

Function GLFX.ParticleSystem:Move(x, y) ; 04/2021
/******************************************************************************
GLFX.ParticleSystem:Move(x, y)

Moves the emitter to the given position
---------------------------------------------------------------------
INPUT
  x : New x position
  y : New y position
******************************************************************************/
  self.Emitter.x = x
  self.Emitter.y = y

EndFunction

Function GLFX.ParticleSystem:Free() ; 04/2021
/******************************************************************************
GLFX.ParticleSystem:Free() 

Free the particle system and all allocated resources including all
emitted particles.
;--------------------------------------------------------------------

******************************************************************************/
  ; Remove the Particle System from the Sprite Engine list
  Local SE, li, psl, pi, ps = self.SpriteEngine
  For li, psl In Pairs(SE.PartSystems)
    For pi, ps In Pairs(psl)
      If ps = self
        RemoveItem(SE.PartSystems[li], pi)
        Break(2)
        
      EndIf
      
    Next
    
  Next    

  ; Free brushes
  If self.UseAtlas
    ; Nothing to free
    
  Else
    Local brushes = 0
    If Not(self.Textures.Brushes)
      For Local i = 0 To self.TexturesCount - 1
        brushes = brushes + 1
        FreeBrush(self.Textures.Items[i])
        
      Next
      
    EndIf
    
  EndIf

  ; Free all the particles and linked sprites
  Local particles, i, v
  For i, v In Pairs(self.Particles)
    particles = particles + 1
    v.Sprite:Destroy()
    self.ParticlesCount = self.ParticlesCount - 1
    self.Particles[i] = Nil

  Next

  If self.UseAtlas
  
  Else
    gl.DeleteLists(self.DisplayList, 1)

  EndIf
  
  ; Removes the update interval
  ClearInterval(self.IntervalID)
  self.IntervalID = -1
  
EndFunction

Function GLFX.ParticleSystem._Update(msg) ; 04/2021
/******************************************************************************
GLFX.ParticleSystem._Update(msg)

Internal function called by the updater to update all particles.
---------------------------------------------------------------------
INPUT
  msg : Interval message
******************************************************************************/  
  Local PartSys = msg.UserData
  Local Emitter = PartSys.Emitter

  ; Step 1: Updates all particles and removes death ones
  ; ----------------------------------------------------
  For Local i = PartSys.ParticlesCount-1 To 0 Step -1
    If PartSys.Particles[i]:Update()
      RemoveItem(PartSys.Particles, i)
      PartSys.ParticlesCount = PartSys.ParticlesCount - 1
      
    EndIf

  Next

  ; Step 2: Check if we have to destroy the particle system
  ; -------------------------------------------------------
  If Emitter.Count <> -1
    ; Established number of emissions
    If Emitter.Count > 0
      ; Do nothing emissions counter is not yet completed
      
    Else
      ; Count reached, destroy the particle system
      ; The system will be destroyed only when all particles are death
      ; -> PartSys.ParticlesCount = 0
      If PartSys.ParticlesCount = 0
        ; Destroy the system
        Local i, v
        For i, v In Pairs(PartSys.SpriteEngine.PartSystems)
          If v = PartSys
            RemoveItem(PartSys.SpriteEngine.PartSystems, i)
            Break()
            
          EndIf
          
        Next
        PartSys:Free()
        
      EndIf

      ; No more emissions!
      Return()
      
    EndIf

  EndIf

  ; Step 3: New particles emission
  ; ------------------------------
  ; If the system is active verify if it's time to emit new particles
  If PartSys.Active
    If Emitter.NextEmission <= GetTimer(PartSys.SpriteEngine.Framework.TimerID)
      ; Create the new particles
      For Local p = 1 To Emitter.Quantity Do GLFX.Particle:Create(PartSys)
      ; Setup the timer for the next emission
      Emitter.NextEmission = GetTimer(PartSys.SpriteEngine.Framework.TimerID) + Emitter.Rate
      ; If needed updates the emitter counter
      If Emitter.Count > 0 Then Emitter.Count = Emitter.Count - 1
      
    EndIf
    
  EndIf
  
EndFunction

Function GLFX.ParticleSystem:Draw() ; 04/2021
/******************************************************************************
GLFX.ParticleSystem:Draw()

Draw all particle-system's particles
;--------------------------------------------------------------------
INTERNAL method used to draw the particles system.
******************************************************************************/
  Local ps  = self
  Local pi0 = self.ParticlesInfo.rotoMatrix[0]
  Local pi1 = self.ParticlesInfo.rotoMatrix[1]
  Local pi2 = self.ParticlesInfo.rotoMatrix[2]

  If ps.ParticlesCount > 0

    ; Setup
    gl.Enable(#GL_TEXTURE_2D)
    
    If self.blendEnabled
      gl.Enable(#GL_BLEND)
      If self.blendSrc <> self.SpriteEngine.Framework.GL_blendSrc Or
         self.blendDst <> self.SpriteEngine.Framework.GL_blendDst
        gl.BlendFunc(self.blendSrc, self.blendDst)
        self.SpriteEngine.Framework.GL_blendSrc = self.blendSrc
        self.SpriteEngine.Framework.GL_blendDst = self.blendDst
        
      EndIf
      
    Else
      gl.Disable(#GL_BLEND)
      
    EndIf    
    
    gl.PushMatrix()

    Local parti, partp
    For parti, partp In IPairs(ps.particles)
      Local partv  = partp.Sprite     
      gl.LoadIdentity()
      
      ; Position
      gl.Translate(partv.px, partv.py, 0.0)

      ; Color
      If self.colorEnabled Then gl.Color(partv.Color[0], partv.Color[1], partv.Color[2], partv.Color[3])
      
      ; Scaling
      If self.scaleEnabled Then gl.Scale(partv.pw, partv.ph, 1)
      
      ; Angle
      If self.angleEnabled Then gl.Rotate(partv.angle, pi0, pi1, pi2)
      
      If self.UseAtlas
        If GLFX.LastTexture <> self.Atlas.id
          gl.BindTexture(#GL_TEXTURE_2D, self.Atlas.id)
          GLFX.LastTexture = self.Atlas.id
          
        EndIf

        gl.Begin(#GL_QUADS)
          gl.TexCoord(partv.texMapping[0], partv.texMapping[1])
          gl.Vertex(-1, -1, 0)
          gl.TexCoord(partv.texMapping[2], partv.texMapping[3])
          gl.Vertex(1, -1, 0)
          gl.TexCoord(partv.texMapping[4], partv.texMapping[5])
          gl.Vertex(1, 1, 0)
          gl.TexCoord(partv.texMapping[6], partv.texMapping[7])
          gl.Vertex(-1, 1, 0)
        gl.End
        
        
      Else
        If GLFX.LastTexture <> partv.Brush_ID
          gl.BindTexture(#GL_TEXTURE_2D, partv.Brush_ID)
          GLFX.LastTexture = partv.Brush_ID
          
        EndIf
      
        gl.CallList(self.DisplayList)  
      EndIf
      
    Next

    gl.PopMatrix()
    
  EndIf

EndFunction

;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;:::::::::::::::::::::::::::::: PARTICLE CLASS ::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
GLFX.Particle = {}
GLFX.Particle.Sprite = {}
GLFX.Particle.Velocity = 0
GLFX.Particle.Gravity = {}
GLFX.Particle.Gi = {}
GLFX.Particle.Angle = 0
GLFX.Particle.DeathTime = 0
GLFX.Particle.LifeTime = 0
GLFX.Particle.UpdateRate = 20
GLFX.Particle.EngineTimer = -1
GLFX.Particle.lastUpdate = 0
GLFX.Particle.TweenColor = -1

Function GLFX.Particle:Create(PartSys) ; 04/2021
/******************************************************************************
particle = GLFX.Particle:Create(PartSys)

Create a new particle in the give system
---------------------------------------------------------------------
INPUT
  PartSys : The particle system object that need to emit a new particle
******************************************************************************/
  ; Adjust the emission point
  Local pSysEmitter = PartSys.Emitter
  Local xpos = pSysEmitter.x + Rnd(pSysEmitter.SpreadX)
  Local ypos = pSysEmitter.y + Rnd(pSysEmitter.SpreadY)

  Local pinfo = PartSys.ParticlesInfo

  ; Create a new particle object
  Local NewPart = CopyTable(GLFX.Particle)
  NewPart.UpdateRate  = PartSys.UpdateRate
  NewPart.EngineTimer = PartSys.SpriteEngine.Framework.TimerID
  
  ; Setup gravity
  NewPart.Gravity = PartSys.Gravity
  NewPart.Gi = { x = 0, y = 0 }
  
  ; Setup the particle system father
  NewPart.PartSys = PartSys

  ; Pick a random image/texture
  Local frame = Rnd(PartSys.TexturesCount)
  Local _text = PartSys.Textures.Items[frame]
  
  If PartSys.UseAtlas
    ; Check if we have to use an Atlas, if so picks the texture from there
      NewPart.Sprite = GLFX.Sprite:Load(
      { AtlasSprite = PartSys.Atlas,
        FrameIndex = _text
        },
      PartSys.SpriteEngine,
      { layer = PartSys.Layer, 
        X = xpos, 
        Y = ypos, 
        AnchorX = pinfo.AnchorX, 
        AnchorY = pinfo.AnchorY, 
        group = 
        PartSys.Group, 
        Color = CopyTable(PartSys.Color), 
        blenSrc = PartSys.blendSrc, 
        blendDst = PartSys.blendDst, 
        texMapping = PartSys.texMapping, 
        blendEnabled = PartSys.blendEnabled, 
        angleEnabled = PartSys.angleEnabled, 
        colorEnabled = PartSys.colorEnabled })
        
  Else
    ; If not load the particle from a brush
    NewPart.Sprite = GLFX.Sprite:NewFromBrush(
      _text, 
      PartSys.SpriteEngine, 
      { layer = PartSys.Layer, 
        X = xpos, 
        Y = ypos, 
        AnchorX = pinfo.AnchorX, 
        AnchorY = pinfo.AnchorY, 
        group = PartSys.Group, 
        Color = CopyTable(PartSys.Color), 
        blenSrc = PartSys.blendSrc, 
        blendDst = PartSys.blendDst, 
        texMapping = PartSys.texMapping, 
        blendEnabled = PartSys.blendEnabled, 
        angleEnabled = PartSys.angleEnabled, 
        colorEnabled = PartSys.colorEnabled })

  EndIf
  
  ; Setup the particle sprite properties
  NewPart.Sprite.isParticle = True
  NewPart.Sprite.px = -500
  NewPart.Sprite.py = -500
  NewPart.Sprite.pw = 1
  NewPart.Sprite.ph = 1
  NewPart.Sprite.IsParticle = True
  NewPart.Sprite.Particle = NewPart
  
  ; Check if we have to enable the collisions
  If PartSys.PolyCollEnabled
    NewPart.Sprite:MakePolyCollision(PartSys.PolyCollGeometry)
    NewPart.Sprite:EnablePolyCollision(True, { }, { })    
  EndIf
  
  ; SETUP THE PARTICLE ANIMATIONS
  ; ::: Particle Life :::
  Local var, hvar = 0, 0
  If pinfo.LifeVar <> 0
    var  = Rnd(pinfo.LifeVar)
    hvar = Shr(pinfo.LifeVar, 1)
  EndIf
  Local life = pinfo.Life - hvar + var
  NewPart.LifeTime = life

  ; ::: Particle Fade & Color :::
  Local Var, HVar, Fadetime = 0, 0, Life
  If GetType(pinfo.Fade1) = #TABLE
    If Not(pinfo.LinkedFade)
      If pinfo.FadeVar <> 0
        Var  = Rnd(pinfo.FadeVar)
        HVar = Shr(pinfo.FadeVar, 1)
      EndIf
      fadetime = pinfo.FadeTime - HVar + Var
    EndIf
  
    NewPart.pColorEnabled = True
    
    NewPart.Sprite.Color = CopyTable(pinfo.Fade1)
    NewPart.ColorSteps = 
      { (NewPart.Sprite.Color[0]-pInfo.Fade2[0])/fadetime*NewPart.updateRate,
        (NewPart.Sprite.Color[1]-pInfo.Fade2[1])/fadetime*NewPart.updateRate,
        (NewPart.Sprite.Color[2]-pInfo.Fade2[2])/fadetime*NewPart.updateRate,
        (NewPart.Sprite.Color[3]-pInfo.Fade2[3])/fadetime*NewPart.updateRate }
    ;NewPart.TweenColor = tween.start(fadetime, NewPart.Sprite, { color = pinfo.fade2 }, pinfo.fadeeasing, Function() EndFunction)
  
  Else
    NewPart.pColorEnabled = False

  EndIf

  ; :: Particle Rotation :::
  Local Var1, Var2, HVar2, RotoTime = 0, 0, 0, Life
  If pinfo.Roto1 <> -1
    If pinfo.RotoVar <> 0 Then Var1 = Rnd(pinfo.RotoVar)
    If Not(pinfo.LinkedRoto)
      If pinfo.RotoVar <> 0
        Var2  = Rnd(pinfo.RotoVar)
        HVar2 = Shr(pinfo.RotoVar, 1)
      EndIf
      rototime = pinfo.RotoTime - HVar2 + Var2
    EndIf

    NewPart.pAngleEnabled = True
    
    NewPart.Sprite.Angle = pinfo.Roto1
    NewPart.angleSteps = (NewPart.Sprite.Angle-pInfo.Roto2)/rototime*NewPart.updateRate

  Else
    NewPart.pAngleEnabled = False

  EndIf

  ; :: Particle Scaling :::
  If pinfo.Scale1 <> -1
    Local Var, HVar, ScaleTime = 0, 0, Life
    If Not(pinfo.LinkedScale)
      If pinfo.ScaleVar <> 0
        Var  = Rnd(pinfo.ScaleVar)
        HVar = Shr(pinfo.ScaleVar, 1)
      EndIf
      scaletime = pinfo.ScaleTime - HVar + Var
    EndIf

    NewPart.pScaleEnabled = True
    
    NewPart.Sprite.scaleW = pinfo.Scale1
    NewPart.Sprite.scaleH = pinfo.Scale1
    NewPart.scaleSteps = (NewPart.Sprite.scaleW-pInfo.Scale2)/scaletime*NewPart.updateRate

  Else
    NewPart.pScaleEnabled = False
    
  EndIf

  ; ::: Particle Direction (Angle) :::
  Local Var, HVar = 0, 0
  If pinfo.AngleVar <> 0
    Var = Rnd(pinfo.AngleVar)
    HVar = Shr(pinfo.AngleVar, 1)
  EndIf
  NewPart.Angle = pinfo.Angle - HVar + Var
  
  ;--- experimental ---
  ;--- The particles are generated on the external ring and move to
  ;--- the emitter point.
  If PartSys.Inverted
    ; Determine the starting position
    Local startX, startY = xpos, ypos
    Local lifeTime = Life
    Local rs     = Rad(NewPart.Angle)
    Local deltaX = pinfo.Velocity*Cos(rs)
    Local deltaY = pinfo.Velocity*Sin(rs)
    ; Direction Inversion
    Local dieX = startX + deltaX*lifeTime/PartSys.UpdateRate
    Local dieY = startY + deltaY*lifeTime/PartSys.UpdateRate
    
    ; Imposto il punto di nascita
    NewPart.Sprite.x = dieX
    NewPart.Sprite.y = dieY
    ; Inverto la direzione
    NewPart.Angle = NewPart.Angle-180
    
  EndIf

  ; ::: Particle Velocity :::
  Local Var, HVar = 0, 0
  If pinfo.VelocityVar <> 0
    Var = Rnd(pinfo.VelocityVar)
    HVar = Shr(pinfo.VelocityVar, 1)
  EndIf
  NewPart.Velocity = pinfo.Velocity - HVar + Var
  
  ; ::: Particle Death Time :::
  NewPart.DeathTime = GetTimer(PartSys.SpriteEngine.Framework.TimerId) + Life

  ; Stores the particle and increase the counter
  InsertItem(PartSys.Particles, NewPart, PartSys.ParticlesCount)
  PartSys.ParticlesCount = PartSys.ParticlesCount + 1
  
  ; Update the particle last update time
  NewPart.LastUpdate  = GetTimer(NewPart.EngineTimer)

EndFunction

Function GLFX.Particle:Update() ; 04/2021
/******************************************************************************
GLFX.Particle:Update()

Update the particle
;--------------------------------------------------------------------
OUTPUT
  death : Returns 'True' if the particle is death
******************************************************************************/
  ; Compute movement & rotation
  Local rs     = Rad(self.Angle)
  Local deltax = self.Velocity*Cos(rs) + self.Gi.x
  Local deltay = self.Velocity*Sin(rs) + self.Gi.y

  Local now = GetTimer(self.EngineTimer)
  Local dt = (now-self.LastUpdate)/self.UpdateRate
  
  self.Velocity = self.Velocity + self.Gravity.Velocity*dt
  self.Gi.y = self.Gi.y + self.Gravity.y*dt
  self.Gi.x = self.Gi.x + self.Gravity.x*dt

  self.Sprite:Translate(DeltaX*dt, DeltaY*dt)
  
  ; Color Update
  If self.pColorEnabled
    self.Sprite.Color[0] = self.Sprite.Color[0] - self.ColorSteps[0]*dt
    self.Sprite.Color[1] = self.Sprite.Color[1] - self.ColorSteps[1]*dt
    self.Sprite.Color[2] = self.Sprite.Color[2] - self.ColorSteps[2]*dt
    self.Sprite.Color[3] = self.Sprite.Color[3] - self.ColorSteps[3]*dt
    
  EndIf

  ; Scale Update
  If self.pScaleEnabled
    self.Sprite.scaleW = self.Sprite.scaleW - self.scaleSteps*dt
    self.Sprite.scaleH = self.Sprite.scaleW
    
  EndIf
  
  ; Angle Update
  If self.pAngleEnabled
    self.Sprite.Angle = self.Sprite.Angle - self.angleSteps*dt
    
  EndIf
  
  self.Sprite.pw = self.Sprite.Width*self.Sprite.scaleW/2
  self.Sprite.ph = self.Sprite.Height*self.Sprite.scaleH/2
  self.Sprite.px = self.Sprite.x-self.Sprite.AnchorX*self.Sprite.pw
  self.Sprite.py = self.Sprite.y-self.Sprite.AnchorY*self.Sprite.ph
  self.LastUpdate = GetTimer(self.EngineTimer)
  
  If self.DeathTime <= self.LastUpdate
    self.Sprite:Destroy()
    Return(True)
    
  EndIf

  Return(False)
  
EndFunction

Function GLFX.Particle:Free() ; 04/2021
/******************************************************************************
GLFX.Particle:Free()

Mark the particle so that at the next update it will be removed
;--------------------------------------------------------------------

******************************************************************************/
  self.DeathTime = 0
  self.LastUpdate = 1

EndFunction

Function GLFX.Sprite:PathStart()
/******************************************************************************
GLFX.SimpleSprite:PathStart()

Starts the active path sequence for this sprite starting its movements.
******************************************************************************/
  Local seq = self.Paths
  
  ;| Execute the current node
  seq.currentNode = 0
  Local node = seq.currentSequence.Nodes[seq.currentNode]

  ;| Start movement tween
  Local sx, sy, ex, ey = node.startpos.x+node.startoffset.x, node.startpos.y+node.startoffset.y, node.endpos.x+node.endoffset.y, node.endpos.y+node.endoffset.y
  self:MoveAbs(sx, sy)
  
  Local flagx = IIf(sx-ex=0, False, True)
  Local flagy = IIf(sy-ey=0, False, True)
  If flagx And flagy
    seq.tweenIDx = tween.start(node.runtime, self, { x = node.endpos.x + node.endoffset.x }, node.modex, Function() EndFunction)
    seq.tweenIDy = tween.start(node.runtime, self, { y = node.endpos.y + node.endoffset.y }, node.modey, Function() self:_NextPathNode() EndFunction)
  ElseIf Not(flagx) And Not(flagy)
    self:_NextPathNode()
  Else
    If flagx Then seq.tweenIDx = tween.start(node.runtime, self, { x = node.endpos.x + node.endoffset.x }, node.modex, Function() self:_NextPathNode() EndFunction)
    If flagy Then seq.tweenIDy = tween.start(node.runtime, self, { y = node.endpos.y + node.endoffset.y }, node.modey, Function() self:_NextPathNode() EndFunction)
  EndIf
EndFunction

Function GLFX.__NextPathNode(msg)
/******************************************************************************
GLFX.__NextPathNode(msg)
 
Utility for callback functions.
---------------------------------------------------------------------
INPUT
  msg       Message sent from the callback function
******************************************************************************/
  msg.userdata.Paths.PauseTimeoutID = Nil
  msg.userdata:_NextPathNode()
EndFunction

Function GLFX.Sprite:_NextPathNode()
/******************************************************************************
GLFX.SimpleSprite:_NextPathNode()

Function used by the PathSequences handling routines.
******************************************************************************/
  Local seq = self.Paths
  
  If TB.Item.Exists(seq, "pausetimeoutid") Then seq.PauseTimeoutID = Nil

  seq.currentNode = seq.currentNode + 1
  
  If seq.currentNode > seq.currentSequence.nodeCount-1
    If seq.currentSequence.Loop
      seq.currentNode = 0
    Else
      seq.currentSequence.onEnd(self)
      Return()
    EndIf
  EndIf
  
  ;| Execute the node
  Local node = seq.currentSequence.Nodes[seq.currentNode]

  ;| Check Special Commands
  If GetType(node.startpos) = #STRING
    Local splitted = SplitStr(node.startpos, ":")
    Switch splitted[0]
      Case "JUMPNODE"
        seq.currentNode = ToNumber(splitted[1])-1
        self:_NextPathNode()
        Return()
        
      Case "JUMPSEQ"
        seq:SetSequence(splitted[1])
        self:PathStart()
        
        Return()
        
      Case "PAUSE"
        seq.PauseTimeoutID = SetTimeout(Nil, GLFX.__NextPathNode, ToNumber(splitted[1]), self)
        Return()
        
    EndSwitch
  EndIf
  
  ; Start movement tween
  Local sx, sy, ex, ey = node.startpos.x+node.startoffset.x, node.startpos.y+node.startoffset.y, node.endpos.x+node.endoffset.y, node.endpos.y+node.endoffset.y
  self:MoveAbs(sx, sy)
  
  Local flagx = IIf(sx-ex=0, False, True)
  Local flagy = IIf(sy-ey=0, False, True)
  If flagx And flagy
    seq.tweenIDx = tween.start(node.runtime, self, { x = node.endpos.x + node.endoffset.x }, node.modex, Function() EndFunction)
    seq.tweenIDy = tween.start(node.runtime, self, { y = node.endpos.y + node.endoffset.y }, node.modey, Function() self:_NextPathNode() EndFunction)
  ElseIf Not(flagx) And Not(flagy)
    self:_NextPathNode()
  Else
    If flagx Then seq.tweenIDx = tween.start(node.runtime, self, { x = node.endpos.x + node.endoffset.x }, node.modex, Function() self:_NextPathNode() EndFunction)
    If flagy Then seq.tweenIDy = tween.start(node.runtime, self, { y = node.endpos.y + node.endoffset.y }, node.modey, Function() self:_NextPathNode() EndFunction)
  EndIf
  
EndFunction

Function GLFX.Sprite:PathStop()
/******************************************************************************
GLFX.SimpleSprite:PathStop()

Stops the running PathSequence movement.
******************************************************************************/
  Local seq = self.Paths
  
  If TB.Item.Exists(seq, "tweenIDx") Then tween.stop(seq.tweenIDx, False)
  If TB.Item.Exists(seq, "tweenIDy") Then tween.stop(seq.tweenIDy, False)
EndFunction

Function GLFX.Sprite:SetPolyCollision(PolyObject)
  ; Attach a polygon to the sprite for collision detections
  
  ; PolyObject = Object created with G2D.Poly:New(params)
  ; Visible = True to make the polygon visible
  
  self.Collisions.WithSprites.PolyColl = CopyTable(PolyObject)
  self.Collisions.WithSprites.PolyCollClone = CopyTable(PolyObject)
  self.Collisions.WithSprites.PolyColl.ScaleW = 1
  self.Collisions.WithSprites.PolyColl.ScaleH = 1
  self.Collisions.WithSprites.PolyColl.AnchorX = 0 ;self.anchorX
  self.Collisions.WithSprites.PolyColl.AnchorY = 0; self.AnchorY
  self.Collisions.WithSprites.PolyColl.Angle = 0
  self.Collisions.WithSprites.PolyColl.X = self.x
  self.Collisions.WithSprites.PolyColl.Y = self.y
  
  
EndFunction

Function GLFX.Sprite:EnablePolyCollision(value, spriteList, events)
  ; Wthin sprite list you can specify also group namesù
  
  self.Collisions.WithSprites.Enabled = value
  self.Collisions.WithSprites.Collide = {}
  If IsNil(spriteList)
    self.Collisions.WithSprites.SpriteList = {}
  Else
    self.Collisions.WithSprites.SpriteList = spriteList
  EndIf
  
  If Not(IsNil(events))
    If TB.Item.Exists(events, "oncollision")
      If GetType(events.OnCollision) <> #FUNCTION
        self.Collisions.WithSprites.Events.OnCollision = Function() EndFunction
      Else
        self.Collisions.WithSprites.Events.OnCollision = events.OnCollision
      EndIf
    EndIf
    If TB.Item.Exists(events, "oncollisionstart")
      If GetType(events.OnCollisionStart) <> #FUNCTION
        self.Collisions.WithSprites.Events.OnCollisionStart = Function() EndFunction
      Else
        self.Collisions.WithSprites.Events.OnCollisionStart = events.OnCollisionStart
      EndIf
    EndIf
    If TB.Item.Exists(events, "oncollisionend")
      If GetType(events.OnCollisionEnd) <> #FUNCTION
        self.Collisions.WithSprites.Events.OnCollisionEnd = Function() EndFunction
      Else
        self.Collisions.WithSprites.Events.OnCollisionEnd = events.OnCollisionEnd
      EndIf
    EndIf
  EndIf

EndFunction

Function GLFX.Sprite:EnablePolyCollisionRender(Render)
  
  self.Collisions.WithSprites.PolyRender = Render
  
EndFunction

Function GLFX.TEST()
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::: ENGINE TEST ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
;::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
  Local prefs = { width = 1024, height = 600, FlipSync = False, FPS = 120 }
  Local menu = 
    { { "01 : SCENE SETUP",         { "Setup an empty scene, nothing interesting, just a test." } },
      { "02 : BACKGROUND IMAGE",    { "Setup a sprite as a background using the [u]:Resize()[/u] method." } },
      { "03 : SPRITE / Clone",      { "Load a sprite and clone it for 49 times.",
                                      "Hit + to add clones."} },
      { "04 : SPRITE / Actions",    { "Actions are callback functions that can be attached to sprites and are called regurarly or at predefined timeouts.",
                                      "This test uses an [u]interval[/u] action to move and clone a sprite, the cloned sprite will also have the",
                                      "action defined in the source sprite." } },
      { "05 : SPRITE / Fade Fx",    { "The fade effect is used to smoothly change the sprite's colors. This test demonstrates this effect applied to 10",
                                      "sprites, fades follow a list of one or more colors each with a custom transition time. After 20 seconds the effect",
                                      "will be switched off on all sprites." } },
      { "06 : SPRITE / Angle Fx",   { "The angle fx is used to smoothly rotate a sprite. This test demonstrates this effect on 10 sprites, each one with a",
                                      "different setup, after 20 seconds the effect will be switched off on all sprites." } },
      { "07 : SPRITE / Stretch Fx", { "The stretch fx is used to smoothly change the sprite's size. This test demonstrates the stretch fx on 10 sprites,",
                                      "each one with a different setup, after 20 seconds the effect will be switched off on all sprites." } },
      { "08 : SPRITE / Blink",      { "The blink method is used to change instantly the sprite's color, after a given time the original color will be restored.",
                                      "This is useful for make the sprite blink, for example, to hiligh collisions." } },
      { "09 : SPRITE / Flash",      { "The flash effect is a configurable color changer that can alternate the original color of the sprite with a given one.",
                                      "The effect can be tuned specifing the duration of the 'off' color and the duration of the 'on' color. You can also",
                                      "specify a timeout to switch off the effect automatically."} },
      { "10 : SPRITE / Parallax Item",
                                    { "A parallax item is a sprite that automatically moves vertically or horizontally in the scene, when it reaches the screen",
                                      "boundary it will be moved to the starting position and this loop is repeated forever." } },
      { "11 : SPRITE / Parallax Strip",
                                    { "A parallax strip creates the classic parallax effect using a single sprite and repeating it in the scene. Parallax",
                                      "effect is great for depth effects in 2d games." } },
      { "12 : SPRITE / Attach to Mouse",
                                    { "The method :AttachToMouse() allow you to easily attach a sprite to the mouse pointer, you can specify an offset and",
                                      "an update rate to keep your sprite synchronized with the mouse pointer." } },
      { "13 : SPRITE / Follow",     { "You can make a sprite follow a target using the :FollowStart() method, you can specify an update rate, the follower speed,",
                                      "the easing used to move the follower and other ineresting partameters to customize the follow action." } },
      { "14 : SPRITE / Orbit",      { "The :OrbitStart() method allow you to make a sprite orbit around a target, you can select if the orbiter should face",
                                      "the current direction along other parameters like distance and update rate." } },
      { "15 : SPRITE / Attach",     { "Using the :Attach() method you can attach a sprite to any other target." } },
      { "16 : SPRITE / Boundaries", { "Boundaries can be defined for each sprite so that it never exceed it's allowed area." } },
      { "17 : SPRITE / Y Sorting",  { "GLFX allow you to sort the rendering order of the sprite on the y coordinate, this make really easy to build pseudo 3d,",
                                      "scenes, like isometric views, with GLFX. You can also have y sorting on each layer." } },
      { "18 : SPRITE / Y Sorting, Forced",
                                    { "Somatimes you may need to force the y sorting for example with sprites moved using a tween, this is option is to force,",
                                      "the y sorting for all the existing sprites." } },
      { "19 : SPRITE / Y Sorting, Y Target",
                                    { "Sometimes you may want to assign the same y sorting order of a sprite to a given target." } },
      { "20 : SPRITE / Collisions with mouse", 
                                    { "A brief demonstration to show collisions between sprites and the mouse pointer." } },
      { "21 : PARTICLES / Particle Systems",
                                    { "Here is an example of multiple particle systems with gravity and layering enabled." } },
      { "22 : PARTICLES / Particle Systems Fun",
                                    { "Some animated Particle Systems in action!" } },
      { "23 : SPRITE / From Text",  { "This example shows how easy is the creation of sprites from a text string." } },
      { "24 : SPRITE / Path",       { "Sprite's paths demonstration." } },
      { "25 : SPRITE / Collisions", { "Sprite's collisions demonstration." } }
      }

  ; Build the menu
  Local fw = GLFX:New(
    { Display  = 1, 
      Width    = prefs.Width,
      Height   = Prefs.Height,
      FlipSync = Prefs.FlipSync,
      FPS      = Prefs.FPS,
      Title    = "GLFX DEMO",
      })
      
  fw:Init()

  ; A simple function to manage the ESC key
  Local checkESC = Function()
                    If IsKeyDown("ESC")
                      While IsKeyDown("ESC")
                        Wait(5)
                      Wend
                      fw:ChangeScene("menu", 0) 
                    EndIf
                   EndFunction
                        
  /************************/
  /*** 01 : SCENE SETUP ***/
  /************************/
  Local scene01 = fw.Scene:New()
  scene01:Setup(
    { Name   = "01 Scene Setup",
      Init   = Function() EndFunction,
      UnInit = Function() EndFunction,
      Clear  = Function() EndFunction,
      Render = Function() EndFunction,
      Update = Function() checkESC() EndFunction })
  fw:AddScene(scene01)
  
  /*****************************/
  /*** 02 : BACKGROUND IMAGE ***/
  /*****************************/
  Local scene02 = fw.Scene:New()
  scene02:Setup(
    { Name   = "02 Background Image",
      Init   = Function(scene)
                 ; Common variables
                 Local bgFile = "glfx_test/BG_800x600.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(prefs.width, Nil, True)
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkESC() EndFunction })
      
  fw:AddScene(scene02)
  
  /***************************/
  /*** 03 : SPRITE / CLONE ***/
  /***************************/
  Local scene03 = fw.Scene:New()
  scene03:Setup(
    { ; SCENE NAME
      Name   = "03 Sprite / Clone", 
    
      ; SCENE INITIALIZATION CALLBACK
      ; Load and setup the background and a single sprite that will be
      ; initially cloned 49 times.
      Init   = 
        Function(scene)
          ; Message for the stats screen
          fw.UserMessage = "Hit + to add clones."
          ; Define resources
          Local bgFile = "glfx_test/BG_800x600.jpg"
          Local spriteFile = "glfx_test/small_planet.png"
          ; Define a new sprite engine
          scene.SpriteEngine = fw.SpriteEngine:Create(fw)
          scene.SpriteEngine:YSort_Set(False, False)
          ; Load and setup a static background
          scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, AnchorY = 0 })
          scene.Background:Resize(prefs.width, Nil, True)
          ; Create one sprite that will be cloned
          scene.Sprites = {}
          scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
          scene.Sprites[0]._Speed = RndF()
          For Local i = 1 To 49
            scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
            scene.Sprites[i]._Speed = RndF()
          Next
          scene.clonesCount = 49
        EndFunction,
      
      ; SCENE UNINITIALIZATION CALLBACK
      ; Simply destroy the sprite engine and all its resources
      UnInit = 
        Function(scene) scene.SpriteEngine:Destroy() EndFunction,
      
      ; CLEAR SCENE CUSTOM CODE
      Clear  = 
        Function() EndFunction,
      
      ; SCENE RENDER CODE
      ; Draw all sprite engine's items
      Render = 
        Function(scene)
          scene.SpriteEngine:All_DrawUnorderedLayered()
        EndFunction,
               
      ; SCENE UPDATE CODE
      ; Called before every render, here we updates all our sprites manually
      ; and we will check for keypresses.
      ; Updating the coordinates here in this way it's not a good idea because on
      ; slow systems the target FPS could be violated resulting in a wrong movement
      ; a good way could be to use the :MoveTo() method or use directly a tween
      ; to move the objcts.
      Update = 
        Function(scene)
          ; Check for th e + key
          If IsKeyDown("+")
            Local i = scene.clonesCount + 1
            scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
            scene.Sprites[i]._Speed = RndF()
            scene.clonesCount = i
          EndIf
         
          ; Updates all planet sprites
          For _, s In IPairs(scene.Sprites) Do s:MoveRel(s._Speed, 0, True)

          ; Check for the ESCAPE key
          checkESC()

        EndFunction
    }
  )

  ; ADD THE SCENE TO THE FRAMEWORK
  fw:AddScene(scene03)

  /***************************/
  /*** 04 SPRITE / ACTIONS ***/
  /***************************/
  Local scene04 = fw.Scene:New()
  scene04:Setup(
    { ; SCENE NAME
      Name   = "04 Sprite / Actions",
      
      ; SCENE INITIALIZATION CALLBACK
      ; Load and setup the background and a sprite that will be used as
      ; the one that will be cloned.
      Init   = 
        Function(scene)
          ; Message for the stats screen
          fw.UserMessage = "-- RECURSIVE ACTIONS --"
          ; Define resources
          Local bgFile = "glfx_test/BG_800x600.jpg"
          Local spriteFile = "glfx_test/small_planet.png"
          ; Define a new sprite engine
          scene.SpriteEngine = fw.SpriteEngine:Create(fw)
          scene.SpriteEngine:YSort_Set(False, False)
          ; Load and setup a static background
          scene.Background  = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
          scene.Background:Resize(prefs.width, Nil, True)
          ; Create one sprite that will be cloned after 4 seconds
          scene.Sprites = {}
          scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { name = "Sprite 0", x = 512, y = 300, blendEnabled = True })
          ; Now we are attaching to the source sprite an interval action to
          ; move the sprite around the screen using two tweens. The interval function
          ; will be called every 4 seconds.
          
          ; Let's use a simple counter to limit the cloning
          scene.Sprites[0].Engine.cloneCount = 0
          scene.Sprites[0]:ActionAdd(
            { name  = "Sprite Mover",
              atype = #SE_ATYPE_INTERVAL,
              args  = 2500,
              func  = 
                Function(msg)
                  ; This little pest will clone itself every movement!
                  If msg.userdata.Sprite.Engine.cloneCount > 32
                    ; Stop duplicating!
                    fw.UserMessage = "-- LIMIT REACHED : STOP DUPLICATING --"
                  Else
                    ; Clone it!
                    Local cloned = msg.userdata.Sprite:Clone()
                    cloned.Engine.cloneCount = cloned.Engine.cloneCount + 1
                    cloned.Color = { RndF(), RndF(), RndF(), 1 }    
                    ; Move the cloned sprite
                    tween.start(2400, cloned, { x = Rnd(prefs.width) }, "outsine" )
                    tween.start(2400, cloned, { y = Rnd(prefs.height) }, "insine" )
                    
                  EndIf
                  
                  ; Move the source sprite
                  tween.start(2400, msg.userdata.Sprite, { x = Rnd(prefs.width) }, "outsine" )
                  tween.start(2400, msg.userdata.Sprite, { y = Rnd(prefs.height) }, "insine" )
                EndFunction 
              })   

        EndFunction,
      
      ; SCENE UNINITIALIZATION CALLBACK
      ; Destroy the sprite angine and all its sprites
      UnInit = 
        Function(scene) scene.SpriteEngine:Destroy() EndFunction,
        
      ; CLEAR SCENE
      Clear  = 
        Function() EndFunction,
      
      ; SCENE RENDER CODE
      ; Draw all sprites
      Render = 
        Function(scene)
          scene.SpriteEngine:All_DrawUnordered()
        EndFunction,
        
      ; SCENE UPDATE CODE
      ; Check for key presses before each rendering
      Update = 
        Function(scene) checkESC() EndFunction,
      })

  ; ADD THE SCENE TO THE FRAMEWORK
  fw:AddScene(scene04)

  /***************************/
  /*** 05 : Sprites / Fade ***/
  /***************************/
  Local scene05 = fw.Scene:New()
  scene05:Setup(
    { Name   = "05 Sprite / Fade",
      Init   = Function(scene)
                 ; Define a sprite engine
                 Local bgFile = "glfx_test/BG_800x600.jpg"
                 Local spriteFile = "glfx_test/planet.png"
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
                 scene.Background:Resize(prefs.width, Nil, True)
          
                 ; Create one sprite that will be cloned
                 scene.Sprites = {}
                 scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
                 scene.Sprites[0]._Speed = RndF()
                 For Local i = 1 To 9
                   scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
                   scene.Sprites[i]._Speed = RndF()
                   Local colorlist, timings = {}, {}
                   For Local k = 0 To Rnd(9)+1
                     InsertItem(colorlist, { RndF(), RndF(), RndF(), RndF() })
                     InsertItem(timings, Rnd(2000)+1000)
                   Next
 
                   scene.Sprites[i]:Fader(
                     { ColorList = colorlist, Timings = timings, Loop = True, Easing = "outsine" })
                 Next
          
                 ; After 20 seconds stop all fades
                 SetTimeout(
                   Nil, 
                   Function()
                     For Local k = 0 To 9 Do scene.Sprites[k]:FadeStop()
                   EndFunction,
                 20000)
               EndFunction,
      UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 ; Draw all defined sprites
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function(scene)
                 checkESC()
                 ; Updates all planet sprites
                 For Local i = 0 To 9
                   scene.Sprites[i].x = scene.Sprites[i].x + scene.Sprites[i]._Speed
                   If scene.Sprites[i].x > prefs.width+128 Then scene.Sprites[i].x = -128
                 Next
               EndFunction })

  fw:AddScene(scene05)


  ;****************************
  ;*** 06 : Sprites / Angle ***
  ;****************************
  Local scene06 = fw.Scene:New()
  scene06:Setup(
    { Name   = "06 Sprite / Angle",
      Init   = Function(scene)
                 ; Define a sprite engine
                 Local bgFile = "glfx_test/BG_800x600.jpg"
                 Local spriteFile = "glfx_test/planet.png"
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
                 scene.Background:Resize(prefs.width, Nil, True)
          
                 ; Create one sprite that will be cloned
                 scene.Sprites = {}
                 scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
                 scene.Sprites[0]._Speed = RndF()
                 scene.Sprites[0].AnchorX = 0.5
                 scene.Sprites[0].AnchorY = 0.5
                 scene.Sprites[0].angleEnabled = True
                 For Local i = 1 To 9
                   scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
                   scene.Sprites[i]._Speed = RndF()
                   scene.Sprites[0].AnchorX = 0.5
                   scene.Sprites[0].AnchorY = 0.5
                   scene.Sprites[0].angleEnabled = True
                   Local anglelist, timings = {}, {}
                   For Local k = 0 To Rnd(9)+1
                     InsertItem(anglelist, Rnd(360))
                     InsertItem(timings, Rnd(2000)+1000)
                   Next
                   scene.Sprites[i]:Rotator(
                     { AngleList = anglelist, Timings = timings, Loop = True, Easing = "inquad" })
                 Next
          
                 ; After 20 seconds stop all fades
                 SetTimeout(
                   Nil, 
                   Function()
                     For Local k = 0 To 9 Do scene.Sprites[k]:RotateStop()
                   EndFunction,
                   20000)
               EndFunction,
      UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 ; Draw all defined sprites
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function(scene)
                 checkESC()
                 ; Updates all planet sprites
                 For Local i = 0 To 9
                   scene.Sprites[i].x = scene.Sprites[i].x + scene.Sprites[i]._Speed
                   If scene.Sprites[i].x > prefs.width+128 Then scene.Sprites[i].x = -128
                 Next
               EndFunction })

  fw:AddScene(scene06)

  ;******************************
  ;*** 07 : Sprites / Stretch ***
  ;******************************
  Local scene07 = fw.Scene:New()
  scene07:Setup(
    { Name   = "07 Sprite / Stretch",
      Init   = Function(scene)
                 ; Define a sprite engine
                 Local bgFile = "glfx_test/BG_800x600.jpg"
                 Local spriteFile = "glfx_test/planet.png"
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
                 scene.Background:Resize(1024, Nil, True)
                 
                 ; Create one sprite that will be cloned
                 scene.Sprites = {}
                 scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
                 scene.Sprites[0]._Speed = RndF()
                 scene.Sprites[0].AnchorX = 0.5
                 scene.Sprites[0].AnchorY = 0.5

                 For Local i = 1 To 9
                   scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
                   scene.Sprites[i]._Speed = RndF()
                   scene.Sprites[0].AnchorX = 0.5
                   scene.Sprites[0].AnchorY = 0.5
                   Local stretchlist, timings = {}, {}
                   For Local k = 0 To Rnd(9)+1
                     InsertItem(stretchlist, { RndF()*3, RndF()*3 })
                     InsertItem(timings, Rnd(2000)+1000)
                   Next
                   scene.Sprites[i]:Stretcher(
                     { StretchList = stretchlist, Timings = timings, Loop = True, Easing = "outbounce" })
                 Next
          
                 ; After 20 seconds stop all fades
                 SetTimeout(
                   Nil, 
                   Function()
                     For Local k = 0 To 9 Do scene.Sprites[k]:StretchStop()
                   EndFunction,
                   20000)
               EndFunction,
      UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 ; Draw all defined sprites
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function(scene)
                 checkESC()
                 ; Updates all planet sprites
                 For Local i = 0 To 9
                   scene.Sprites[i].x = scene.Sprites[i].x + scene.Sprites[i]._Speed
                   If scene.Sprites[i].x > prefs.width+128 Then scene.Sprites[i].x = -128
                 Next
               EndFunction })

  fw:AddScene(scene07)
  

;****************************
;*** 08 : Sprites / Blink ***
;****************************
Local scene08 = fw.Scene:New()
scene08:Setup(
  { Name   = "08 Sprite / Blink",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile = "glfx_test/planet.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(prefs.width, Nil, True)
              
               ; Create one sprite that will be cloned
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
               scene.Sprites[0]._Speed = RndF()
               scene.Sprites[0].AnchorX = 0.5
               scene.Sprites[0].AnchorY = 0.5
               For Local i = 1 To 9
                 scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
                 scene.Sprites[i]._Speed = RndF()
                 scene.Sprites[0].AnchorX = 0.5
                 scene.Sprites[0].AnchorY = 0.5
                
                 scene.Sprites[i]:Blink(
                   { Color = { RndF(), RndF(), RndF(), 1 }, Time = Rnd(1500)*2 })
               Next
             EndFunction,
    
    UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function(scene)
               checkESC()
               ; Updates all planet sprites
               For Local i = 0 To 9
                 scene.Sprites[i].x = scene.Sprites[i].x + scene.Sprites[i]._Speed
                 If scene.Sprites[i].x > prefs.width+128 Then scene.Sprites[i].x = -128
               Next
             EndFunction })

fw:AddScene(scene08)


;****************************
;*** 09 : Sprites / Flash ***
;****************************
Local scene09 = fw.Scene:New()
scene09:Setup(
  { Name   = "09 Sprite / Flash",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile = "glfx_test/planet.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(prefs.width, Nil, True)
              
               ; Create one sprite that will be cloned
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile, scene.SpriteEngine, { x = 512, y = 300, blendEnabled = True })
               scene.Sprites[0]._Speed = RndF()
               scene.Sprites[0].AnchorX = 0.5
               scene.Sprites[0].AnchorY = 0.5
               For Local i = 1 To 9
                 scene.Sprites[i] = scene.Sprites[0]:Clone({ x = Rnd(prefs.width-64), y = Rnd(prefs.height-64)})
                 scene.Sprites[i]._Speed = RndF()
                 scene.Sprites[0].AnchorX = 0.5
                 scene.Sprites[0].AnchorY = 0.5
                
                 scene.Sprites[i]:Flash(
                   { Color = { RndF(), RndF(), RndF(), RndF() }, UpdateRate = 20, OnTime = Rnd(50)*20, OffTime = Rnd(50)*20, Timeout = Rnd(20000)+2000 })
               Next
             EndFunction,
    UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function(scene)
               checkESC()
               ; Updates all planet sprites
               For Local i = 0 To 9
                 scene.Sprites[i].x = scene.Sprites[i].x + scene.Sprites[i]._Speed
                 If scene.Sprites[i].x > prefs.width+128 Then scene.Sprites[i].x = -128
               Next
             EndFunction })

fw:AddScene(scene09)


;************************************
;*** 10 : Sprites / Parallax Item ***
;************************************
Local scene10 = fw.Scene:New()
scene10:Setup(
  { Name   = "10 Sprite / Parallax Item",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 0, x = Rnd(prefs.width), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:ParallaxItem({ horizontal = True, position = 130, stride = -0.05, rateMS = 10 })
               scene.Sprites[1]:ParallaxItem({ horizontal = True, position = 180, stride = -0.10, rateMS = 10 })
              
               Local y, scale, speed = 400, 0.20, 0.01
               For Local i = 2 To 59
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 2, x = Rnd(1024), scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxItem({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + i*4
                 scale = 0.20 + i*0.02
                 speed = 0.01 + i*0.01
               Next
             EndFunction,
    
    UnInit = Function(scene) scene.SpriteEngine:Destroy() EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene10)


;*************************************
;*** 11 : Sprites / Parallax Strip ***
;************************************* 
Local scene11 = fw.Scene:New()
scene11:Setup(
  { Name   = "11 Sprite / Parallax Strip",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(prefs.width, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 0, x = Rnd(prefs.width), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:ParallaxItem({ horizontal = True, position = 130, stride = -0.02, rateMS = 10 })
               scene.Sprites[1]:ParallaxItem({ horizontal = True, position = 180, stride = -0.05, rateMS = 10 })
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-3)*speed*10
                 scale = 0.20 + (i-3)*0.05
                 speed = 0.10 + (i-3)*0.05
               Next
              
             EndFunction,
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
               scene.SpriteEngine = Nil
               scene.Background   = Nil
               scene.Sprites      = Nil
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

    fw:AddScene(scene11)

;**************************************
;*** 12 : Sprites / Attach to Mouse ***
;**************************************
Local scene12 = fw.Scene:New()
scene12:Setup(
  { Name   = "12 Sprite / Attach to mouse",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(prefs.width, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 0, x = Rnd(prefs.width), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 250, offset = { x = 200, y = -100 }})
               scene.Sprites[1]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 4, x = -Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next      
               scene.Sprites[15]:AttachToMouse({ updateRate = 10, offset = { x = Nil, y = 0 }})
              
             EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene12)

      
;*****************************
;*** 13 : Sprites / Follow ***
;*****************************
Local scene13 = fw.Scene:New()
scene13:Setup(
  { Name   = "13 Sprite / Follow",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteFile3 = "glfx_test/arrowed.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(prefs.width, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
              
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 0, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next
              
               Local easing = { "linear", "inoutquad", "inoutquart", "outinquint", "outinsine", "inoutback", "outbounce" }
               Local ur = 20
               For Local i = 16 To 20
                 Local scale = RndF() + 0.3
                 If scale > 1 Then scale = 1
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { scaleW = scale, scaleH = scale, Layer = 2, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True })
                 scene.Sprites[i]:FollowStart({ updateRate = ur, target = scene.Sprites[0], speed = 250, easing = easing[Rnd(7)], continuos = True, facedirection = True, angleoffset = 90 })
               Next
               ur = 10
               For Local i = 21 To 25
                 Local scale = RndF() + 0.3
                 If scale > 1 Then scale = 1
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { scaleW = scale, scaleH = scale, Layer = 2, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True })
                 scene.Sprites[i]:FollowStart({ updateRate = ur, target = scene.Sprites[0], speed = 150, easing = easing[Rnd(7)], continuos = False, facedirection = True, angleoffset = 90 })
               Next 
             EndFunction,
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene13)


;****************************
;*** 14 : Sprites / Orbit ***
;****************************
Local scene14 = fw.Scene:New()
scene14:Setup(
  { Name   = "14 Sprite / Orbit",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteFile3 = "glfx_test/arrowed.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
              
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 4, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next
              
               Local easing = { "linear", "inoutquad", "inoutquart", "outinquint", "outinsine", "inoutback", "outbounce" }
               Local ur = 20
               For Local i = 16 To 20
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { Layer = 5, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
                 scene.Sprites[i]:OrbitStart({ updateRate = ur, target = scene.Sprites[0], time = Rnd(5000) + 3000, direction = -1, distance = Rnd(150)+150, easing = easing[Rnd(7)], startAngle = 0, faceTarget = True, angleoffset = 90 })
               Next
              
               For Local i = 21 To 25
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { Layer = 5, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
                 scene.Sprites[i]:OrbitStart({ updateRate = ur, target = scene.Sprites[0], time = Rnd(5000) + 3000, direction = 1, distance = Rnd(50)+100, easing = easing[Rnd(7)], startAngle = 180, faceTarget = False, angleoffset = 90 })
               Next
             EndFunction,
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene14)


;***************************************
;*** 15 : Sprites / Attach to Object ***
;***************************************
Local scene15 = fw.Scene:New()
scene15:Setup(
  { Name   = "15 Sprite / Attach",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
               scene.Sprites[16] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 2, x = Rnd(1024), blendEnabled = True, scaleW = 0.25, scaleH = 0.25 })              
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 4, x = Rnd(1024), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 5, x = Rnd(1024), blendEnabled = True })
               scene.Sprites[1]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
               scene.Sprites[0]:Attach({ updateRate = 20, offset = { x = 250, y = 0 }, target = scene.Sprites[1]})
               scene.Sprites[16]:Attach({ updateRate = 20, offset = { x = 150, y = 50 }, target = scene.Sprites[0]})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 4, x = -Rnd(1024), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next      
               scene.Sprites[15]:Attach({ updateRate = 10, offset = { x = Nil, y = -50 }, target = scene.Sprites[16]})
              
             EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
              scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene15)


;*********************************
;*** 16 : Sprites / Boundaries ***
;*********************************
Local scene16 = fw.Scene:New()
scene16:Setup(
  { Name   = "16 Sprite / Boundaries",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteFile3 = "glfx_test/arrowed.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               ; Parallax items
               scene.Sprites = {}
              
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 0, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next
              
               Local ur = 10
               For Local i = 16 To 18
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { Layer = 5, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True, scaleW = 0.25, scaleH = 0.25 })
                 scene.Sprites[i]:OrbitStart({ updateRate = ur, target = scene.Sprites[0], time = Rnd(3000) + 1000, direction = -1, distance = Rnd(150)+150, easing = "linear", startAngle = 0, faceTarget = True, angleoffset = 90 })
                 scene.Sprites[i]:SetBoundaries({ top = 200, bottom = 400, left = 100, right = 924 })
               Next
              
               For Local i = 19 To 21
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { Layer = 5, x = Rnd(prefs.width), y = Rnd(prefs.height), blendEnabled = True, scaleW = 0.25, scaleH = 0.25 })
                 scene.Sprites[i]:OrbitStart({ updateRate = ur, target = scene.Sprites[0], time = Rnd(3000) + 1000, direction = 1, distance = Rnd(50)+100, easing = "linear", startAngle = 180, faceTarget = True, angleoffset = 90 })
                 scene.Sprites[i]:SetBoundaries({ top = 100, bottom = 500, left = 300, right = 724 })
               Next
             EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene16)


;**********************
;*** 17 : Y Sorting ***
;**********************
Local scene17 = fw.Scene:New()
scene17:Setup(
  { Name   = "17 Sprite / Y Sorting",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.SpriteEngine:YSort_Set(True, False)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(Prefs.width), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 20, offset = { x = 200, y = -50 }})
               scene.Sprites[1]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next      
              
             EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = 
      Function(scene)
        ; Draw all defined sprites
        scene.SpriteEngine:All_DrawOrdered()
      EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene17)



;*****************************
;*** 18 : Y Sorting Forced ***
;*****************************
Local scene18 = fw.Scene:New()
scene18:Setup(
  { Name   = "18 Sprite / Y Sorting, forced",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               Local spriteArrow = "glfx_test/arrowed.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.SpriteEngine:YSort_Set(False, True)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(prefs.width), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 15, offset = { x = 250, y = -50 }})
               scene.Sprites[1]:AttachToMouse({ updateRate = 15, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(prefs.width), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next    
              
               scene.Sprites[16] = fw.Sprite:Load(spriteArrow, scene.SpriteEngine, { name = "orb", Layer = 3, x = Rnd(1024), y = Rnd(600), blendEnabled = True })
               scene.Sprites[16]:OrbitStart({ updateRate = 10, target = scene.Sprites[1], time = 8000, direction = -1, distance = 200, easing = "linear", startAngle = 0, faceTarget = True, angleoffset = 90 })
               scene.Sprites[17] = fw.Sprite:Load(spriteArrow, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), y = Rnd(600), blendEnabled = True, scaleW = 0.4, scaleH = 0.4 })
               scene.Sprites[17]:OrbitStart({ updateRate = 10, target = scene.Sprites[0], time = 5000, direction = -1, distance = 100, easing = "linear", startAngle = 0, faceTarget = True, angleoffset = 90 })
             EndFunction,
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawOrdered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene18)

      
     
     
;********************************************
;*** 19 : Y Sorting Forced / YSort Target ***
;********************************************
Local scene19 = fw.Scene:New()
scene19:Setup(
  { Name   = "19 Sprite / Y Sorting, Y Target",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               Local spriteArrow = "glfx_test/arrowed.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.SpriteEngine:YSort_Set(False, True)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               scene.Sprites = {}
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
               scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), blendEnabled = True })
               scene.Sprites[0]:AttachToMouse({ updateRate = 20, offset = { x = 250, y = -50 }})
               scene.Sprites[1]:AttachToMouse({ updateRate = 20, offset = { x = 0, y = 0 }})
              
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next    
              
               scene.Sprites[16] = fw.Sprite:Load(spriteArrow, scene.SpriteEngine, { name = "orb", Layer = 3, x = Rnd(1024), y = Rnd(600), blendEnabled = True })
               scene.Sprites[16]:OrbitStart({ updateRate = 20, target = scene.Sprites[1], time = 8000, direction = -1, distance = 200, easing = "linear", startAngle = 0, faceTarget = True, angleoffset = 90 })
               scene.Sprites[16]:YSortTarget(scene.Sprites[1])
               scene.Sprites[17] = fw.Sprite:Load(spriteArrow, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), y = Rnd(600), blendEnabled = True, scaleW = 0.4, scaleH = 0.4 })
               scene.Sprites[17]:OrbitStart({ updateRate = 20, target = scene.Sprites[0], time = 5000, direction = -1, distance = 100, easing = "linear", startAngle = 0, faceTarget = True, angleoffset = 90 })
               scene.Sprites[17]:YSortTarget(scene.Sprites[0])
              
             EndFunction,
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawOrdered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene19)



;****************************************
;*** 20 : Collisions : Sprite / Mouse ***
;****************************************
Local scene20 = fw.Scene:New()
scene20:Setup(
  { Name   = "20 Sprite / With Mouse",
    Init   = Function(scene)
               ; Define a sprite engine
               Local bgFile = "glfx_test/BG_800x600.jpg"
               Local spriteFile1 = "glfx_test/planet.png"
               Local spriteFile3 = "glfx_test/arrowed.png"
               Local spriteTerrain = "glfx_test/i_parallax.png"
               Local spriteFile2 = "glfx_test/tree3.png"
               scene.SpriteEngine = fw.SpriteEngine:Create(fw)
               scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
               scene.Background:Resize(1024, Nil, True)
              
               scene.Sprites = {}
              
               scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 4, x = 512, y = 250, blendEnabled = True })
               scene.Sprites[0].AnchorX = 0.5
               scene.Sprites[0].AnchorY = 0.5
               scene.Sprites[0].scaleW = 0.5
               scene.Sprites[0].scaleH = 0.5
               scene.Sprites[0]:CollisionWithMouse(
                 { Enabled = True, Events =
                   { OnCollision = Function(sprite, cPoint)
                                     Local s1, s2 = IIf(Rnd(2)=1, -2, 2), IIf(Rnd(2)=1, -2, 2)
                                     sprite:Translate(Rnd(2)*s1, Rnd(2)*s2)
                                   EndFunction }})
                                  
               scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
               scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
               scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
               scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

               Local y, scale, speed = 400, 0.20, 0.10
               For Local i = 4 To 15
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 4, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
                 scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                 y = 400 + (i-4)*10
                 scale = 0.20 + (i-4)*0.05
                 speed = 0.10 + (i-4)*0.10
               Next
              
               Local easing = { "linear", "inoutquad", "inoutquart", "outinquint", "outinsine", "inoutback", "outbounce" }
               Local ur = 10
               For Local i = 16 To 20
                 scene.Sprites[i] = fw.Sprite:Load(spriteFile3, scene.SpriteEngine, { Layer = 5, x = Rnd(1024), y = Rnd(600), blendEnabled = True, scaleW = 0.5, scaleH = 0.5 })
                 scene.Sprites[i]:OrbitStart({ updateRate = ur, target = scene.Sprites[0], time = Rnd(5000) + 3000, direction = -1, distance = i*20-150, easing = easing[Rnd(7)], startAngle = 0, faceTarget = True, angleoffset = 90 })
                 scene.Sprites[i]:CollisionWithMouse(
                   { Enabled = True, Events =
                     { OnCollisionStart = Function(sprite, cPoint)                                      
                                            sprite.Color = { RndF(), RndF(), RndF(), 1.0 }
                                          EndFunction,
                       OnCollisionEnd   = Function(sprite, cPoint)                                      
                                            sprite.Color = { 1.0, 1.0, 1.0, 1.0 }
                                          EndFunction,
                                          }})
                
               Next
                            
             EndFunction,
          
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

    fw:AddScene(scene20)


    
;*****************************
;*** 21 : Particle Systems ***
;*****************************
Local scene21 = fw.Scene:New()
scene21:Setup(
  { Name   = "21 Particles / Particle Systems",
    Init   = 
      Function(scene)
        ; Define a sprite engine
        Local bgFile = "glfx_test/BG_800x600.jpg"
        Local spriteFile1 = "glfx_test/planet.png"
        Local spriteFile3 = "glfx_test/arrowed.png"
        Local spriteTerrain = "glfx_test/i_parallax.png"
        Local spriteFile2 = "glfx_test/tree3.png"
        Local blob1 = "glfx_test/nuvola.png"
        Local blob2 = "glfx_test/blob.png"
        
        scene.SpriteEngine = fw.SpriteEngine:Create(fw)

        scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
        scene.Background:Resize(1024, Nil, True)
        
        scene.Sprites = {}
        
        scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 1, x = 512, y = 250, blendEnabled = True })
                            
        scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
        scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
        scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
        scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

        Local y, scale, speed, layer = 400, 0.20, 0.10, 4
        For Local i = 4 To 15
          scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = layer, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
          scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
          y = 400 + (i-4)*10
          scale = 0.20 + (i-4)*0.05
          speed = 0.10 + (i-4)*0.10
          layer = layer + 1
        Next

        ; Particle systems
        scene.PartSys1 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            Emitter = { x = 700, y = 250, Rate = 15, quantity = 3 },
            ParticlesInfo = { angle = 250, anglevar = 360, velocity = 3, velocityvar = 0.5,
                              fade1 = { 0.0 , 1.0, 0, 0 },
                              fade2 = { 1.0, 1.0, 1.0, 1.0 },
                              life = 1000,
                              scale1 = 3.5, scale2 = 1.5 },
            Gravity = { x = -0.00, y = 0, velocity = 0.005 },
            Layer = 2,
            UpdateRate = 20,
            Textures = { Brushes = False, Items = { blob1 } },
            Inverted = True ; ***
            })

        scene.PartSys2 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            Emitter = { x = 600, y = 420, Rate = 20, quantity = 2 },
            ParticlesInfo = { angle = 260, velocity = 1.90, velocityvar = 0.75,
                              fade1 = { 0.0 , 0, 1, 1 }, fade2 = { 1.0 , 0, 0, 0 } },
            Layer = 5,
            UpdateRate = 20,
            Textures = { Brushes = False, Items = { blob1 } }
            })

        scene.PartSys3 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            UpdateRate = 20,
            Emitter = { x = 800, y = 490, Rate = 20, quantity = 2 },
            Gravity = { x = -0.02 },
            ParticlesInfo = { velocity = 1.8 },
            Layer = 10,
            Textures = { Brushes = False, Items = { blob2 } }
            })
        
        
      EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene21)


;*********************************
;*** 22 : Particle Systems Fun ***
;*********************************
Local scene22 = fw.Scene:New()
scene22:Setup(
  { Name   = "22 Particles / Particle Systems Fun",
    Init   = 
      Function(scene)
        ; Define a sprite engine
        Local bgFile = "glfx_test/BG_800x600.jpg"
        Local spriteFile1 = "glfx_test/planet.png"
        Local spriteFile3 = "glfx_test/arrowed.png"
        Local spriteTerrain = "glfx_test/i_parallax.png"
        Local spriteFile2 = "glfx_test/tree3.png"
        Local blob1 = "glfx_test/nuvola.png"
        Local blob2 = "glfx_test/blob.png"
        
        scene.SpriteEngine = fw.SpriteEngine:Create(fw)

        scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
        scene.Background:Resize(1024, Nil, True)
        
        scene.Sprites = {}
        
        scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 2, x = -1000, blendEnabled = True })
        scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
        scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
        scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

        Local y, scale, speed, layer = 400, 0.20, 0.10, 4
        For Local i = 4 To 15
          scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = layer, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
          scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
          y = 400 + (i-4)*10
          scale = 0.20 + (i-4)*0.05
          speed = 0.10 + (i-4)*0.10
          layer = layer + 1
        Next

        ; Particle systems
        scene.PartSys1 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            Emitter = { x = 400, y = 350, Rate = 10, quantity = 2 },
            ParticlesInfo = { angle = 250, velocity = 2,
                              fade2 = { 0.0 , 1.0, 0, 0 } },
            Gravity = { x = -0.005 },
            Layer = 2,
            UpdateRate = 15,
            Textures = { Brushes = False, Items = { blob1 } }
            })
        ; Move the particle system emitter
        scene.f1a = Function() tween.start(5000, scene.PartSys1.Emitter, { x = 1000 }, "linear", scene.f1b) EndFunction
        scene.f1b = Function() tween.start(5000, scene.PartSys1.Emitter, { x = 24 }, "outsine", scene.f1a) EndFunction
        scene.f1a()
        
        
        scene.PartSys2 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            Emitter = { x = 600, y = 250, Rate = 10, quantity = 1 },
            ParticlesInfo = { angle = 260, velocity = 1.90, velocityvar = 0.75,
                              fade1 = { 0.0 , 0, 1, 1 }, fade2 = { 1.0 , 0, 0, 0 } },
            Layer = 5,
            UpdateRate = 15,
            Textures = { Brushes = False, Items = { blob1 } }
            })
        ; Changes emission angle
        scene.f2a = Function() tween.start(5000, scene.PartSys2.ParticlesInfo, { angle = 0, scale2 = 0.2, scale1 = 8.0 }, "linear", scene.f2b) EndFunction
        scene.f2b = Function() tween.start(5000, scene.PartSys2.ParticlesInfo, { angle = 360, scale2 = 8.0, scale1 = 0.2 }, "linear", scene.f2a) EndFunction
        scene.f2a()
        
        scene.PartSys3 = GLFX.ParticleSystem:New(
          { SpriteEngine = scene.SpriteEngine,
            UpdateRate = 15,
            Emitter = { x = 800, y = 490, Rate = 10, quantity = 1 },
            Gravity = { x = -0.02 },
            ParticlesInfo = { velocity = 2.3, scale2 = 6 },
            Layer = 10,
            Textures = { Brushes = False, Items = { blob2 } }
            })
        ; Changes colors
        scene.f3a = Function() tween.start(2500, scene.PartSys3.ParticlesInfo, { velocity = 2.3, fade1 = { RndF(), RndF(), RndF(), 1.0 }, fade2 = { RndF(), RndF(), RndF(), 0.0 }}, "linear", scene.f3b) EndFunction
        scene.f3b = Function() tween.start(2500, scene.PartSys3.ParticlesInfo, { velocity = 4.0, fade1 = { RndF(), RndF(), RndF(), 1.0 }, fade2 = { RndF(), RndF(), RndF(), 0.0 }}, "linear", scene.f3a) EndFunction
        scene.f3a()
        
      EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawUnorderedLayered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene22)

      
;*******************************
;*** 23 : Sprite / From text ***
;*******************************
Local scene23 = fw.Scene:New()
scene23:Setup(
  { Name   = "23 Sprites / From Text",
    Init   = 
      Function(scene)
        ; Define a sprite engine
        Local bgFile = "glfx_test/BG_800x600.jpg"
        Local spriteFile1 = "glfx_test/planet.png"
        Local spriteTerrain = "glfx_test/i_parallax.png"
        Local spriteFile2 = "glfx_test/tree3.png"
        Local spriteArrow = "glfx_test/arrowed.png"
        scene.SpriteEngine = fw.SpriteEngine:Create(fw)
        scene.SpriteEngine:YSort_Set(False, True)
        scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
        scene.Background:Resize(1024, Nil, True)
        
        scene.Sprites = {}
        ;scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), blendEnabled = True })
        scene.sprites[0] = fw.Sprite:NewFromText(scene.SpriteEngine, { blendEnabled = True, Layer = 3, text = "[edge=$88FFFFFF,4][shadow=$44222222,12,#SHDWSOUTHWEST] Hello [color=$FF0000]World![/color]", textattrs = { }, splitted = False, textrawidth = 0, textraheight = 0, tstyle = #NORMAL, tfontname = "Arial", tfontsize = 150, tcolor = $FF00FF })
        scene.Sprites[0]:AttachToMouse({ updateRate = 10, offset = { x = 0, y = 0 }})
        scene.spritesList1 = fw.Sprite:NewFromText(scene.SpriteEngine, { blendEnabled = True, Layer = 3, text = "Hello World!", textattrs = { }, splitted = True, textrawidth = 0, textraheight = 0, tstyle = #BOLD, tfontname = "Arial", tfontsize = 40, tcolor = $88FFFFFF })
        Local items = ListItems(scene.spritesList1)-1
        For s = 0 To items        
          scene.SpritesList1[s]:OrbitStart({ updateRate = 10, target = scene.Sprites[0], time = 8000, direction = -1, distance = 350-s*25, easing = "linear", startAngle = 0, faceTarget = False, angleoffset = 90 })
          scene.SpritesList1[s]:YSortTarget(scene.Sprites[0])              
        Next
        
        scene.spritesList2 = fw.Sprite:NewFromText(scene.SpriteEngine, { blendEnabled = True, Layer = 3, text = "Hello World!", textattrs = { }, splitted = True, textrawidth = 0, textraheight = 0, tstyle = #BOLD+#ANTIALIAS, tfontname = "Arial", tfontsize = 70, tcolor = $2200FF00 })
        Local items = ListItems(scene.spritesList2)-1
        For s = 0 To items        
          scene.SpritesList2[s]:OrbitStart({ updateRate = 10, target = scene.Sprites[0], time = 4000, direction = -1, distance = 300, easing = "linear", startAngle = -s*8, faceTarget = True, angleoffset = 0 })
          scene.SpritesList2[s]:YSortTarget(scene.Sprites[0])              
        Next
        
        scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
        scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
        scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
        scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

        Local y, scale, speed = 400, 0.20, 0.10
        For Local i = 4 To 15
          scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
          scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
          y = 400 + (i-4)*10
          scale = 0.20 + (i-4)*0.05
          speed = 0.10 + (i-4)*0.10
        Next    
        
      EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawOrdered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene23)


;*******************************
;*** 24 : Sprite / Path      ***
;*******************************
Local scene24 = fw.Scene:New()
scene24:Setup(
  { Name   = "24 Sprites / Path",
    Init   = 
      Function(scene)
        ; Define a sprite engine
        Local bgFile = "glfx_test/BG_800x600.jpg"
        Local spriteFile1 = "glfx_test/planet.png"
        Local spriteTerrain = "glfx_test/i_parallax.png"
        Local spriteFile2 = "glfx_test/tree3.png"
        Local spriteArrow = "glfx_test/arrowed.png"
        scene.SpriteEngine = fw.SpriteEngine:Create(fw)
        scene.SpriteEngine:YSort_Set(False, True)
        scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
        scene.Background:Resize(1024, Nil, True)
        
        scene.Sprites = {}
        scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), blendEnabled = True })
        scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), blendEnabled = True })
        
        ; Create some path nodes
        Local node1 = GLFX.PathNode:New({ startPos = { x = 100, y = 100 }, startOffset = { x = 0, y = 0 }, endPos = { x = 600, y = 500 }, endOffset = { x = 0, y = 0 }, runtime = 5000, modex = "outquad", modey = "insine" })
        Local node2 = GLFX.PathNode:New({ startPos = { x = 600, y = 500 }, startOffset = { x = 0, y = 0 }, endPos = { x = 200, y = 250 }, endOffset = { x = 0, y = 0 }, runtime = 5000, modex = "linear", modey = "inquad" })
        Local node3 = GLFX.PathNode:New({ startPos = { x = 250, y = 250 }, startOffset = { x = 0, y = 0 }, endPos = { x = 100, y = 100 }, endOffset = { x = 0, y = 0 }, runtime = 5000, modex = "outsine", modey = "linear" })
        Local node4 = GLFX.PathNode:New({ startPos = scene.Sprites[0], startOffset = { x = 0, y = 0 }, endPos = { x = 600, y = 500 }, endOffset = { x = 0, y = 0 }, runtime = 2500, modex = "outsine", modey = "linear" })
        Local node5 = GLFX.PathNode:New({ startPos = { x = 250, y = 250 }, startOffset = { x = 0, y = 0 }, endPos = scene.Sprites[0], endOffset = { x = 0, y = 0 }, runtime = 2500, modex = "outsine", modey = "linear" })
        
        ; Create the sequences object
        Local sequences1 = GLFX.PathSequences:New()
        Local sequences2 = GLFX.PathSequences:New()
        ; Add a sequence
        sequences1:AddSequence("basic", { node1, node2, node3 }, True, Nil)
        sequences2:AddSequence("basic", { node4, node2, node5 }, True, Nil)
        ; Attach the sequences to the sprite and set up the starting sequence
        scene.Sprites[0]:AttachPaths(sequences1, "basic")
        scene.Sprites[1]:AttachPaths(sequences2, "basic")
        ; Start the path
        scene.Sprites[0]:PathStart()
        scene.Sprites[1]:PathStart()
        
        
        scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
        scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
        scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
        scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

        Local y, scale, speed = 400, 0.20, 0.10
        For Local i = 4 To 15
          scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
          scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
          y = 400 + (i-4)*10
          scale = 0.20 + (i-4)*0.05
          speed = 0.10 + (i-4)*0.10
        Next    
        
      EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawOrdered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene24)
      
      
;*******************************
;*** 25 : Sprite / Collisions***
;*******************************
Local scene25 = fw.Scene:New()
scene25:Setup(
  { Name   = "25 Sprites / Collisions",
    Init   = 
      Function(scene)
        ; Define a sprite engine
        Local bgFile = "glfx_test/BG_800x600.jpg"
        Local spriteFile1 = "glfx_test/planet.png"
        Local spriteTerrain = "glfx_test/i_parallax.png"
        Local spriteFile2 = "glfx_test/tree3.png"
        Local spriteArrow = "glfx_test/arrowed.png"
        scene.SpriteEngine = fw.SpriteEngine:Create(fw)
        scene.SpriteEngine:YSort_Set(False, True)
        scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
        scene.Background:Resize(1024, Nil, True)
        
        scene.Sprites = {}
        scene.Sprites[0] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = 200, y = 200, blendEnabled = True, ScaleW = 1, ScaleH = 1, AnchorX = 0, AnchorY = 0.5 })
        scene.Sprites[1] = fw.Sprite:Load(spriteFile1, scene.SpriteEngine, { Layer = 3, x = Rnd(1024), scaleW = 0.5, scaleH = 0.5, blendEnabled = True })
        
scene.Sprites[0].angleEnabled = True
scene.Sprites[0]:Rotator({ AngleList = { 359, 0 }, Timings = { 10000, 500 }, Loop = True, Easing = "linear" })
scene.Sprites[1].angleEnabled = True
scene.Sprites[1]:Rotator({ AngleList = { 359, 0 }, Timings = { 30000, 2500 }, Loop = True, Easing = "linear" })

        ; Create some path nodes
        Local node1 = GLFX.PathNode:New({ startPos = { x = 100, y = 100 }, startOffset = { x = 0, y = 0 }, endPos = { x = 800, y = 400 }, endOffset = { x = 0, y = 0 }, runtime = 15000, modex = "outquad", modey = "insine" })
        Local node2 = GLFX.PathNode:New({ startPos = { x = 800, y = 400 }, startOffset = { x = 0, y = 0 }, endPos = { x = 200, y = 250 }, endOffset = { x = 0, y = 0 }, runtime = 5000, modex = "linear", modey = "inquad" })
        Local node3 = GLFX.PathNode:New({ startPos = { x = 250, y = 250 }, startOffset = { x = 0, y = 0 }, endPos = { x = 100, y = 100 }, endOffset = { x = 0, y = 0 }, runtime = 15000, modex = "outsine", modey = "linear" })
        Local node4 = GLFX.PathNode:New({ startPos = scene.Sprites[0], startOffset = { x = 0, y = 0 }, endPos = { x = 600, y = 500 }, endOffset = { x = 0, y = 0 }, runtime = 2500, modex = "outsine", modey = "linear" })
        Local node5 = GLFX.PathNode:New({ startPos = { x = 250, y = 250 }, startOffset = { x = 0, y = 0 }, endPos = scene.Sprites[0], endOffset = { x = 0, y = 0 }, runtime = 12500, modex = "outsine", modey = "linear" })
        
        ; Create the sequences object
        Local sequences1 = GLFX.PathSequences:New()
        Local sequences2 = GLFX.PathSequences:New()
        ; Add a sequence
        sequences1:AddSequence("basic", { node1, node2, node3 }, True, Nil)
        sequences2:AddSequence("basic", { node4, node2, node5 }, True, Nil)
        ; Attach the sequences to the sprite and set up the starting sequence
        scene.Sprites[0]:AttachPaths(sequences1, "basic")
        scene.Sprites[1]:AttachPaths(sequences2, "basic")
        ; Start the path
        scene.Sprites[0]:PathStart()
        scene.Sprites[1]:PathStart()
        
        ; Setup collisions
        scene.Sprites[0]:MakePolyCollision(#POLY_BOX)
        scene.Sprites[0]:EnablePolyCollision(True, { scene.Sprites[1] }, 
          { OnCollision      = Function(s1, s2, data)
                                 If s1._t <> GetDate(True)
                                   DebugPrint("STILL COLLIDING:", s1, s2, data) 
                                   s1._t = GetDate(True)
                                 EndIf
                               EndFunction, 
            OnCollisionStart = Function(s1, s2, data) 
                                 DebugPrint("ON COLLISION START:", s1, s2, data) 
                                 s1._t = GetDate(True)
                                 s1.polyColor = { 0, 1, 0, 0.5 }
                                 s2.polyColor = { 0, 0, 1, 0.5 }
                               EndFunction,
            OnCollisionEnd   = Function(s1, s2, data) 
                                 DebugPrint("ON COLLISION END:", s1, s2, data) 
                                 s1.polyColor = { 1, 0, 0, 0.5 }
                                 s2.polyColor = { 1, 0, 0, 0.5 }
                               EndFunction })
        scene.Sprites[0]:EnablePolyCollisionRender(True)
        
        scene.Sprites[1]:MakePolyCollision(#POLY_OCTA)
        scene.Sprites[1]:EnablePolyCollision(True, { })
        scene.Sprites[1]:EnablePolyCollisionRender(True)
        
        scene.Sprites[1]:Stretcher( { StretchList = { { 1, 1 }, { 0.5, 0.5 }, { 2, 2 } }, 
                                      Timings = { 10000, 15000, 20000 },
                                      Loop = True,
                                      Easing = "linear" })       
        
        scene.Sprites[2] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -1000, blendEnabled = True })
        scene.Sprites[2]:ParallaxCreate({ horizontal = True, position = 200, stride = 0.20, ratems = 10 })
        scene.Sprites[3] = fw.Sprite:Load(spriteTerrain, scene.SpriteEngine, { Layer = 3, x = -Rnd(1024), blendEnabled = True })
        scene.Sprites[3]:ParallaxCreate({ horizontal = True, position = 300, stride = 0.50, ratems = 10 })

        Local y, scale, speed = 400, 0.20, 0.10
        For Local i = 4 To 15
          scene.Sprites[i] = fw.Sprite:Load(spriteFile2, scene.SpriteEngine, { Layer = 3, x = 0, scaleW = scale, scaleH = scale, blendEnabled = True })
          scene.Sprites[i]:ParallaxCreate({ horizontal = True, position = y, stride = speed, rateMS = 10 })
          y = 400 + (i-4)*10
          scale = 0.20 + (i-4)*0.05
          speed = 0.10 + (i-4)*0.10
        Next    
        
      EndFunction,
    
    UnInit = Function(scene) 
               scene.SpriteEngine:Destroy()
             EndFunction,
    Clear  = Function() EndFunction,
    Render = Function(scene)
               ; Draw all defined sprites
               scene.SpriteEngine:All_DrawOrdered()
             EndFunction,
    Update = Function() checkESC() EndFunction })

fw:AddScene(scene25)


  Local scene1 = fw.Scene:New()
  scene1:Setup(
    { Name   = "menu",
      Init   = 
        Function(scene)
          Local bgFile      = "glfx_test/menu_bg.jpg"
          
          scene.SpriteEngine = fw.SpriteEngine:Create(fw)
          scene.Background   = fw.Sprite:Load(bgFile, scene.SpriteEngine, { AnchorX = 0, ANchorY = 0 })
          scene.Background:Resize(prefs.width, Nil, True)
          
          scene.Sprites = {}
          
          Local subY, addX, YH = 0, 0, 28
          For mi = 0 To ListItems(menu)-1
            If mi > 15
              addX = prefs.width/2-50
              subY = 16*YH
            EndIf
            Local edge = ARGB($33, RGB(200-mi*5, 0, mi*5))
            scene.Sprites[mi] = GLFX.Sprite:NewFromText(
              scene.SpriteEngine, 
              { blendEnabled = True, 
                Layer = 1, 
                text = "[edge="..edge..",2][shadow=$22000000,4,#SHDWSOUTHEAST]" .. menu[mi][0], 
                textattrs = { }, 
                align_x = #LEFT,
                splitted = False, 
                textrawidth = 30, 
                textraheight = 10, 
                tstyle = #BOLD, 
                tfontname = #SANS, 
                tfontsize = YH-2, 
                tcolor = RGB(150+mi*5, 250-mi*5, 250-mi*5),
                color = { 0.7, 0.7, 0.7, 0.7 },
                AnchorX = 0,
                AnchorY = 0,
                x = 50+addX,
                y = 50 + mi*YH-subY })
               
               Local descList = menu[mi][1]
               scene.Sprites[mi].DescSprites = {}
               scene.Sprites[mi].descTweens = {}
               
               For Local di = 0 To ListItems(descList)-1        
                 Local s = GLFX.Sprite:NewFromText(
                              scene.SpriteEngine, 
                                { blendEnabled = True, 
                                  Layer = 1, 
                                  text = "[edge=$00000000,2][shadow=$44000000,2,#SHDWSOUTHEAST]" .. descList[di], 
                                  textattrs = { }, 
                                  splitted = False, 
                                  textrawidth = 10, 
                                  textraheight = 10, 
                                  tstyle = #ANTIALIAS+#BOLD, 
                                  tfontname = #SANS, 
                                  tfontsize = 18, 
                                  tcolor = RGB(100+di*4, 150+di*6, 150+di*7),
                                  AnchorX = 0,
                                  AnchorY = 0,
                                  x = prefs.width,
                                  y = 520 + di*18 })    
                 scene.Sprites[mi].DescSprites[di] = s
                 scene.Sprites[mi].descTweens[di] = -1
                 s:Hide()
               Next
                
               scene.Sprites[mi]._menuID = mi
              
            scene.Sprites[mi]:CollisionWithMouse(
              { Enabled = True, Events =
                { OnCollision = Function(sprite, cPoint)
                                  If IsLeftMouse()
                                    Switch sprite._menuID
                                      Case 0
                                        fw:ChangeScene("01 Scene Setup", 1500)
                                      Case 1
                                        fw:ChangeScene("02 Background Image", 1500)
                                      Case 2
                                        fw:ChangeScene("03 Sprite / Clone", 1500)
                                      Case 3
                                        fw:ChangeScene("04 Sprite / Actions", 1500)
                                      Case 4
                                        fw:ChangeScene("05 Sprite / Fade", 1500)
                                      Case 5
                                        fw:ChangeScene("06 Sprite / Angle", 1500)
                                      Case 6
                                        fw:ChangeScene("07 Sprite / Stretch", 1500)
                                      Case 7
                                        fw:ChangeScene("08 Sprite / Blink", 1500)
                                      Case 8
                                        fw:ChangeScene("09 Sprite / Flash", 1500)
                                      Case 9 
                                        fw:ChangeScene("10 Sprite / Parallax Item", 1500)
                                      Case 10
                                        fw:ChangeScene("11 Sprite / Parallax Strip", 1500)
                                      Case 11
                                        fw:ChangeScene("12 Sprite / Attach to mouse", 1500)
                                      Case 12
                                        fw:ChangeScene("13 Sprite / Follow", 1500)
                                      Case 13
                                        fw:ChangeScene("14 Sprite / Orbit", 1500)
                                      Case 14
                                        fw:ChangeScene("15 Sprite / Attach", 1500)
                                      Case 15
                                        fw:ChangeScene("16 Sprite / Boundaries", 1500)
                                      Case 16
                                        fw:ChangeScene("17 Sprite / Y Sorting", 1500)
                                      Case 17
                                        fw:ChangeScene("18 Sprite / Y Sorting, forced", 1500)
                                      Case 18
                                        fw:ChangeScene("19 Sprite / Y Sorting, Y Target", 1500)
                                      Case 19
                                        fw:ChangeScene("20 Sprite / With Mouse", 1500)
                                      Case 20
                                        fw:ChangeScene("21 Particles / Particle Systems", 1500)
                                      Case 21
                                        fw:ChangeScene("22 Particles / Particle Systems Fun", 1500)
                                      Case 22
                                        fw:ChangeScene("23 Sprites / From Text", 1500)
                                      Case 23
                                        fw:ChangeScene("24 Sprites / Path", 1500)
                                      Case 24
                                        fw:ChangeScene("25 Sprites / Collisions", 1500)
                                        
                                    EndSwitch
                                    
                                    GLFX.Sprite.SetCollisions(scene.Sprites, False)
                                    
                                  EndIf
                                EndFunction,
                  OnCollisionStart = Function(sprite, cPoint)
                                       ; Hilight effect
                                       sprite:Fader({ ColorList = { { 0.7, 0.7, 0.7, 0.7 }, { 1.0, 1.0, 1.0, 1.0 }, { 0.7, 0.7, 0.7, 0.7 } }, Timings = { 100, 150, 250 }, Loop = True, Easing = "linear" })
                  
                                       ; Show description
                                       For Local i = 0 To ListItems(sprite.descSprites)-1
                                         If GetType(sprite.descTweens[i]) <> #NUMBER
                                           tween.stop(sprite.descTweens[i])
                                         EndIf
                                         sprite.descSprites[i]:Show()
                                         sprite.descTweens[i] = tween.start(500, sprite.descSprites[i], { x = 50 }, "outquad")
                                       Next
                                     EndFunction,
                                     
                  OnCollisionEnd   = Function(sprite, cPoint)
                                       ; Hilight effect
                                       sprite:Fader({ ColorList = { { 1.0, 1.0, 1.0, 1.0 }, { 0.7, 0.7, 0.7, 0.7 } }, Timings = { 10, 350 }, Loop = False, Easing = "insine" })                  
                                       
                                       ; Hide description
                                       For Local i = 0 To ListItems(sprite.descSprites)-1
                                         If GetType(sprite.descTweens[i]) <> #NUMBER
                                           tween.stop(sprite.descTweens[i])
                                         EndIf
                                         sprite.descTweens[i] = tween.start(500, sprite.descSprites[i], { x = prefs.width }, "inquad", Function(s, i) s.descTweens[i] = -1 s.descSprites[i]:Hide() EndFunction, sprite, i)
                                       Next

                                     EndFunction
                  }})
                          
          Next
                        
        EndFunction,
      
      UnInit = Function(scene)
                 ; Fade out the background
                 tween.start(1250, scene.background, { color = { 0.0, 0.0, 0.0, 0.0 } }, "linear")
                 ; Get rid of the sprites
                 For Local mi = 0 To ListItems(menu)-1
                   tween.start(500+mi*50, scene.Sprites[mi], { x = prefs.width }, "outquad")
                 Next
                 ; After 1400ms destroy the sprite engine
                 SetTimeout(Nil, 
                            Function() scene.SpriteEngine:Destroy() 
                            EndFunction, 
                            1400)
               EndFunction,
      Clear  = Function() EndFunction,
      Render = 
        Function(scene)
          ; Draw all defined sprites
          scene.SpriteEngine:All_DrawUnorderedLayered()
        EndFunction,

      Update = 
        Function()
        EndFunction,
      })

  fw:AddScene(scene1)
  
  fw:ChangeScene("menu")
  
  fw:Init()
  
  fw:Start()


  Repeat
    WaitEvent()
  Forever
    
EndFunction

Function GLFX.Test_Background()
  /* This test shows how to use a sprite as a background, you can see
     the following background types accessible with the respective key
     number:
      1 : Static background
          An image is used as background, it is scaled to the current
          resolution.
      2 : Endless horizontal background
          Using a parallax level we can easily create an endless
          scrolling background.
      3 : Endless vertical background
          The same as <2> but vertical scroller.
      4 : Static with overscan
          An image bigger than the screen resolution is attached to the
          mouse but it can be easily attached to any sprite, this
          demonstrate a follow-background.
  */
  
  Local prefs = { width = 1024, 
                  height = 600, 
                  FlipSync = False, 
                  FPS = 120 }
  
  Local fw = GLFX:New(
    { Display  = 1, 
      Width    = prefs.Width,
      Height   = Prefs.Height,
      FlipSync = Prefs.FlipSync,
      FPS      = Prefs.FPS,
      Title    = "GLFX DEMO",
      UserMessage = "BG TEST: 1-Static 2-Hori 3-Vert 4-LockIn"
      })
      
  Local checkInput = 
    Function()
      If IsKeyDown("1")
        While IsKeyDown("1")
          Wait(5)
        Wend
        fw:ChangeScene("Static Background", 0) 
      ElseIf IsKeyDown("2")
        While IsKeyDown("2")
          Wait(5)
        Wend
        fw:ChangeScene("Horizontal Scrolling Background", 0)
      ElseIf IsKeyDown("3")
        While IsKeyDown("3")
          Wait(5)
        Wend
        fw:ChangeScene("Vertical Scrolling Background", 0)         

      ElseIf IsKeyDown("4")
        While IsKeyDown("4")
          Wait(5)
        Wend
        fw:ChangeScene("Follow Static Background", 0)         
        
      EndIf
    EndFunction
      
  
  fw:Init()
  
  /******************************************************************
   1 : STATIC BACKGROUND
   Simple example to show how to setup a static background using a
   Sprite.
   ******************************************************************/
  Local scene = fw.Scene:New()
  scene:Setup(
    { Name   = "Static Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_800x600.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background sprite creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(prefs.width, Nil, True)
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene)

  
  /******************************************************************
   2 : SIMPLE HORIZONTAL SCROLLER
   Simple example to show how to setup an horizontal scrolling
   background.
   ******************************************************************/  
  Local scene1 = fw.Scene:New()
  scene1:Setup(
    { Name   = "Horizontal Scrolling Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Scrolling.png"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(Nil, prefs.height, True)
                 
                 ; Crea un parallasse
                 scene.Background:ParallaxCreate(
                  { horizontal = True,
                    position   = 0,
                    stride     = 1,
                    ratems     = 10,
                    OnParallaxReset = Function(msg)
                                        DebugPrint("* EVENT => Event Type  : " .. msg.event .. ", Object Type : " .. msg.objecttype .. ", Object : " .. ToString(msg.object))
                                      EndFunction })
                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene1)
  
  /******************************************************************
   3 : SIMPLE VERTICAL SCROLLER
   Simple example to show how to setup an vertical scrolling
   background.
   ******************************************************************/  
  Local scene2 = fw.Scene:New()
  scene2:Setup(
    { Name   = "Vertical Scrolling Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Scrolling2.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(prefs.width, Nil, True)
                 
                 ; Crea un parallasse
                 scene.Background:ParallaxCreate(
                  { horizontal = False,
                    position   = 0,
                    stride     = 1,
                    ratems     = 10,
                    OnParallaxReset = Function(msg)
                                        DebugPrint("* EVENT => Event Type  : " .. msg.event .. ", Object Type : " .. msg.objecttype .. ", Object : " .. ToString(msg.object))
                                      EndFunction })
                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene2)  
  
  /******************************************************************
   4 : FOLLOW STATIC BACKGROUND
   Demonstrate how to make a follow background that can be attached
   to any sprite, in this case it will be attached to the mouse
   pointer.
   ******************************************************************/  
  Local scene4 = fw.Scene:New()
  scene4:Setup(
    { Name   = "Follow Static Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Big.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0.5, 
                                                     AnchorY = 0.5,
                                                     lockInside = True } )
                 
                 ; Attach the sprite to the mouse pointer
                 scene.Background:AttachToMouse({ updateRate = 15 })

                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene4)  
  
  ;---------------------------------
    
  fw:Init()
  
  fw:Start()
  
  fw:ChangeScene("Static Background")
  
  Repeat
    WaitEvent()
  Forever
  
EndFunction

Function GLFX.Test_Parallax()
  /* This test shows how to use a sprite as a parallax bg, you can see
     the following parallax types accessible with the respective key
     number:
      1 : Parallax Items
          A single parallax item is a parallax sprite repeated vertically
          or horixzontally.
      2 : Endless horizontal background
          Using a parallax level we can easily create an endless
          scrolling background.
      3 : Endless vertical background
          The same as <2> but vertical scroller.
      4 : Static with overscan
          An image bigger than the screen resolution is attached to the
          mouse but it can be easily attached to any sprite, this
          demonstrate a follow-background.
  */
  
  Local prefs = { width = 1024, 
                  height = 600, 
                  FlipSync = False, 
                  FPS = 120 }
  
  Local fw = GLFX:New(
    { Display  = 1, 
      Width    = prefs.Width,
      Height   = Prefs.Height,
      FlipSync = Prefs.FlipSync,
      FPS      = Prefs.FPS,
      Title    = "GLFX DEMO",
      UserMessage = "PRX TEST: 1-Items 2-Hori 3-Vert 4-LockIn"
      })
      
  Local checkInput = 
    Function()
      If IsKeyDown("1")
        While IsKeyDown("1")
          Wait(5)
        Wend
        fw:ChangeScene("Parallax Items", 0) 
      ElseIf IsKeyDown("2")
        While IsKeyDown("2")
          Wait(5)
        Wend
        fw:ChangeScene("Horizontal Scrolling Background", 0)
      ElseIf IsKeyDown("3")
        While IsKeyDown("3")
          Wait(5)
        Wend
        fw:ChangeScene("Vertical Scrolling Background", 0)         

      ElseIf IsKeyDown("4")
        While IsKeyDown("4")
          Wait(5)
        Wend
        fw:ChangeScene("Follow Static Background", 0)         
        
      EndIf
    EndFunction
      
  
  fw:Init()
  
  /******************************************************************
   1 : PARALLAX ITEMS
   Simple example to show how to setup a background using parallax
   items.
   ******************************************************************/
  Local scene = fw.Scene:New()
  scene:Setup(
    { Name   = "Parallax Items",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Scrolling.png"
                 Local PrxItemTree = "glfx_test/tree3.png"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Setup 30 parallax items
                 Local y, scale, speed = 150, 0.20, 0.01
                 scene.Sprites = {}
                 For Local i = 1 To 100
                   scene.Sprites[i] = fw.Sprite:Load(PrxItemTree, scene.SpriteEngine, { Layer = 2, x = Rnd(1024), AnchorY = 1, scaleW = scale, scaleH = scale, blendEnabled = True })
                   scene.Sprites[i]:ParallaxItem({ horizontal = True, position = y, stride = speed, rateMS = 10 })
                   
                   y = y + i*0.05
                   scale = scale + i*0.0001
                   speed = speed + i*0.0001
                 Next
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene)

  
  /******************************************************************
   2 : SIMPLE HORIZONTAL SCROLLER
   Simple example to show how to setup an horizontal scrolling
   background.
   ******************************************************************/  
  Local scene1 = fw.Scene:New()
  scene1:Setup(
    { Name   = "Horizontal Scrolling Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Scrolling.png"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(Nil, prefs.height, True)
                 
                 ; Crea un parallasse
                 scene.Background:ParallaxCreate(
                  { horizontal = True,
                    position   = 0,
                    stride     = 1,
                    ratems     = 10,
                    OnParallaxReset = Function(msg)
                                        DebugPrint("* EVENT => Event Type  : " .. msg.event .. ", Object Type : " .. msg.objecttype .. ", Object : " .. ToString(msg.object))
                                      EndFunction })
                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene1)
  
  /******************************************************************
   3 : SIMPLE VERTICAL SCROLLER
   Simple example to show how to setup an vertical scrolling
   background.
   ******************************************************************/  
  Local scene2 = fw.Scene:New()
  scene2:Setup(
    { Name   = "Vertical Scrolling Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Scrolling2.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0, 
                                                     AnchorY = 0 } )
                 
                 ; Uses the :Resize() method to resize the background
                 scene.Background:Resize(prefs.width, Nil, True)
                 
                 ; Crea un parallasse
                 scene.Background:ParallaxCreate(
                  { horizontal = False,
                    position   = 0,
                    stride     = 1,
                    ratems     = 10,
                    OnParallaxReset = Function(msg)
                                        DebugPrint("* EVENT => Event Type  : " .. msg.event .. ", Object Type : " .. msg.objecttype .. ", Object : " .. ToString(msg.object))
                                      EndFunction })
                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene2)  
  
  /******************************************************************
   4 : FOLLOW STATIC BACKGROUND
   Demonstrate how to make a follow background that can be attached
   to any sprite, in this case it will be attached to the mouse
   pointer.
   ******************************************************************/  
  Local scene4 = fw.Scene:New()
  scene4:Setup(
    { Name   = "Follow Static Background",
      Init   = Function(scene)
                 Local bgFile = "glfx_test/BG_Big.jpg"
                 
                 ; Sprite Engine Creation
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)
                 
                 ; Background creation loading a sprite
                 scene.Background = fw.Sprite:Load(bgFile, 
                                                   scene.SpriteEngine, 
                                                   { AnchorX = 0.5, 
                                                     AnchorY = 0.5,
                                                     lockInside = True } )
                 
                 ; Attach the sprite to the mouse pointer
                 scene.Background:AttachToMouse({ updateRate = 15 })

                    
               EndFunction,
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
      Clear  = Function() EndFunction,
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
      Update = Function() checkInput() EndFunction })
      
  fw:AddScene(scene4)  
  
  ;---------------------------------
  
  
  fw:Init()
  
  fw:Start()
  
  fw:ChangeScene("Parallax Items")
  
  Repeat
    WaitEvent()
  Forever
  
EndFunction

Function GLFX.Test_AnimatedSprites()
  /* This test shows how you can deal with animated sprites, it offers 3 examples
     you can select at runtime using the keys 1, 2, 3, you can also use the + key
     to clone the single sprite that is initially displayed.
     In the bottom left corner a box will show informations about the current scene.
     
     Method 1 : Use single frames loaded from the disk or preloaded into brushes
     Methos 2 : Use a sprite sheet
     Method 3 : Use an animated GIF
     */

  ; Let's store our preferences in a table
  Local prefs = { width    = 1024,      ; Screen width
                  height   = 600,       ; Screen Height
                  FlipSync = False,     ; WaitVBL setting
                  FPS      = 120 }      ; Target FPS
  
  ; Create a new context where the test will be built
  Local fw = GLFX:New(
    { Display  = 1,                     ; Display number to use
      Width    = prefs.Width,           ; Display width
      Height   = Prefs.Height,          ; Display Height
      FlipSync = Prefs.FlipSync,        ; WaitVBL setting
      FPS      = Prefs.FPS,             ; Target FPS
      Title    = "GLFX DEMO",           ; Window title
      UserMessage = "---"               ; User message to show in bottom left corner
                                        ; along with all the other informations
      })
      
  ; Let's create a function to check the user input
  Local checkInput = 
    Function()
      If IsKeyDown("1")
      ;----------------
       ; Check for the '1' key
       ; It is used to switch to the 'AnimatedSprites 1' scene
       While IsKeyDown("1")
          ; Wait for the key release before proceeding
          Wait(5)
        Wend
        fw:ChangeScene("AnimatedSprites 1")
        
      ElseIf IsKeyDown("2")
      ;--------------------
        ; Check for the '2' key
        ; It is used to switch to the 'AnimatedSprites 2' scene
        While IsKeyDown("2")
          ; Wait for the key release before proceeding
          Wait(5)
        Wend
        fw:ChangeScene("AnimatedSprites 2")
      
      ElseIf IsKeyDown("3")
      ;--------------------
        ; Check for the '3' key
        ; It is used to switch to the 'AnimatedSprites 2' scene
        While IsKeyDown("3")
          ; Wait for the key release before proceeding
          Wait(5)
        Wend
        fw:ChangeScene("AnimatedSprites 3")
      
      EndIf
    EndFunction
      
  ; Initialize the created context
  fw:Init()
  

  ; ---------------------------------------------------------------------
  ; Now we are going to create and setup the 3 scenes used to demonstrate
  ; and test the animated sprites.
  ; ---------------------------------------------------------------------
  
  ; SCENE 1 (Binded to the '1' key)
  Local scene = fw.Scene:New()          ; Create a new, empty scene
  scene:Setup(
    { Name   = "AnimatedSprites 1",
      Init   = Function(scene)
                 ; FIRST METHOD
                 ; ------------
                 ; In this test we will create an animated sprite defining every
                 ; single frame and loading the single frame from the disk.
                 ; ------------------------------------------------------------
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)      ; Create the sprite engine
                 fw.UserMessage = "+ to clone - 1, 2, 3 change scene" ; Setup the message to show in the info box
                 
                 ; Now we have to create a sprite
                 scene.sprite = fw.Sprite:New(scene.SpriteEngine,     ; Reference to the created sprite engine
                                              { x         = 600,      ; Initial horizontal position
                                                y         = 300,      ; Initial vertical position
                                                width     = 48,       ; Sprite Width
                                                height    = 90,       ; Sprite Height
                                                haveAlpha = True,     ; Have alpha channel?
                                                bgColor   = $FF0000,  ; Background color
                                                blendEnabled = True   ; Rendering enabled?
                                                })
                 
                 ; As said we are going to create the animation loading each needed
                 ; frame, if you want to create an identical sprite with the same
                 ; animations, you should be use the :Clone() method instead of loading
                 ; over and over the animation frames.
                 ; You can also pass brushId instead of file names, in case you have
                 ; preloaded your frames.

                 ; So, here is how to setup the frames we will use to create the
                 ; sprite animations: it's a list of the resources to be loaded,
                 ; image files or brushIds.
                 scene.sprite:SetAnimationFrames(
                  { "glfx_test/f1_32x60.png", 
                    "glfx_test/f2_32x60.png",
                    "glfx_test/f3_32x60.png",
                    "glfx_test/f4_32x60.png",
                    "glfx_test/f5_32x60.png",
                    "glfx_test/f6_32x60.png" }) 
                    
                 ; Now that we have defined which frames we need we can build
                 ; the animation sequences using those frames, animations are very
                 ; flexible and generally each frame has the following format:
                 ;   frame    = <frame reference number>            Mandatory
                 ;   duration = <frame duration in milliseconds>    Mandatory
                 ;   callback = <callback function to call when
                 ;               this frame is reached>             Optional
                 ; The callback function will receive in the <msg> table also
                 ; the <sprite> field which is the owner of the animation.
                 ; The callback function is useful in many cases, for example
                 ; to play a sound, to check for specific conditions, or to
                 ; chain animations, and so on...
                 ; In this example we have used it to move the sprite when the
                 ; 'walk' animation is running.
                 
                 ; So here is how you can define an animation sequence:
                 scene.sprite:NewAnimationSequence(
                   { frames = { { frame = 0, duration = 1000 },       ; Defines all the needed frames
                                { frame = 1, duration = 150, 
                                    Callback = Function(msg) 
                                                 Local dy = msg.sprite.y + 30
                                                 If dy > 640
                                                   msg.sprite.y = -40
                                                   dy = -40
                                                 EndIf
                                                 msg.sprite:MoveTo({ y = dy, time = 600 })
                                               EndFunction },
                                { frame = 2, duration = 150 },
                                { frame = 3, duration = 150 },
                                { frame = 4, duration = 150 },
                                { frame = 5, duration = 150 } },
                     name = "walking1",                               ; Setup the animation name
                     type = "loop",                                   ; Define the animation type which
                                                                      ; can be "oneshot", "loop", "pingpong", "random"
                     })                                
                      
                 ; Now that we have defined the animation we can set it as the current animation
                 ; The first argument is the animation name, the second argument is
                 ; the first animation frame to render.
                 scene.sprite:SetAnimationSequence("walking1", 0)
                 
                 ; Finally we can start to playback the current sprite animation
                 scene.sprite:AnimationStart()
                
               EndFunction,
               
      UnInit = Function(scene)
                 ; When we UnInit the scene we have to destroy the sprite engine
                 scene.SpriteEngine:Destroy()
               EndFunction,
               
      Clear  = Function() 
                 ; We don't have any custo clear screen function
               EndFunction,
               
      Render = Function(scene)
                 ; Render all the sprites without any particular order
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
               
      Update = Function(scene)
                 ; During the update call we have to check the input and
                 ; If the user hits the '+' key we will clone the sprite,
                 ; all will be cloned! Animations, callbacks, collisions, etc...
                 checkInput()
                 If IsKeyDown("+")
                   Local s = scene.sprite:Clone()
                   s:SetAnimationSequence("walking1", 0) ; We want to make every frame walk on its own
                                                         ; and not to move with the other ones
                   s.x = Rnd(900)+50
                   s.y = Rnd(500)+50
                 EndIf
               EndFunction })

  ; Let's add the first scene to the GLFX context.
  fw:AddScene(scene)
  

  ; SCENE 2 (Binded to the '2' key
  Local scene2 = fw.Scene:New()           ; Create a new, empty scene
  scene2:Setup(
    { Name   = "AnimatedSprites 2",
      Init   = Function(scene)
                 ; SECOND METHOD
                 ; -------------
                 ; In this test we will create an animated sprite using a 
                 ; spritesheet loaded from the disk.
                 ; ------------------------------------------------------------
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)          ; Create the SpriteEngine
                 fw.UserMessage = "+ to clone - 1, 2, 3 change scene"     ; Setup the user message in the info box
                 
                 ; Let's create a sprite
                 scene.sprite = fw.Sprite:New(scene.SpriteEngine,         ; Reference to the created sprite engine
                                              { x         = 600,          ; Initial horizontal position
                                                y         = 300,          ; Initial vertical position
                                                width     = 48,           ; Sprite Width
                                                height    = 90,           ; Sprite Height
                                                haveAlpha = True,         ; Have alpha channel?
                                                bgColor   = $FF0000,      ; Background color
                                                blendEnabled = True       ; Rendering enabled?
                                                })

                 ; Now we are going to define the animation frames using a spritesheet,
                 ; it's simple, just look below:
                 scene.sprite:SetAnimationFrames(
                                           "SPRITESHEET::glfx_test/framesheet_tiny.png",  ; The spritesheet we want to use
                                           { x = 0, y = 0,                                ; Coordinates of the first frame
                                             width = 30, height = 37,                     ; Frame width & height
                                             frames_per_row = 6,                          ; How many frames are in each row
                                             frames = 30                                  ; How many frames we want to load
                                             })
                 
                 ; Now we are going to create a new animation sequence, for details please
                 ; have a look at the first created scene:
                 Local speed = 30       ; Shortcut for the frame speed (delay)
                 scene.sprite:NewAnimationSequence(
                    { frames = { { frame = 0, duration = speed, callback =
                                   Function(msg)
                                     ; In the first frame we check for the respawn to 
                                     ; the left and we also move the sprite to the right
                                     Local s = msg.sprite
                                     If s.x > 1080
                                       s.x = -50
                                     EndIf
                                     Local dx = s.x + 100
                                     s:MoveTo({ x = dx, time = speed*30 })
                                   EndFunction
                                   },
                                 { frame = 1, duration = speed },
                                 { frame = 2, duration = speed },
                                 { frame = 3, duration = speed },
                                 { frame = 4, duration = speed },
                                 { frame = 5, duration = speed },
                                 { frame = 6, duration = speed },
                                 { frame = 7, duration = speed },
                                 { frame = 8, duration = speed },
                                 { frame = 9, duration = speed },
                                 { frame = 10, duration = speed },
                                 { frame = 11, duration = speed },
                                 { frame = 12, duration = speed },
                                 { frame = 13, duration = speed },
                                 { frame = 14, duration = speed },
                                 { frame = 15, duration = speed },
                                 { frame = 16, duration = speed },
                                 { frame = 17, duration = speed },
                                 { frame = 18, duration = speed },
                                 { frame = 19, duration = speed },
                                 { frame = 20, duration = speed },
                                 { frame = 21, duration = speed },
                                 { frame = 22, duration = speed },
                                 { frame = 23, duration = speed },
                                 { frame = 24, duration = speed },
                                 { frame = 25, duration = speed },
                                 { frame = 26, duration = speed },
                                 { frame = 27, duration = speed },
                                 { frame = 28, duration = speed },
                                 { frame = 29, duration = speed } },
                     name = "walking1",       ; The animation sequence name
                     type = "loop",           ; The animation sequence mode
                     })                                
                      
                    
                 ; Like for the scene 1 we set the current animation
                 scene.sprite:SetAnimationSequence("walking1", 0)
                 
                 ; And finally we start the animation playback
                 scene.sprite:AnimationStart()
                 
               EndFunction,
               
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
               
      Clear  = Function() EndFunction,
      
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
               
      Update = Function(scene)
                 checkInput()
                 If IsKeyDown("+")
                   Local s = scene.sprite:Clone()
                   s.x = Rnd(900)+50
                   s.y = Rnd(500)+50
                   s:SetAnimationSequence("walking1", 0)
                 EndIf
               EndFunction })
  
  ; Add this newly created scene to the GLFX context
  fw:AddScene(scene2)


  ; SCENE 3 (Binded to the '3' key)
  Local scene3 = fw.Scene:New()           ; Create a new, empty scene
  scene3:Setup(
    { Name   = "AnimatedSprites 3", 
      Init   = Function(scene)
                 ; THIRD METHOD
                 ; ------------
                 ; In this test we will use an animated Gif image as our source
                 ; but this method is more generic, you can use any supported animation
                 ; for this prupose.
                 ; ------------------------------------------------------------
                 scene.SpriteEngine = fw.SpriteEngine:Create(fw)        ; Create the new sprite engine
                 fw.UserMessage = "+ to clone - 1, 2, 3 change scene"   ; Setup the user message for the info box
                 
                 ; Let's create a sprite
                 scene.sprite = fw.Sprite:New(scene.SpriteEngine,         ; Reference to the created sprite engine
                                              { x         = 600,          ; Initial horizontal position
                                                y         = 300,          ; Initial vertical position
                                                width     = 79,           ; Sprite Width
                                                height    = 111,          ; Sprite Height
                                                haveAlpha = True,         ; Have alpha channel?
                                                bgColor   = $FF0000,      ; Background color
                                                blendEnabled = True       ; Rendering enabled?
                                                })
                 
                 ; Now we define the animation frames using an animated gif as soruce
                 scene.sprite:SetAnimationFrames("ANIMATION::glfx_test/anim.gif",
                                           { x = 0, y = 0,                ; Starting position
                                             width = 79, height = 111,    ; Frames size
                                             transparency = $080000       ; Transparent color
                                             })
                 
                 ; Now we are going to create a new animation sequence, for details please
                 ; have a look at the first created scene:
                 Local speed = 100
                 scene.sprite:NewAnimationSequence(
                    { frames = { { frame = 0, duration = speed },
                                 { frame = 1, duration = speed },
                                 { frame = 2, duration = speed },
                                 { frame = 3, duration = speed },
                                 { frame = 4, duration = speed },
                                 { frame = 5, duration = speed },
                                 { frame = 6, duration = speed },
                                 { frame = 7, duration = speed },
                                 { frame = 8, duration = speed },
                                 { frame = 9, duration = speed },
                                 { frame = 10, duration = speed },
                                 { frame = 11, duration = speed },
                                 { frame = 12, duration = speed },
                                 { frame = 13, duration = speed },
                                 { frame = 14, duration = speed },
                                 { frame = 15, duration = speed }
                                 },
                     name = "walking1",
                     type = "loop",
                     })                                
                      
                    
                 ; As before, define the animation sequence and start its playback
                 scene.sprite:SetAnimationSequence("walking1", 0)
                 scene.sprite:AnimationStart()
                 
               EndFunction,
               
      UnInit = Function(scene)
                 scene.SpriteEngine:Destroy()
               EndFunction,
               
      Clear  = Function() EndFunction,
      
      Render = Function(scene)
                 scene.SpriteEngine:All_DrawUnorderedLayered()
               EndFunction,
               
      Update = Function(scene)
                 checkInput()
                 If IsKeyDown("+")
                   Local s = scene.sprite:Clone()
                   s.x = Rnd(900)+50
                   s.y = Rnd(500)+50
                   s:SetAnimationSequence("walking1", 0)
                 EndIf
               EndFunction })
  
  ; Add this scene too, to the the context
  fw:AddScene(scene3)

  ; Now that we hace all the scenes ready we can initialize GLFX
  fw:Init()
  
  ; ...and start it!
  fw:Start()
  
  ; Switch to the scene 1, we are ready!
  fw:ChangeScene("AnimatedSprites 1")

  ; Loop where all events are processed and handled
  Repeat
    WaitEvent()
  Forever
  
EndFunction

; Debug log to the console is enabled so you can view what's appening
DBG.Console.Enable(True, True)
DBG.Console.AddChannel(GLFXCh)


; OpenResourceMonitor()

;GLFX.TEST()
;GLFX.Test_HeightMap()
;GLFX.Test_AnimatedSprites()
;GLFX.Test_Background()
;GLFX.Test_Parallax()
;        1:Items
;        2:Horizontal
;        3:Vertical
;        4:Horizontal+Items
; FARE : GLFX.Test_Tiles()
; GLFX.TileMap:New()
; Usa un brush come render buffer <- brutta, bruttissima idea
;             :Draw()
;             :Destroy()
;             :Move()
;             :MoveTo()

; :: PROBLEMA ::
; Quando allargo lo schermo le coordinate del mouse fanno come gli pare
; e mi sfava le collisioni
; 29/04/2017 : Risolto con GLFX.PixelSize[], convertire le altre funzioni
;              che hanno le coordinate del mouse tipo :AttachToMouse()
; 04/05/2017 : Fixato anche :AttachToMouse()
; --------------


